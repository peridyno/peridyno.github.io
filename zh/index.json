[
{
	"uri": "https://peridyno.github.io/zh/installation/window/",
	"title": "Windows平台安装",
	"tags": [],
	"description": "",
	"content": "1、源码安装 源码安装使用Visual Studio进行编译，使用C++语言，可对源代码进行修改。\n2、二进制安装 二进制安装使用pip安装，使用python语言，可以创建自己的场景，无法对源代码进行修改。\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/",
	"title": "布料仿真",
	"tags": [],
	"description": "",
	"content": "物理仿真布料模拟是一种基于物理原理的计算机图形学技术，用于模拟和渲染布料在现实世界中的行为和外观。它广泛应用于电影、游戏和虚拟现实等领域，以实现逼真的布料效果。\n布料模拟的过程涉及到多个物理计算，如质量、弹性、摩擦力和空气阻力等。这些计算可以使用拉格朗日动力学或有限元法等方法来实现。通过不断迭代计算，可以更新布料的状态和位置，以反映其与外界交互的效果。\n在模拟过程中，还需要考虑到布料的材质、纹理和光照等因素，以达到逼真的视觉效果。这可以通过材质属性、纹理映射和光照模型等技术来实现。例如，可以根据布料的材质属性调整其表面的粗糙度、反射率和透明度，使其在不同光照条件下呈现出真实的外观。\n物理仿真布料模拟为电影、游戏和虚拟现实提供了逼真的布料效果，使得角色和场景更加生动和真实。它也为设计师和艺术家提供了一种创造和控制布料行为的工具，使其能够在虚拟环境中实现特定的视觉效果和表现风格。\n  CPD_ClothDrop: CPD_ClothDrop\n  CPD_ClothOnTable: CPD_ClothOnTable\n  CPD_ClothOverBall_1：CPD_ClothOverBall_1\n  CPD_ClothOverBall_3: CPD_ClothOverBall_3\n  CPD_ClothOverBall_6：CPD_ClothOverBall_6\n  CPD_RealTimeCloth_v1：CPD_RealTimeCloth_v1\n  CPD_RealTimeCloth_v2：CPD_RealTimeCloth_v2\n  CPD_RotateCylinder：CPD_RotateCylinder\n  CPD_ShootingCloth：CPD_ShootingCloth\n  GL_ClothWithCollision：GL_ClothWithCollision\n  Qt_ClothStudio：Qt_ClothStudio\n  2021年，李旻辰等人[1]构造出用于薄片、细线等物体的连续碰撞的势能函数，将IPC方法用于求解布料和毛发的连续碰撞。该方法收敛性优于经典的约束方法求解，且在收敛的情况下保证了无论时间步长多大，求解的毛发也不会穿透。\n[1] Li, Minchen, Danny M. Kaufman, and Chenfanfu Jiang. \u0026ldquo;Codimensional Incremental Potential Contact.\u0026ldquo;SIGGRAPH 2021.\n"
},
{
	"uri": "https://peridyno.github.io/zh/installation/window/source/",
	"title": "Windows平台源码安装",
	"tags": [],
	"description": "",
	"content": "1、安装环境  Windows 平台：支持Windows10、 Windows11系统； 显卡：推荐使用Nvidia类型的显卡（大多数示例需要Nvidia显卡支持）； CPU：Intel i7+； OpenGL：4.6+； 内存：8G+。  2、运行依赖  IDE: Visual studio 2017+（推荐Visual studio 2019） CUDA: CUDA Toolkit 11.0+（推荐CUDA Toolkit 11.4） cmake：3.17+  可选依赖：\n Qt: 5.0版本以上（推荐5.14.2） VulkanSDK：(https://vulkan.lunarg.com/)  3、安装 使用 git 命令克隆项目及子模块：\ngit clone --recursive https://gitee.com/peridyno/peridyno.git\r4、编译项目 使用cmake软件对项目进行编译：\n 设置文件源码路径和编译路径； 点击Configure； 点击Generate。  5、运行项目（GLFW平台） 使用Visual studio打开编译好的项目，选择Examples的中示例作为启动项，运行。下图是GL_ParticleFluid示例的运行效果图：\n6、安装交互式Qt平台（可选） PeriDyno引擎有三种交互式平台，详情请见3.6节。Qt框架主要是面向工程研发人员设计的交互式框架。该框架可以通过场景图的形式将仿真任务依次连接起来，开发人员可对每个节点属性进行编辑。推荐安装Qt5.12以上版本。\n运行Qt安装包，注册Qt账号登录安装： Qt高版本必须联网注册才能安装。低版本(以Qt5.14.2为例)断网后，安装可以免注册。\n\r设置安装路径： 勾选以下几项： 将Qt加入环境变量： 打开cmake软件，查找qt，勾选PERIDYNO_Qt5_GUI选项。接着依次点击Configure和Generate: 重新打开Visual studio，此时可以发现解决方案资源管理器中多出Qt目录及相关示例程序： 运行Qt_Bricks项目，可看到Qt框架界面： 基于Qt6的安装 Qt 6已不再提供编译之后的安装包，需要先下载online installer完成安装。考虑到国内安装下载速度非常缓慢，建议用清华镜像下载安装\n./qt-unified-linux-x64-online.exe --mirror https://mirrors.tuna.tsinghua.edu.cn/qt\r其余安装流程可参见官方教程。\n安装过程中注意选择MSVC 2019 64-bit以及Qt 5 Compatibility Module两个包（以VS 2019为例，其他请选择相应选项）\n7、Vulkan安装（可选） PeriDyno在cmake阶段支持三种模式，分别是CUDA、Vulkan和NoGPU。Vulkan模式支持其它类型的显卡，但是Vulkan模式中示例较少。安装请确保您的显卡支持Vulkan API。\n下载VulkanSDK: 安装： 将Vulkan加入环境变量： 8、Peridyno插件安装（可选） PeriDyno支持插件导入。在正常情况下，为了提高编译速度，默认插件是不启用的。如需要使用插件，在cmake阶段勾选PERIDYNO_LIBRARY_PLUGIN选项： 重新Configure和Generate后将会出现可选的插件： 勾选后再次Configure和Generate，此时Visual Studio软件解决方案中将出现Plugin文件夹： 9、Windows平台安装常见问题 问题1：软件安装有顺序要求吗？\n 答：优先安装Visual studio。其它软件无顺序要求。CUDA和Qt会自动查找Visual studio路径安装。\n 问题2：PeriDyno引擎对显卡有什么要求？\n 答：PeriDyno在cmake阶段支持三种模式，分别是CUDA、Vulkan和NoGPU。CUDA模式只支持Nvidia类型的显卡。用户尽可能的选择高性能的显卡，显卡 显存不低于4G。Vulkan模式支持其它类型的显卡。NoGPU模式不需要显卡支持。目前PeriDyno引擎绝大多数示例都是用CUDA模式开发的。Vulkan和 NoGPU模式示例较少，推荐用户使用CUDA模式进行学习。\n 问题3：QT程序运行过程中报错：qt.qpa.plugin: Could not find the Qt platform plugin \u0026ldquo;windows\u0026rdquo; in\n 答：可尝试在Windows系统中添加如下系统变量名\n变量名：QT_QPA_PLATFORM_PLUGIN_PATH\n变量值：C:\\Qt\\Qt5.15.2\\5.15.2\\msvc2019_64\\plugins（以VS 2019为例，其他注意替换相应目录）\n如仍然有问题可尝试将C:\\Qt\\Qt{Qt版本号}{Qt版本号}\\msvc{VS平台}\\plugins的platforms目录完整拷贝到生成的bin目录下。\n "
},
{
	"uri": "https://peridyno.github.io/zh/examples/tutorials/gl_glfwgui/",
	"title": "创建GLFW窗口",
	"tags": [],
	"description": "",
	"content": "1、布料模拟 案例位置：examples/Cuda/Tutorials/GL_GlfwGUI\n功能介绍：该案例主要展示PeriDyno引擎glfw窗口。\n案例说明： 该项目是一个空的项目，向用户介绍如何创建一个glfw窗口。\n2、程序实现 接下来介绍案例的实现过程：\n 创建创建:  int main(int, char**) { GlfwApp app; app.initialize(1024, 768); app.mainLoop(); return 0; } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_bricks/",
	"title": "刚体仿真",
	"tags": [],
	"description": "",
	"content": "1、刚体仿真 案例位置：examples/Cuda/QtGUI/Qt_Bricks\n功能介绍：该案例展示了Qt框架下 RigidBodySystem 类的的基本使用。主要用于测试Qt框架下的刚体系统的仿真功能。\n案例说明：初始化时地面放置了许多正方体刚体，空中放置了四面体和球体刚体。程序运行后四面体和球体掉落，与正方体刚体发生碰撞。该案例主要用于测试Qt框下，刚体系统运动是否正确。\n2、程序实现 接下来介绍案例的实现过程：\n 创建Ghost Particles:  std::shared_ptr\u0026lt;GhostParticles\u0026lt;DataType3f\u0026gt;\u0026gt; createGhostParticles() { auto ghost = std::make_shared\u0026lt;GhostParticles\u0026lt;DataType3f\u0026gt;\u0026gt;(); std::vector\u0026lt;Vec3f\u0026gt; host_pos; std::vector\u0026lt;Vec3f\u0026gt; host_vel; std::vector\u0026lt;Vec3f\u0026gt; host_force; std::vector\u0026lt;Vec3f\u0026gt; host_normal; std::vector\u0026lt;Attribute\u0026gt; host_attribute; Vec3f low(-0.2, -0.015, -0.2); Vec3f high(0.2, -0.005, 0.2); Real s = 0.005f; int m_iExt = 0; float omega = 1.0f; float half_s = -s / 2.0f; int num = 0; for (float x = low.x - m_iExt * s; x \u0026lt;= high.x + m_iExt * s; x += s) { for (float y = low.y - m_iExt * s; y \u0026lt;= high.y + m_iExt * s; y += s) { for (float z = low.z - m_iExt * s; z \u0026lt;= high.z + m_iExt * s; z += s) { Attribute attri; attri.setFluid(); attri.setDynamic(); host_pos.push_back(Vec3f(x, y, z)); host_vel.push_back(Vec3f(0)); host_force.push_back(Vec3f(0)); host_normal.push_back(Vec3f(0, 1, 0)); host_attribute.push_back(attri); } } } ghost-\u0026gt;statePosition()-\u0026gt;resize(num); ghost-\u0026gt;stateVelocity()-\u0026gt;resize(num); ghost-\u0026gt;stateForce()-\u0026gt;resize(num); ghost-\u0026gt;stateNormal()-\u0026gt;resize(num); ghost-\u0026gt;stateAttribute()-\u0026gt;resize(num); ghost-\u0026gt;statePosition()-\u0026gt;assign(host_pos); ghost-\u0026gt;stateVelocity()-\u0026gt;assign(host_vel); ghost-\u0026gt;stateForce()-\u0026gt;assign(host_force); ghost-\u0026gt;stateNormal()-\u0026gt;assign(host_normal); ghost-\u0026gt;stateAttribute()-\u0026gt;assign(host_attribute); host_pos.clear(); host_vel.clear(); host_force.clear(); host_normal.clear(); host_attribute.clear(); return ghost; }  创建场景图及边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setUpperBound(Vec3f(0.5, 1, 0.5)); scn-\u0026gt;setLowerBound(Vec3f(-0.5, 0, -0.5)); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-0.1f, 0.0f, -0.1f), Vec3f(0.1f, 1.0f, 0.1f), 0.005, true);  创建基于Ghost GhostParticles的流体粒子:  auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleSystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(-0.1, 0.0, -0.1), Vec3f(0.105, 0.1, 0.105), 0.005); auto ghost = scn-\u0026gt;addNode(createGhostParticles()); auto incompressibleFluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;GhostFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;connect(incompressibleFluid-\u0026gt;importFluidParticles()); ghost-\u0026gt;connect(incompressibleFluid-\u0026gt;importBoundaryParticles()); incompressibleFluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems());  创建渲染节点:  { auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); fluid-\u0026gt;statePointSet()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender); // A simple color bar widget for node \tauto colorBar = std::make_shared\u0026lt;ImColorbar\u0026gt;(); colorBar-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorBar-\u0026gt;inScalar()); // add the widget to app \tfluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorBar); } { auto ghostRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ghostRender-\u0026gt;setColor(Vec3f(1, 0.5, 0)); ghostRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_OBJECT_SHADER); ghost-\u0026gt;statePointSet()-\u0026gt;connect(ghostRender-\u0026gt;inPointSet()); ghost-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ghostRender); } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/rigidbody/gl_bricks/",
	"title": "刚体动力学",
	"tags": [],
	"description": "",
	"content": "1、刚体动力学 案例位置：examples/Cuda/Rigidbody/GL_Bricks\n功能介绍：该案例主要用于测试刚体系统的仿真功能。案例展示了 RigidBodySystem 类的的基本使用。刚体系统已经包含球体、圆柱体、圆锥体、长方体等常用的几何体仿真模型。用户只需要设置几何形体的中心位置、边长以及旋转矩阵等简单的参数就可以构成出常见的几何模型。\n案例说明：案例中展示了刚体动力学功能。初始化时地面放置了许多正方体刚体，空中放置了四面体和球体刚体。程序运行后四面体和球体掉落，与正方体刚体发生碰撞。该案例主要用于测试PeriDyno刚体动力学系统是否正确。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建刚体模型，包括正方体、四面体和球体：  auto rigid = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.5, 0, 0); BoxInfo box; for (int i = 8; i \u0026gt; 1; i--) for (int j = 0; j \u0026lt; i + 1; j++) { box.center = 0.5f * Vec3f(0.5f, 1.1 - 0.13 * i, 0.12f + 0.21 * j + 0.1 * (8 - i)); box.halfLength = 0.5f * Vec3f(0.065, 0.065, 0.1); rigid-\u0026gt;addBox(box, rigidBody); } SphereInfo sphere; sphere.center = Vec3f(0.5f, 0.75f, 0.5f); sphere.radius = 0.025f; RigidBodyInfo rigidSphere; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.95f, 0.5f); sphere.radius = 0.025f; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.65f, 0.5f); sphere.radius = 0.05f; rigid-\u0026gt;addSphere(sphere, rigidSphere); TetInfo tet; tet.v[0] = Vec3f(0.5f, 1.1f, 0.5f); tet.v[1] = Vec3f(0.5f, 1.2f, 0.5f); tet.v[2] = Vec3f(0.6f, 1.1f, 0.5f); tet.v[3] = Vec3f(0.5f, 1.1f, 0.6f); rigid-\u0026gt;addTet(tet, rigidSphere);  创建渲染节点：  auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender);  创建触点接触计算节点：  //TODO: to enable using internal modules inside a node \t//Visualize contact normals \tauto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); rigid-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(elementQuery); auto contactMapper = std::make_shared\u0026lt;ContactsToEdgeSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactMapper-\u0026gt;inContacts()); contactMapper-\u0026gt;varScale()-\u0026gt;setValue(0.02); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactMapper); auto wireRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); wireRender-\u0026gt;setColor(Vec3f(0, 1, 0)); contactMapper-\u0026gt;outEdgeSet()-\u0026gt;connect(wireRender-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(wireRender); //Visualize contact points \tauto contactPointMapper = std::make_shared\u0026lt;ContactsToPointSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactPointMapper-\u0026gt;inContacts()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactPointMapper); auto pointRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRender-\u0026gt;setColor(Vec3f(1, 0, 0)); contactPointMapper-\u0026gt;outPointSet()-\u0026gt;connect(pointRender-\u0026gt;inPointSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRender); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/sph/gl_ghostsph/",
	"title": "幽灵粒子(Ghost Particles)",
	"tags": [],
	"description": "",
	"content": "1、流体仿真 案例位置：examples/Cuda/SPH/GL_GhostSPH\n功能介绍：SPH方法存在虚假的数值表面张力伪影、不满足质量守恒约束，无法获取液体与固体的真实内力等问题。Ghost SPH方案通过一种新的粒子采样算法解决了这一问题。该算法在周围的空气和固体中创建了一个狭窄的Ghost粒子层作为边界条件，以更加真实的模拟物理现象。\n案例说明： 案例展示了GhostParticles的流体仿真功能。如下图所示流体粒子从Ghost粒子层滑落，没有发生穿透现象。\n2、程序实现 接下来介绍案例的实现过程：\n 创建Ghost Particles:  std::shared_ptr\u0026lt;GhostParticles\u0026lt;DataType3f\u0026gt;\u0026gt; createGhostParticles() { auto ghost = std::make_shared\u0026lt;GhostParticles\u0026lt;DataType3f\u0026gt;\u0026gt;(); std::vector\u0026lt;Vec3f\u0026gt; host_pos; std::vector\u0026lt;Vec3f\u0026gt; host_vel; std::vector\u0026lt;Vec3f\u0026gt; host_force; std::vector\u0026lt;Vec3f\u0026gt; host_normal; std::vector\u0026lt;Attribute\u0026gt; host_attribute; Vec3f low(-0.2, -0.015, -0.2); Vec3f high(0.2, -0.005, 0.2); Real s = 0.005f; int m_iExt = 0; float omega = 1.0f; float half_s = -s / 2.0f; int num = 0; for (float x = low.x - m_iExt * s; x \u0026lt;= high.x + m_iExt * s; x += s) { for (float y = low.y - m_iExt * s; y \u0026lt;= high.y + m_iExt * s; y += s) { for (float z = low.z - m_iExt * s; z \u0026lt;= high.z + m_iExt * s; z += s) { Attribute attri; attri.setFluid(); attri.setDynamic(); host_pos.push_back(Vec3f(x, y, z)); host_vel.push_back(Vec3f(0)); host_force.push_back(Vec3f(0)); host_normal.push_back(Vec3f(0, 1, 0)); host_attribute.push_back(attri); } } } ghost-\u0026gt;statePosition()-\u0026gt;resize(num); ghost-\u0026gt;stateVelocity()-\u0026gt;resize(num); ghost-\u0026gt;stateForce()-\u0026gt;resize(num); ghost-\u0026gt;stateNormal()-\u0026gt;resize(num); ghost-\u0026gt;stateAttribute()-\u0026gt;resize(num); ghost-\u0026gt;statePosition()-\u0026gt;assign(host_pos); ghost-\u0026gt;stateVelocity()-\u0026gt;assign(host_vel); ghost-\u0026gt;stateForce()-\u0026gt;assign(host_force); ghost-\u0026gt;stateNormal()-\u0026gt;assign(host_normal); ghost-\u0026gt;stateAttribute()-\u0026gt;assign(host_attribute); host_pos.clear(); host_vel.clear(); host_force.clear(); host_normal.clear(); host_attribute.clear(); return ghost; }  创建场景图及边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setUpperBound(Vec3f(0.5, 1, 0.5)); scn-\u0026gt;setLowerBound(Vec3f(-0.5, 0, -0.5)); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-0.1f, 0.0f, -0.1f), Vec3f(0.1f, 1.0f, 0.1f), 0.005, true);  创建基于Ghost GhostParticles的流体粒子:  auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleSystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(-0.1, 0.0, -0.1), Vec3f(0.105, 0.1, 0.105), 0.005); auto ghost = scn-\u0026gt;addNode(createGhostParticles()); auto incompressibleFluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;GhostFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;connect(incompressibleFluid-\u0026gt;importFluidParticles()); ghost-\u0026gt;connect(incompressibleFluid-\u0026gt;importBoundaryParticles()); incompressibleFluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems());  创建渲染节点:  { auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); fluid-\u0026gt;statePointSet()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender); // A simple color bar widget for node \tauto colorBar = std::make_shared\u0026lt;ImColorbar\u0026gt;(); colorBar-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorBar-\u0026gt;inScalar()); // add the widget to app \tfluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorBar); } { auto ghostRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ghostRender-\u0026gt;setColor(Vec3f(1, 0.5, 0)); ghostRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_OBJECT_SHADER); ghost-\u0026gt;statePointSet()-\u0026gt;connect(ghostRender-\u0026gt;inPointSet()); ghost-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ghostRender); } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/peridynamics/gl_cloth/",
	"title": "布料模拟",
	"tags": [],
	"description": "",
	"content": "1、布料模拟 案例位置：examples/Cuda/Peridynamics/GL_Cloth\n功能介绍：主要用于测试布料仿真功能。该案例展示了 Cloth 类的的基本使用。\n案例说明：场景由两个模型组成，一个是上方的布料模型，一个是下方的静态球体。案例展示了布料从空中掉落，并与静态球体发生碰撞，最后掉落到地面的仿真过程。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真边界以及布料节点：  auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); root-\u0026gt;loadCube(Vec3f(0), Vec3f(1), 0.005f, true); root-\u0026gt;loadShpere(Vec3f(0.5, 0.7f, 0.5), 0.08f, 0.005f, false, true); auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;Cloth\u0026lt;DataType3f\u0026gt;\u0026gt;()); cloth-\u0026gt;loadParticles(getAssetPath() + \u0026#34;cloth/cloth.obj\u0026#34;); root-\u0026gt;addParticleSystem(cloth);  创建渲染节点：  auto pointRenderer = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRenderer-\u0026gt;setColor(Vec3f(1, 0.2, 1)); pointRenderer-\u0026gt;setColorMapMode(GLPointVisualModule::PER_OBJECT_SHADER); cloth-\u0026gt;statePointSet()-\u0026gt;connect(pointRenderer-\u0026gt;inPointSet()); cloth-\u0026gt;stateVelocity()-\u0026gt;connect(pointRenderer-\u0026gt;inColor()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRenderer); cloth-\u0026gt;setVisible(true); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); cloth-\u0026gt;statePointSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_clothdrop/",
	"title": "布料垂坠模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_ClothDrop\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。布料的上面两个点被固定，在重力作用逐渐落下的效果。\n2、程序实现  创建场景图和边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, -1, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); scn-\u0026gt;setGravity(Vec3f(0,-200,0));  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15, 120, 0.001, 0.0001)); //also try: \t//auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15, 1200, 0.001, 0.0001)); \t//auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15, 12000, 0.001, 0.0001)); \tcloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/mesh_drop.obj\u0026#34;); auto custom = std::make_shared\u0026lt;ManualControl\u0026lt;DataType3f\u0026gt;\u0026gt;(); cloth-\u0026gt;statePosition()-\u0026gt;connect(custom-\u0026gt;inPosition()); cloth-\u0026gt;stateVelocity()-\u0026gt;connect(custom-\u0026gt;inVelocity()); cloth-\u0026gt;stateFrameNumber()-\u0026gt;connect(custom-\u0026gt;inFrameNumber()); cloth-\u0026gt;stateAttribute()-\u0026gt;connect(custom-\u0026gt;inAttribute()); cloth-\u0026gt;animationPipeline()-\u0026gt;pushModule(custom); cloth-\u0026gt;setSelfContact(false);  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(1, 1, 1)); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); cloth-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/heightfield/gl_capillarywave/",
	"title": "水面涟漪仿真",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/HeigthField/GL_CapillaryWave\n功能介绍：案例中展示了 CapillaryWave 类的的基本使用。表面张力波 （Capillary wave） 是延著液体行进的波，其动力学及相速度是由表面张力的效应所决定。在水面上的表面张力波常称为涟漪，例如在现实世界中微风吹过水面产生涟漪的现象。表面张力波是自然界常见的现象，其波长多半在数公分以内，而相速度约0.2-0.3米/秒。PeriDyno 引擎支持涟漪效果实时仿真，可由用户调节海浪区域大小。\n案例说明：该案例主要用于模拟测试水面涟漪的仿真功能。初始状态，给水面中间部分水域设置一个高度，模拟中间水域下落后产生的涟漪效果。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建CapillaryWave节点，用于模拟水上的波纹。  auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;CapillaryWave\u0026lt;DataType3f\u0026gt;\u0026gt;());  创建渲染节点：  auto mapper = std::make_shared\u0026lt;HeightFieldToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); root-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inHeightField()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(0, 0.2, 1.0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); "
},
{
	"uri": "https://peridyno.github.io/zh/topics/rigidbodydynamics/broadphase/",
	"title": "宽阶段碰撞检测",
	"tags": [],
	"description": "刚体碰撞
",
	"content": "刚体碰撞流程主要分为五部分。首先，对可能产生碰撞的n个刚体构建包围盒树（包括：AABB树（轴平行包围盒树，Aixe align bounding box tree）和OBB树（有向包围盒树），下述将以AABB树为例），将AABB树的根节点对应的区域，作为的碰撞区域；然后，使用Z空间填充曲线（Z-SFC）对碰撞区域进行划分，生成单元空间，并使用Morton码（莫顿码）对单元空间进行编码，生成Z空间填充曲线（Z-SFC）索引，以便后续构建内部节点的邻接关系；接着，根据生成的Z空间填充曲线（Z-SFC）索引自底向上、并行的构建压缩八叉树；其次，对构建出来的压缩八叉树进一步并行的恢复成完整的八叉树结构；最后，根据完整的八叉树自底向上的进行并行碰撞检测。接下来详细介绍每一个步骤：\n1、构建AABB树 AABB树中每个子节点也是AABB树的结构，它只需要log(n)的时间复杂度就能完成节点的搜索过程。假设我们要检测刚体1-9的碰撞。根据刚体1-9的轮廓生成AABB包围盒。接下来通过执行以下操作来构建AABB树：   把刚体1作为AABB树的根节点；\n  把刚体2和刚体1作比较，判断刚体2与刚体1所在的区域有没有交集。如果有交集则继续判断刚体2是否与刚体1的子集有交集，将其加入到与节点1有公共交集的子集的最小的公共子节点之后。如果刚体2与刚体1没有交集，则根据刚体1和刚体2的区域重新生成一个公共区域，作为节点1和节点2的公共节点；\n  重复步骤b)，直达把所有的节点都加入到AABB树中，并将AABB树的根节点对应的区域，作为的碰撞区域。\n  2、构建Z空间填充曲线（Z-SFC）和索引 Z空间填充曲线（Z-SFC）技术易于实现，并行化高，可用于将二维或三维空间中的区域进行有效的线性化。假设在D维空间中，将空间的每个维度均匀的分成k分，则会产生 个相等的非重叠的小空间单元。例如使用Z空间填充曲线（Z-SFC）对二维正方形区域进行划分，结果如下图所示；根据划分的结果按顺序进行标记： 例如刚体1-9进行空间划分之后可得到： 通常将划分的结果左下角的小单元空间设置为Z空间填充曲线（Z-SFC）的起点，并对区域进行Morton码编码。在二维空间中，假设存在刚体P的重心位置坐标为（x，y），则将该坐标作为叶子节点的坐标。经过Z空间填充曲线（Z-SFC）划分之后，该点所属的单元将为。对于刚体9横跨多个区域的需要进行去重操作$(\\left\\lfloor {{2^k}x/D} \\right\\rfloor ,\\left\\lfloor {{2^k}y/D} \\right\\rfloor )$，此时刚体9的Z空间填充曲线索引设置为数值最小的区域即11110000，并保存这几个区域的信息。二维空间创建Z空间填充曲线索引如下图所示： 根据Z空间填充曲线（Z-SFC）索引，我们可以创建不同层级的Z空间填充曲线（Z-SFC），如下图所示： 3、基于GPU的并行压缩八叉树的构建 不同于CPU的八叉树构建，基于GPU的并行八叉树的构建是自底向上构建的。根据叶子节点所在的位置，反向生成内部节点，进而确定内部节点的关系，从而确定树的结构。自底向上生成树的过程适用于GPU并行计算。具体的实施过程如下图所示：   构建叶子节点\n  将待检测的刚体1-9作为输入点，使用长度为2n-1（n表示刚体的数量）的数组A保存这9个输入点作为叶子节点。\n  根据叶子节点的坐标生成Z空间填充曲线（Z-SFC）索引。\n  根据叶子节点的Z空间填充曲线（Z-SFC）索引，并行对数组A中的9个元素进行排序。\n    生成内部节点和八叉树的后序遍历 对每个相邻的叶子，使用Z空间填充曲线（Z-SFC）索引中的公共位并行的找出最小公共父节点（LCA）。例如，相邻叶子节点1和节点2的Z空间填充曲线（Z-SFC）索引分别为11000001和11000010，由此可得到节点1和节点2的最小公共父节点为11000000。\n 分配n − 1个GPU线程。 对于数组A中的每两个相邻叶子（例如数组A[i]和A[i + 1]），并行生成最小公共父节点，其最小公共节点的Z空间填充曲线索引为叶子节点A[i]和A[i + 1]的Z空间填充曲线索引的最大公共部分，并将其值存储在A[n + i]中。 根据公共节点的Z空间填充曲线索引，对不同层的内部节点进行并行排序。如果元素L1包含在元素L2中，则将L2元素置于L1元素之前；否则，将L1元素置于L2元素之前。图7中的（c）显示了排序后的内部节点，其中可能会生成重复项（N2和N3）。 在数组A的后半部分中，删除重复项。 对于没有相同Z空间填充曲线（Z-SFC）索引的两个相邻内部节点，并行地从当前节点开始遍历数组A的后半部分，删除它们重复的项。根据Z空间填充曲线（Z-SFC）索引对数组A进行并行排序，进而可以得到压缩八叉树的后序遍历。    生成压缩八叉树 我们可以注意到数组A的末尾可能会有一些空元素。这是无法避免的，因为CUDA不支持动态内存分配和释放，因此必须在编译时就创建大小为2n−1的数组。然而仅仅得到八叉树的后续遍历还无法确定树的结构。（a）所示节点A和节点B属于同级的情况，因此它们的公共的父节点为C；（b）所示节点B是节点N的子节点，与节点A是相邻节点。（c）所示节点B是节点A的父节点。\n为了进一步确定八叉树的内部结构，执行以下步骤：\n 分配两倍大小的叶子和内部节点数的数组B（最多4n-2）。将数组A复制到数组B中。 分配（叶子节点数+ 内部节点数-1）个GPU线程。 对于数组B的前半部分中的每两个相邻节点，根据Z空间填充曲线（Z-SFC）索引并行的生成最小公共父节点。例如对于数组B中的每两个相邻叶子B[i]和B[i + 1]，并行生成内部节点，并将其存储在B[n + i]中。 根据Z空间填充曲线（Z-SFC）索引对生成的结果进行并行排序，将所有的内部节点和它们的副本将归并到一起。 对于具有相同Z空间填充曲线（Z-SFC）索引并且至少其中一个不是副本的节点，建立内部节点的父子关系。最终生成的压缩八叉树下图所示：     4、从压缩八叉树中恢复完整的八叉树 两个相邻的节点N4和节点3，其中节点3是节点N4的子节点。通过Z空间填充曲线（Z-SFC）索引来计算两个节点之间的深度差。例如节点N4和节点3的Z空间填充曲线（Z-SFC）索引分别为11000000和11001101，则深度差为2（节点N4处于深度1，节点3处于深度3，假设根深度为0）。这种差异表明压缩八叉树中缺少节点N4和节点3之间的中间节点。 为了生成完整的八叉树结构执行：\n 分配大小等于数组A长度的线程，即（叶子数+内部节点数）。 计算每个节点与其父节点的深度差并累加，以获取插入内部节点所需的内存总数（由于GPU上不能进行动态的分配内存）。 根据每个节点与其父节点之间的深度差添加新的节点。当深度差大于1时，并行的在其中间插入新的节点。如下图所示，在节点N4和节点3之间插入了一个内部节点CH1，以获得完整八叉树结构。  5、使用八叉树结构自底向上的对刚体进行并行的碰撞检测 从叶子节点开始自底向上进行检测，当发现碰撞点时进一步进行细粒度检测，直到找到发生碰撞的叶子节点对。  假设刚体2和刚体3发生了碰撞。针对待碰撞检测刚体，计算刚体所有八叉树层数及对应叶子节点，利用步骤4中八叉树自底向上查询所有重叠区域对应刚体的AABB包围盒。 如果找到碰撞包围盒，针对上述步骤中得到的AABB包围盒进一步对刚体2和刚体3的边界进行精确的碰撞检测，结果如下图所示：   "
},
{
	"uri": "https://peridyno.github.io/zh/reference/reflection/",
	"title": "C++反射",
	"tags": [],
	"description": "",
	"content": "1、反射是什么 假设我们已知某个类的名称，那么如何通过类名称字符串来动态生成类的对象？\n在Java编程中，这并不是个问题。但是C++的语言特性决定了其并不支持通过类名称字符串”ClassXX”来生成对象的，也就是说在C++中我们可以使用ClassXX* object =new ClassXX来生成对象，但是不能通过ClassXX* object=new “ClassXX”来生成对象。这导致我们对节点和模块功能扩展的时候无法做到自适应扩展，也就是如果我们额外引入一个新的功能模块，仿真引擎无法动态感知到它的存在。\n反射机制引入的就是为了解决仿真节点和功能模块的自适应扩充问题，从而避免代码之间的深度耦合。\n2、C++反射原理 参考代码src/Framework/Object.h。\n\r3、扩展模块如何支持反射 所有需要支持反射的类需要继承自Object。以src/Dynamics/ParticleSystem/SummationDensity.h中实现的类为例，其支持反射的流程包含两个步骤\n  派生Object或者Object的子类\ntemplate\u0026lt;typename TDataType\u0026gt; class SummationDensity : public virtual ParticleApproximation\u0026lt;TDataType\u0026gt;   接口申明\nDECLARE_CLASS(SummationDensity)\r//或者\rDECLARE_TCLASS(SummationDensity, TDataType)\r其中SummationDensity对应类的名称，TDataType对应模板参数\n  接口实现\nIMPLEMENT_TCLASS(SummationDensity)\r//或者\rIMPLEMENT_TCLASS(SummationDensity, TDataType)\r其中通过DECLARE_CLASS/DECLARE_TCLASS通过定义静态变量完成对SummationDensity的注册。\n  DECLARE_TCLASS和IMPLEMENT_TCLASS要求定义在同一头文件内，该方式对于实现文件为cpp后缀的类有效。然而当前NVCC的编译器依然存在一定问题，如果实现文件为.cu后缀，则定义的static变量无法完成初始化，需要通过额外的类来完成。\n\r一个可行的解决方案是针对每一个静态链接库引入一个额外的类来完成初始化，在initializeParticleSystem.h中引入\nclass ParticleSystemInitializer : public Object { public: ParticleSystemInitializer(); }; const static ParticleSystemInitializer particleSystemInitializer; 同时再initializeParticleSystem.cpp中定义实现如下构造函数来完成对.cu文件中定义的类进行显式调用。\nParticleSystemInitializer::ParticleSystemInitializer() { TypeInfo::New\u0026lt;LinearDamping\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;ParticleIntegrator\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;ImplicitViscosity\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;DensityPBD\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;SummationDensity\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;VariationalApproximateProjection\u0026lt;DataType3f\u0026gt;\u0026gt;(); } 最后在待运行的Qt项目的CMakeLists.txt中加入\u0026quot;WHOLEARCHIVE\u0026quot;（链接自动注册类的lib库）。例如，运行Qt_VtkVisualModule项目，并期望在项目中自动注册initializeParticleSystem.cpp中类。在{peridyno_Code_path}/examples/Qt_VtkVisualModule/CMakeLists.txt中添加 ：\n"
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/simulation/",
	"title": "仿真管线",
	"tags": [],
	"description": "",
	"content": "1、仿真管线运行时序图 2、支持模块类型 仿真管线支持的模块类型包括：\n 计算模块ComputeModule，虚函数接口为：  virtual void compute();  拓扑模块TopologyModule，虚函数接口为：  virtual void updateTopology()；  输入模块InputModule，虚函数接口为：  输入接口取决于外设类型，详情参加交互章节。\n\r 输出模块OutputModule，虚函数接口为：  virtual void flush() {};  约束模块ConstraintModule，虚函数接口为：  virtual void constrain()\r 用户自定义模块CustomModule，虚函数接口为：  virtual void applyCustomBehavior(); "
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/scenegraph/",
	"title": "场景图",
	"tags": [],
	"description": "",
	"content": "场景图主要包含节点管理、场景遍历、场景更新等功能。\n1、节点管理 节点管理功能包括：\n 添加节点：  template\u0026lt;class TNode, class ...Args\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(Args\u0026amp;\u0026amp; ... args) template\u0026lt;class TNode\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(std::shared_ptr\u0026lt;TNode\u0026gt; tNode) 其中TNode是节点（Node）的派生类型，Args则对应节点构造过程所需要的参数:\n 删除节点：  void deleteNode(std::shared_ptr\u0026lt;Node\u0026gt; node); 2、场景遍历 场景图（SceneGraph）将节点抽象为有向无环图（Directed Acyclic Graph）中的顶点，数据的连接则抽象为顶点之间的有向边。因此一个简单的包含四个节点的场景可以用如下的有向无环图来表示：\n对场景图节点的遍历可采用类似DAG的遍历算法来完成，目前主要提供两类接口：\n 先序遍历，调用方式为:  void traverseForward(Action* act); ​ 或者:\ntemplate\u0026lt;class Act, class ... Args\u0026gt; void traverseBackward(Args\u0026amp;\u0026amp; ... args) 对应上图的场景，先序遍历得到的节点序列如下：\n 后序遍历:  void traverseBackward(Action* act); ​\t或着:\ntemplate\u0026lt;class Act, class ... Args\u0026gt; void traverseBackward(Args\u0026amp;\u0026amp; ... args) 对应上图的场景，后序遍历得到的节点序列如下：\nAction为遍历过程中对每个节点进行的操作，可用于更新节点、获取特定类型模块等操作。\n\r​\t整个场景图的遍历采用广度优先算法完成：\nvoid BFS(Node* node, NodeList\u0026amp; nodeQueue, std::map\u0026lt;ObjectId, bool\u0026gt;\u0026amp; visited) {\rvisited[node-\u0026gt;objectId()] = true;\rnodeQueue.push_back(node);\rauto exports = node-\u0026gt;getExportNodes();\rfor (auto port : exports) {\rauto exNode = port-\u0026gt;getParent();\rif (exNode != nullptr \u0026amp;\u0026amp; !visited[node-\u0026gt;objectId()]) {\rBFS(exNode, nodeQueue, visited);\r}\r}\rauto outFields = node-\u0026gt;getOutputFields();\rfor each (auto f in outFields) {\rauto\u0026amp; sinks = f-\u0026gt;getSinks();\rfor each (auto sink in sinks) {\rif (sink != nullptr) {\rauto exNode = dynamic_cast\u0026lt;Node*\u0026gt;(sink-\u0026gt;parent());\rif (exNode != nullptr \u0026amp;\u0026amp; !visited[exNode-\u0026gt;objectId()]) {\rBFS(exNode, nodeQueue, visited);\r}\r}\r}\r}\r};\rvoid SceneGraph::updateExecutionQueue()\r{\rif (!mQueueUpdateRequired)\rreturn;\rmNodeQueue.clear();\rstd::map\u0026lt;ObjectId, bool\u0026gt; visited;\rfor (auto\u0026amp; nm : mNodeMap) {\rvisited[nm.first] = false;\r}\rfor (auto\u0026amp; n : mNodeMap) {\rif (!visited[n.first])\t{\rNode* node = n.second.get();\rDFS(node, mNodeQueue, visited);\r}\r}\rvisited.clear();\rmQueueUpdateRequired = false;\r}\r3、局部遍历 以上述有向无环图为例，当节点B的内容发生变化时，我们需要对依次更新B及B以后的节点C和D，同时注意到A的数据并不依赖于B。因此B的内容更新不应该影响A的内容。为了实现场景图的局部更新，提供如下接口用于更新特定节点及后续节点：\nvoid traverseForward(std::shared_ptr\u0026lt;Node\u0026gt; node, Action* act); ​ 或者:\ntemplate\u0026lt;class Act, class ... Args\u0026gt; void traverseForward(std::shared_ptr\u0026lt;Node\u0026gt; node, Args\u0026amp;\u0026amp; ... args); ​\t采用广度优先算法完成：\n//Used to traverse the scene graph from a specific node void BFS(Node* node, NodeList\u0026amp; nodeQueue, std::map\u0026lt;ObjectId, bool\u0026gt;\u0026amp; visited) { visited[node-\u0026gt;objectId()] = true; nodeQueue.push_back(node); auto exports = node-\u0026gt;getExportNodes(); for (auto port : exports) { auto exNode = port-\u0026gt;getParent(); if (exNode != nullptr \u0026amp;\u0026amp; !visited[node-\u0026gt;objectId()]) { BFS(exNode, nodeQueue, visited); } } auto outFields = node-\u0026gt;getOutputFields(); for each (auto f in outFields) { auto\u0026amp; sinks = f-\u0026gt;getSinks(); for each (auto sink in sinks) { if (sink != nullptr) { auto exNode = dynamic_cast\u0026lt;Node*\u0026gt;(sink-\u0026gt;parent()); if (exNode != nullptr \u0026amp;\u0026amp; !visited[exNode-\u0026gt;objectId()]) { BFS(exNode, nodeQueue, visited); } } } } }; void SceneGraph::traverseForward(std::shared_ptr\u0026lt;Node\u0026gt; node, Action* act) { std::map\u0026lt;ObjectId, bool\u0026gt; visited; for (auto\u0026amp; nm : mNodeMap) { visited[nm.first] = false; } NodeList list; BFS(node.get(), list, visited); for (auto it = list.begin(); it != list.end(); ++it) { Node* node = *it; act-\u0026gt;start(node); act-\u0026gt;process(node); act-\u0026gt;end(node); } list.clear(); visited.clear(); } 4、场景更新  更新运行队列:  void updateExecutionQueue(); 更新的时机主要依赖于场景图中的节点以及连接关系是否发生变动，一旦任意一项发生改变，场景的节点执行队列会在下次执行节点功能的时候优先更新运行队列。\n 更新节点状态:  void propagateNode(std::shared_ptr\u0026lt;Node\u0026gt; node); 当某个特定节点的运行状态发生改变时，如节点的配置参数发生改变，场景图可以通过调用propagateNode()函数对后续所有依赖该节点的节点的状态进行更新。\n5、其他功能 参见SceneGraph.h和SceneGraph.cpp相应实现。\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/overview/",
	"title": "概要",
	"tags": [],
	"description": "Peridyno概述。
",
	"content": "1、PeriDyno概述 PeriDyno是一个基于CPU/GPU混合架构实现的实时物理仿真引擎。通过基于数据（Field）-\u0026gt;模块（Module）-\u0026gt;节点（Node）-\u0026gt;场景图（SceneGraph）的通用物理仿真框架，将仿真计算、渲染、交互以及底层算法有效分离，实现了算法模块高效复用。PeriDyno旨在解决通用物理仿真任务的增量开发、集成与模块复用难题，实现端云协同环境一套仿真计算代码零成本迁移、多平台复用等目标，其解决的核心问题包括：\n 物理仿真数据表示的完备性问题； 复杂仿真场景作用机理的模块化难题； 仿真数据与仿真算法模块的统一计算图； 端云协同环境复杂仿真任务的可交互性。  目前，PeriDyno支持模拟布料、刚体、柔性体、铰链、高度场、流体、弹性体和断裂等典型物理仿真场景，同时支持多物理场耦合仿真，具备良好的扩展性，可方便的辅助研发人员开发与验证新的仿真算法。\n2、PeriDyno特性 PeriDyno具有以下特性，可以有效地模拟复杂的物理场景：\n  模板编程：PeriDyno以模板的形式支持CPU/GPU兼容的典型数据结构，包括一维数组、二维数组、三维数组、动态数组以及稀疏八叉树等数据结构；\n  高度模块化：整体从上到下模块化，因此可以通过扩展现有组件轻松获得自定义行为；\n  复杂耦合：支持通用物理仿真任务，包括刚体、流体、形变体以及多物理场耦合仿真；\n  高性能：核心仿真算法做到100%GPU并行化，实现了仿真、渲染和交互的高效协同。\n  3、学习PeriDyno 文档由浅入深从安装指引、引擎架构、技术专题以及仿真案例等方面，逐步向用户介绍PeriDyno引擎，帮助用户尽快上手PeriDyno引擎：\n 安装指引：介绍PeriDyno引擎在不同平台下的安装过程； 引擎框架：介绍PeriDyno引擎整体框架； 技术专题：介绍PeriDyno引擎现有的仿真算法； 仿真案例：介绍典型仿真案例，帮助用户尽快熟悉掌握PeriDyno引擎。  更多资源参见\u0026laquo;Games 401: 泛动引擎(PeriDyno)物理仿真编程与实践\u0026raquo;：https://www.bilibili.com/video/BV15M4y1U76M?p=1\n"
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/",
	"title": "场景管理",
	"tags": [],
	"description": "",
	"content": "1、场景示意图 泛动引擎通过场景图（Scene Graph）对节点（Node）、模块（Module）以及数据（Field）在内的全要素进行统一管理。下图展示了一个包含四个仿真节点的场景图：\n场景中每个节点内置两条管线，分别为仿真管线和渲染管线，用于完成仿真计算、渲染及交互功能。在GUI视图中，双击节点可以得到如下图所示的管线示意图： 如上图所示，当前支持的数据传递方向主要支持四类：节点输出—\u0026gt;节点输入、模块输出—\u0026gt;模块输入、节点输入—\u0026gt;模块状态变量和模块输出—\u0026gt;节点输出。\n\r2、如何创建场景 接下来以流体仿真案例为例，展示如何基于PeriDyno引擎创建一个完整的演示demo，完整流程包含以下四个步骤：\n 创建场景图及边界：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setUpperBound(Vec3f(1.5, 1, 1.5)); scn-\u0026gt;setLowerBound(Vec3f(-0.5, 0, -0.5));  添加仿真节点：  //创建一个正方体 auto cube = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); cube-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.6, 0.85, 0.5)); cube-\u0026gt;varLength()-\u0026gt;setValue(Vec3f(0.1, 0.65, 0.1)); cube-\u0026gt;graphicsPipeline()-\u0026gt;disable(); //将正方体转换为粒子 auto sampler = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeSampler\u0026lt;DataType3f\u0026gt;\u0026gt;()); sampler-\u0026gt;varSamplingDistance()-\u0026gt;setValue(0.005); sampler-\u0026gt;graphicsPipeline()-\u0026gt;disable(); cube-\u0026gt;outCube()-\u0026gt;connect(sampler-\u0026gt;inCube()); auto initialParticles = scn-\u0026gt;addNode(std::make_shared\u0026lt;MakeParticleSystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); sampler-\u0026gt;statePointSet()-\u0026gt;promoteOuput()-\u0026gt;connect(initialParticles-\u0026gt;inPoints()); //添加流体仿真节点 auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); //fluid-\u0026gt;loadParticles(Vec3f(0.5, 0.2, 0.4), Vec3f(0.7, 1.5, 0.6), 0.005); initialParticles-\u0026gt;connect(fluid-\u0026gt;importInitialStates()); //添加边界节点 auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); ; boundary-\u0026gt;loadCube(Vec3f(-0.5, 0, -0.5), Vec3f(1.5, 2, 1.5), 0.02, true); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;bowl/bowl.sdf\u0026#34;, false); fluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems());  设置渲染相关节点：  auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); fluid-\u0026gt;statePointSet()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender); // A simple color bar widget for node auto colorBar = std::make_shared\u0026lt;ImColorbar\u0026gt;(); colorBar-\u0026gt;varMax()-\u0026gt;setValue(5.0f); colorBar-\u0026gt;varFieldName()-\u0026gt;setValue(\u0026#34;Velocity\u0026#34;); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorBar-\u0026gt;inScalar()); // add the widget to app fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorBar);  创建应用界面，以GLFW框架为例，其算法流程如下：  GlfwApp app; app.setSceneGraph(createScene()); app.initialize(1024, 768); app.mainLoop(); \r如不显式设置渲染引擎，引擎默认采用内置基于OpenGL实现的GLRenderEngine来完成。\n\r仿真结果如下：\n 如果使用Qt界面，可通过如下代码构建：  QtApp app; app.setSceneGraph(createScene()); app.initialize(1024, 768); app.mainLoop(); 仿真结果以及场景图展示如下： 样例参见 examples/Cuda/SPH/GL_ParticleFluid。\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/installation/window/binary/",
	"title": "Windows平台二进制安装",
	"tags": [],
	"description": "",
	"content": "1、安装环境  Windows 平台：Windows11系统 显卡：使用Nvidia类型的显卡 CPU：Intel i7+ OpenGL：4.6+ 内存：8G+  2、运行依赖  Python: 3.12 CUDA:CUDA Toolkit 12.2  3、安装 使用pip命令安装项目：\npip install PyPeridyno\r推荐使用管理员权限安装在真实环境中。\n4、测试 复制测试代码到新文件GL_GlfwGUI.py：\nimport PyPeridyno as dyno\rscn = dyno.SceneGraph()\rapp = dyno.GLfwApp()\rapp.set_scenegraph(scn)\rapp.initialize(1920, 1080, True)\rapp.set_window_title(\u0026quot;Empty GUI\u0026quot;)\rapp.main_loop()\r使用shell运行文件：python -u \u0026quot;/path/GL_GlfwGUI.py\u0026quot;\n运行结果如下图所示，说明安装正常： 5、使用 使用前先导入PyPeridyno包：import PyPeridyno as dyno\n使用方法：\n  python中创建类使用PyPeridyno包中的类即可，python会调用C++代码。类名与C++中的类名相同。例如：C++代码：std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();，更改为python代码：scn = dyno.SceneGraph()。\n  对于C++中使用了泛型的类，python中改为类名+泛型简写的形式，例如：C++中CodimensionalPD\u0026lt;DataType3f\u0026gt;在python中为CodimensionalPD3f。\n  python中所有方法名称均与C++方法相同，只是从驼峰命名更改为下划线命名。引用运算符(.和-\u0026gt;)，统一更改为python中的点运算符(.)，例如：C++代码：scn-\u0026gt;setLowerBound();，更改为python：scn.set_lower_bound()。\n  python中的dyno.Vector3f()与C++中的dyno::Vec3f()功能相同，但python中输入数据需要使用列表[]，如果数据相同，不可以使用C++中的简写形式，例如：C++：dyno::Vec3f(1)，更改为python：dyno.Vector3f([1,1,1])。\n  使用PyPeridyno时，不支持C++方法中的默认参数，需要完整的写出参数。例如：C++代码：CodimensionalPD\u0026lt;DataType3f\u0026gt;(0.15, 120, 0.001, 0.0001)，改为python代码为：CodimensionalPD3f(0.15, 120, 0.001, 0.0001, \u0026quot;default\u0026quot;)，需要添加\u0026quot;default\u0026quot;默认参数。\n  python使用C++中的枚举类型，命名与C++完全相同，调用时需要写出枚举类型名称，例如：GLPointVisualModule::PER_OBJECT_SHADER，更改为python：dyno.GLPointVisualModule().ColorMapMode.PER_OBJECT_SHADER。\n  python中导入文件的路径书写方法与C++相同，需要添加dyno.get_asset_path()+相对路径，绝对路径也可接受。默认路径为C:\\ProgramData\\Peridyno\\data，这是在pip安装的时候创建的，不包含源码安装中的数据，有需要可以在data下载。\n  其余使用方法与C++代码相同。\n6、pip安装常见问题 问题1：为什么要使用管理员权限？\n 答：pip执行安装过程中，会复制环境变量CUDA_PATH中的cufft64_11.dll文件到环境变量中的python路径下，如果不使用管理员权限，可能会导致复制脚本执行失败，虽然也可以正常安装，不会有报错，但是缺少cufft64_11.dll，会导致无法正常运行。如果没有管理员权限，可以手动复制cufft64_11.dll到python安装路径下。\n 问题2：python程序运行过程中报错：ImportError: DLL load failed while importing PyPeridyno: 找不到指定的模块。\n 答：这是cufft64_11.dll文件不兼容或者导入失败导致的，可以看一下自己的CUDA_PATH路径，检查一下CUDA版本是否哦为12.2，可以手动复制CUDA版本为12.2等的cufft64_11.dll到python目录。也有可能是python版本导致的，请使用python3.12\n 问题3：如何重新安装？\n 答：执行pip uninstall PyPeridyno，之后清除pip缓存pip cache purge，再重新安装pip install PyPeridyno。\n "
},
{
	"uri": "https://peridyno.github.io/zh/installation/",
	"title": "安装指引",
	"tags": [],
	"description": "Peridyno安装教程。
",
	"content": "1、安装平台 Windows 平台:\n  源码安装:支持Window 10、 Window 11平台。\n  二进制安装:支持Window 11平台。\n  Linux 平台：支持Ubuntu 18.04及以上平台。\n2、协议 Peridyno 的默认许可是 Apache 2.0（参见 许可）。\n外部库是根据自己的条款协议分发。\n"
},
{
	"uri": "https://peridyno.github.io/zh/installation/linux/",
	"title": "Linux平台安装",
	"tags": [],
	"description": "",
	"content": "1、平台  Linux 平台：推荐ubuntu:20.04.4-LTS-desktop 不推荐虚拟机安装：虚拟机中的显卡不是真实的物理显卡，在CUDA安装及后续的项目编译中会出现问题。  ubuntu:20.04-LTS-desktop版本系统与本项目运行环境契合度较高，项目编译起来问题较少。ubuntu:18.04-LTS-desktop版本OpenGL版本低于4.3，而且升级较为麻烦。ubuntu22.04-LTS-desktop版本系统g++、gcc以及cuda的版本较高。因此笔者选用ubuntu:20.04-LTS-desktop版本系统作为运行环境，其他版本的Linux系统，读者可以自行尝试。\n\r2、依赖  OpenGL version：4.6+  $ glxinfo | grep \u0026#34;OpenGL version\u0026#34; OpenGL version string: 4.6.0 NVIDIA 510.47.03  安装mesa-utils：  $ sudo apt install mesa-utils\r​\t查看驱动版本：\n$ nvidia-smi Fri Aug 12 14:51:28 2022 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 510.47.03 Driver Version: 510.47.03 CUDA Version: 11.6 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 NVIDIA GeForce ... Off | 00000000:01:00.0 Off | N/A | | 30% 31C P8 18W / 220W | 171MiB / 8192MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | 0 N/A N/A 1338 G /usr/lib/xorg/Xorg 36MiB | | 0 N/A N/A 3416 G /usr/lib/xorg/Xorg 35MiB | | 0 N/A N/A 3546 G /usr/bin/gnome-shell 86MiB | +-----------------------------------------------------------------------------+ \r调用nvidia-smi指令时有可能会出现找不到的问题，其原因通常是Ubuntu 20.04没有安装最新显卡驱动。较为简单的方法可以通过Software \u0026amp; Updates \u0026ndash;\u0026gt;Additional Drivers选取合适的显卡驱动重新安装，安装之后重启系统。\n\r CUDA Version: 11+：  $ nvcc --version nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2021 NVIDIA Corporation Built on Fri_Dec_17_18:16:03_PST_2021 Cuda compilation tools, release 11.6, V11.6.55 Build cuda_11.6.r11.6/compiler.30794723_0 CUDA安装参见官网，安装成功后需要配置环境变量，打开.bashrc文件：\n$ sudo gedit ~/.bashrc\r在文件结尾添加：\nexport PATH=/usr/local/cuda-11.6/bin:$PATH\rexport LD_LIBRARY_PATH=/usr/local/cuda-11.6/lib64:$LD_LIBRARY_PATH\r激活配置文件：\nsource ~/.bashrc\r cmake version: 3.10+  安装CMake：\n$ sudo apt install cmake\r查看cmake版本：\n$ cmake --version cmake version 3.16.3 CMake suite maintained and supported by Kitware (kitware.com/cmake). 同时推荐安装cmake-gui。PeriDyno项目编译可选参数较多，使用图形化界面可以便捷的选择需要编译的库。\n值得注意的是，默认安装的cmake版本较低，有可能出现与最新版本CUDA不兼容的情况。如果出现 “The CMAKE_CUDA_COMPILER: /usr/local/ is not a full path to an existing compiler tool ”的错误，请安装高版本cmake。安装方式如下：\n$ sudo apt remove cmake\r$ sudo apt autoremove\r$ sudo snap install cmake --classic\r3、安装项目 （1）更新系统软件环境：\n$ sudo apt-get update （2）安装C++编译器：\n$ sudo apt install g++\r$ sudo apt install gcc\r（3）安装依赖包：\n$ sudo apt-get install libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libxrandr-dev libxinerama-dev libxcursor-dev $ sudo apt install -y mesa-common-dev libgl-dev （4）克隆项目及子模块：\n$ git clone -b linux --recursive https://gitee.com/peridyno/peridyno.git \r注意，此时需要选择PeriDyno代码仓库中的linux分支。\n\r（5）创建build文件夹：\n$ mkdir build $ cd build 4、编译项目  cmake项目，其中参数 -D PERIDYNO_EXMAPLE=ON 表示编译PeriDyno中的exmaple工程：  hehao@hehao:~/peridyno-gitee/build$ cmake -D PERIDYNO_EXMAPLE=ON .. -- Could NOT find Doxygen (missing: DOXYGEN_EXECUTABLE) -- Using X11 for window creation -- Imath is configuring as a cmake sub project -- Configure Imath 3.2.0-dev, library API version: 29.0.0 -- CMAKE SYSTEM NAME: Linux -- The install dir is /usr/local -- Found package Imath * Alembic Configuration === * USE_ARNOLD OFF * USE_BINARIES OFF * USE_EXAMPLES OFF * USE_HDF5 OFF * USE_MAYA OFF * USE_PRMAN OFF * USE_PYALEMBIC OFF * USE_STATIC_BOOST OFF * USE_STATIC_HDF5 OFF * USE_TESTS OFF * ALEMBIC_ILMBASE_LINK_STATIC OFF * ALEMBIC_SHARED_LIBS ON * PYALEMBIC_PYTHON_MAJOR 3 * DOCS_PATH OFF Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/blur.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/helper/axis.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/helper/axis.vert.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/helper/background.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/helper/bbox.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/helper/bbox.vert.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/helper/plane.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/helper/plane.vert.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/instance.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/instance.geom.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/instance.vert.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/line.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/line.geom.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/line.vert.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/point.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/point.vert.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/screen.vert.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/ssao.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/surface.frag.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/surface.geom.glsl Process: /home/hehao/Documents/peridyno/peridyno/src/Rendering/Engine/OpenGL/shader/surface.vert.glsl -- Configuring done -- Generating done\tCMake Warning: Manually-specified variables were not used by the project: PERIDYNO_EXMAPLE -- Build files have been written to: /home/hehao/Documents/peridyno/peridyno/build   如果安装了cmake-gui图形界面：   make项目\n  可以使用 make -j8 指令加快编译速度，其中 -j8 表示使用8个线程同时编译：\n\rhehao@hehao:~/peridyno-gitee/build$ make [ 2%] Built target Imath [ 6%] Built target glfw [ 7%] Built target glad [ 9%] Built target imgui [ 12%] Built target Core [ 38%] Built target Alembic [ 58%] Built target Framework [ 60%] Built target RenderCore [ 60%] Built target ABCExporter [ 62%] Built target ImWidgets [ 65%] Built target IO Scanning dependencies of target GLRenderEngine [ 67%] Built target Volume [ 69%] Built target HeightField [ 70%] Built target RigidBody [ 75%] Built target ParticleSystem [ 75%] Building CXX object src/Rendering/Engine/OpenGL/CMakeFiles/GLRenderEngine.dir/gl/Program.cpp.o [ 79%] Built target Peridynamics [ 79%] Linking CUDA device code CMakeFiles/GLRenderEngine.dir/cmake_device_link.o [ 79%] Linking CXX static library ../../../../lib/Release/libGLRenderEngine.a [ 85%] Built target GLRenderEngine [ 86%] Linking CUDA device code CMakeFiles/GlfwGUI.dir/cmake_device_link.o [ 86%] Linking CXX shared library ../../../../lib/Release/libdynoGlfwGUI-0.6.0.so [ 86%] Built target GlfwGUI [ 86%] Linking CUDA device code CMakeFiles/GL_GlfwGUI.dir/cmake_device_link.o [ 86%] Linking CUDA device code CMakeFiles/GL_Bricks.dir/cmake_device_link.o [ 87%] Linking CUDA device code CMakeFiles/GL_Buoyancy.dir/cmake_device_link.o [ 87%] Linking CUDA device code CMakeFiles/GL_InstanceVisualizer.dir/cmake_device_link.o [ 88%] Linking CUDA device code CMakeFiles/GL_CapillaryWave.dir/cmake_device_link.o [ 88%] Linking CUDA device code CMakeFiles/GL_Cloth.dir/cmake_device_link.o [ 88%] Linking CUDA device code CMakeFiles/GL_Elasticity.dir/cmake_device_link.o [ 88%] Linking CUDA device code CMakeFiles/GL_CollisionMask.dir/cmake_device_link.o [ 88%] Linking CXX executable ../../bin/Release/GL_GlfwGUI [ 89%] Linking CXX executable ../../bin/Release/GL_Buoyancy [ 89%] Linking CXX executable ../../bin/Release/GL_Bricks [ 89%] Linking CXX executable ../../bin/Release/GL_Elasticity [ 89%] Linking CXX executable ../../bin/Release/GL_CapillaryWave [ 89%] Linking CXX executable ../../bin/Release/GL_CollisionMask [ 89%] Linking CXX executable ../../bin/Release/GL_InstanceVisualizer [ 89%] Linking CXX executable ../../bin/Release/GL_Cloth [ 89%] Built target GL_GlfwGUI [ 90%] Linking CUDA device code CMakeFiles/GL_Ocean.dir/cmake_device_link.o [ 91%] Built target GL_CollisionMask [ 91%] Built target GL_Elasticity [ 91%] Built target GL_Cloth [ 91%] Built target GL_Buoyancy [ 92%] Built target GL_Bricks [ 93%] Built target GL_InstanceVisualizer [ 93%] Built target GL_CapillaryWave [ 93%] Linking CUDA device code CMakeFiles/GL_OceanPatch.dir/cmake_device_link.o [ 93%] Linking CUDA device code CMakeFiles/GL_ParticleEmitter.dir/cmake_device_link.o [ 94%] Linking CUDA device code CMakeFiles/GL_ParticleFluid.dir/cmake_device_link.o [ 94%] Linking CUDA device code CMakeFiles/GL_Plasticity.dir/cmake_device_link.o [ 94%] Linking CUDA device code CMakeFiles/GL_Timing.dir/cmake_device_link.o [ 94%] Linking CUDA device code CMakeFiles/GL_TwoTets.dir/cmake_device_link.o [ 94%] Linking CXX executable ../../bin/Release/GL_Ocean [ 94%] Linking CUDA device code CMakeFiles/GL_TwoBoxes.dir/cmake_device_link.o [ 94%] Linking CXX executable ../../bin/Release/GL_ParticleFluid [ 94%] Built target GL_Ocean [ 96%] Linking CXX executable ../../bin/Release/GL_Timing [ 96%] Linking CXX executable ../../bin/Release/GL_OceanPatch [ 96%] Linking CXX executable ../../bin/Release/GL_Plasticity [ 96%] Linking CXX executable ../../bin/Release/GL_ParticleEmitter [ 96%] Linking CXX executable ../../bin/Release/GL_TwoTets [ 97%] Linking CUDA device code CMakeFiles/GL_Wireframe.dir/cmake_device_link.o [ 97%] Linking CXX executable ../../bin/Release/GL_TwoBoxes [ 97%] Linking CXX executable ../../bin/Release/GL_Wireframe [ 98%] Built target GL_ParticleFluid [ 98%] Built target GL_OceanPatch [ 98%] Linking CUDA device code CMakeFiles/GL_GhostSPH.dir/cmake_device_link.o [ 98%] Built target GL_Timing [ 99%] Built target GL_TwoTets [ 99%] Built target GL_ParticleEmitter [ 99%] Built target GL_Plasticity [ 99%] Built target GL_TwoBoxes [100%] Linking CXX executable ../../../bin/Release/GL_GhostSPH [100%] Built target GL_Wireframe [100%] Built target GL_GhostSPH  运行PeriDyno示例：  $ cd bin/Release $ ./GL_GlfwGUI  运行效果如下：   5、安装Vulkan(可选) git clone https://github.com/SaschaWillems/Vulkan.git git submodule sync git submodule update --init --recursive mkdir build cd build cmake .. make 安装了Vulkan，可选择Vulkan模式进行编译： 6、Peridyno插件安装（可选） PeriDyno支持插件导入。在正常情况下，为了提高编译速度，默认插件是不启用的。如需要使用插件，在cmake阶段勾选PERIDYNO_LIBRARY_PLUGIN选项： 重新Configure和Generate后将会出现可选的插件： 7、安装交互式Qt框架(可选)  安装Qt组件：  sudo apt-get install build-essential sudo apt-get install qtcreator sudo apt-get install qt5-default sudo apt-get install libqt5svg5*  cmake项目，其中参数 -D PERIDYNO_Qt5_GUI=ON 表示编译PeriDyno的Qt库：  hehao@hehao:~/peridyno-gitee/build$ cmake -D PERIDYNO_Qt5_GUI=ON .. -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- The CUDA compiler identification is NVIDIA 11.6.55 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Check for working CUDA compiler: /usr/local/cuda-11.6/bin/nvcc -- Check for working CUDA compiler: /usr/local/cuda-11.6/bin/nvcc -- works -- Detecting CUDA compiler ABI info -- Detecting CUDA compiler ABI info - done -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed -- Looking for pthread_create in pthreads -- Looking for pthread_create in pthreads - not found -- Looking for pthread_create in pthread -- Looking for pthread_create in pthread - found -- Found Threads: TRUE -- Found CUDA: /usr/local/cuda-11.6 (found version \u0026#34;11.6\u0026#34;) -- Could NOT find Doxygen (missing: DOXYGEN_EXECUTABLE) -- Using X11 for window creation -- Found X11: /usr/include -- Looking for XOpenDisplay in /usr/lib/x86_64-linux-gnu/libX11.so;/usr/lib/x86_64-linux-gnu/libXext.so -- Looking for XOpenDisplay in /usr/lib/x86_64-linux-gnu/libX11.so;/usr/lib/x86_64-linux-gnu/libXext.so - found -- Looking for gethostbyname -- Looking for gethostbyname - found -- Looking for connect -- Looking for connect - found -- Looking for remove -- Looking for remove - found -- Looking for shmat -- Looking for shmat - found -- Looking for IceConnectionNumber in ICE -- Looking for IceConnectionNumber in ICE - found -- Configuring done -- Generating done -- Build files have been written to: /home/hehao/peridyno-gitee/build  make项目，其中 -j8 表示使用8个线程同时编译，加快编译速度：  $ make -j8 hehao@hehao:~/peridyno-gitee/build$ make -j8 [ 1%] Automatic MOC for target nodes [ 2%] Built target glad [ 6%] Built target glfw [ 9%] Built target Core [ 9%] Built target nodes_autogen [ 11%] Built target imgui [ 21%] Built target nodes [ 44%] Built target Framework [ 46%] Built target RenderCore [ 50%] Built target IO [ 52%] Built target ImWidgets [ 54%] Built target Volume [ 56%] Built target RigidBody [ 63%] Built target GLRenderEngine [ 63%] Automatic MOC and UIC for target QtGUI [ 64%] Built target GlfwGUI [ 66%] Built target Interaction [ 70%] Built target Modeling [ 70%] Built target QtGUI_autogen [ 75%] Built target ParticleSystem [ 75%] Built target GL_GlfwGUI [ 76%] Built target GL_InstanceVisualizer [ 78%] Built target GL_SegmentVisualizer [ 78%] Built target GL_MouseInteractionInGraphicsPipeline [ 78%] Built target GL_MouseInteraction [ 78%] Built target GL_Topology [ 80%] Built target HeightField [ 84%] Built target Peridynamics [ 97%] Built target QtGUI [ 99%] Built target Qt_Bricks [ 99%] Built target Qt_MarchingCubes [ 99%] Built target Qt_ShowChinese [ 99%] Built target Qt_Pickers [ 99%] Built target Qt_GUI_Empty [100%] Built target Qt_MouseInteractionInGraphicsPipeline  运行效果如下：   "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_connection/",
	"title": "节点连接关系",
	"tags": [],
	"description": "",
	"content": "1、节点连接关系 案例位置：examples/Cuda/QtGUI/Qt_Connection\n功能介绍：该案例展示了场景图中节点的连接关系。如下图所示，场景图中Target节点有输入节点和输出节点。为了方便叙述，将节点标号为①②③④。\n 节点①：输入节点，允许多个节点输入。宏定义如下，其中T代表节点类型，name表示名称，desc表示输入节点描述信息，访问方式为import+数据名称+s。  DEF_NODE_PORTS(T, name, desc)  节点②：输入节点，只允许单个节点输入。宏定义如下，其中T代表节点类型，name表示名称，desc表示输入节点描述信息，访问方式为import+数据名称。  DEF_NODE_PORT(T, name, desc)  节点③：输入节点，只允许单个节点指定数据类型输入。宏定义如下，其中T代表节点类型，name表示名称，desc表示输入节点描述信息。访问方式为in+数据名称。  DEF_INSTANCE_IN(T, name, desc);  节点④：输出节点，将当前节点全部的数据输出。无需定义，系统会默认将每个节点增加一个输出接口out。  案例说明：案例中Target节点定义了三个输入接口，其中Source A(s)运行多个节点接入、Source B只允许一个节点接入、Data是只允许指定数据输入。\n2、程序实现 接下来介绍案例的实现过程：\n Data数据定义：  class Data : public Object { public: Data() {}; ~Data() override {}; };  SourceA节点定义：  class SourceA : public Node { DECLARE_CLASS(SourceA); public: SourceA() { }; ~SourceA() override {}; DEF_INSTANCE_OUT(Data, Data, \u0026#34;Output\u0026#34;); protected: void resetStates() {}; }; IMPLEMENT_CLASS(SourceA);  SourceB节点定义：  class SourceB : public Node { DECLARE_CLASS(SourceB); public: SourceB() { }; ~SourceB() override {}; DEF_INSTANCE_OUT(Data, Data, \u0026#34;Output\u0026#34;); protected: void resetStates() {}; }; IMPLEMENT_CLASS(SourceB);  Target节点定义：  class Target : public Node { DECLARE_CLASS(Target); public: Target() { }; ~Target() override {}; DEF_NODE_PORTS(SourceA, SourceA, \u0026#34;\u0026#34;); DEF_NODE_PORT(SourceB, SourceB, \u0026#34;\u0026#34;); DEF_INSTANCE_IN(Data, Data, \u0026#34;Input\u0026#34;); protected: void resetStates() {}; }; IMPLEMENT_CLASS(Target);  节点间的连接关系：  int main() { std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto source1 = scn-\u0026gt;addNode(std::make_shared\u0026lt;SourceA\u0026gt;()); source1-\u0026gt;setName(\u0026#34;s1\u0026#34;); auto source2 = scn-\u0026gt;addNode(std::make_shared\u0026lt;SourceA\u0026gt;()); source2-\u0026gt;setName(\u0026#34;s2\u0026#34;); auto source3 = scn-\u0026gt;addNode(std::make_shared\u0026lt;SourceB\u0026gt;()); source3-\u0026gt;setName(\u0026#34;s3\u0026#34;); auto target1 = scn-\u0026gt;addNode(std::make_shared\u0026lt;Target\u0026gt;()); target1-\u0026gt;setName(\u0026#34;t1\u0026#34;); source1-\u0026gt;connect(target1-\u0026gt;importSourceAs()); source2-\u0026gt;connect(target1-\u0026gt;importSourceAs()); source3-\u0026gt;connect(target1-\u0026gt;importSourceB()); source1-\u0026gt;outData()-\u0026gt;connect(target1-\u0026gt;inData()); QtApp app; app.setSceneGraph(scn); app.initialize(1366, 800); app.mainLoop(); return 0; } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/rigidbody/gl_collisiondetectionin3d/",
	"title": "刚体碰撞",
	"tags": [],
	"description": "",
	"content": "1、刚体碰撞 案例位置：examples/Cuda/Rigidbody/GL_CollisionDetectionIn3D\n功能介绍：该案例主要用于测试刚体系统的碰撞功能。\n案例说明：案例展示了三个场景，分别是正方体与正方体的碰撞、四面体与四面体的碰撞，以及四面体与正方体的碰撞。通过不同形状的刚体间的碰撞，测试刚体碰撞功能是否正确。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图及渲染节点:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto rigid = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); sRender-\u0026gt;setAlpha(0.8f); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); //TODO: to enable using internal modules inside a node \tauto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); rigid-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(elementQuery); //Visualize contact normals \tauto contactMapper = std::make_shared\u0026lt;ContactsToEdgeSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactMapper-\u0026gt;inContacts()); contactMapper-\u0026gt;varScale()-\u0026gt;setValue(0.02); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactMapper); auto wireRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); wireRender-\u0026gt;setColor(Vec3f(0, 0, 1)); contactMapper-\u0026gt;outEdgeSet()-\u0026gt;connect(wireRender-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(wireRender); //Visualize contact points \tauto contactPointMapper = std::make_shared\u0026lt;ContactsToPointSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactPointMapper-\u0026gt;inContacts()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactPointMapper); auto pointRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRender-\u0026gt;setColor(Vec3f(1, 0, 0)); contactPointMapper-\u0026gt;outPointSet()-\u0026gt;connect(pointRender-\u0026gt;inPointSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRender); createTwoBoxes(rigid);//调用两个正方体碰撞 \tcreateTwoTets(rigid);//调用两个四面体碰撞 \tcreateTetBox(rigid);//调用四面体和正方体碰撞   创建两个刚体碰撞场景：  void createTwoBoxes(std::shared_ptr\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt; rigid) { RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.0, 0, 0); BoxInfo box; box.center = Vec3f(-0.3, 0.1, 0.5); box.halfLength = Vec3f(0.1, 0.1, 0.1); rigid-\u0026gt;addBox(box, rigidBody); rigidBody.linearVelocity = Vec3f(0.0, 0, 0); box.center = Vec3f(-0.3, 0.3, 0.59); box.halfLength = Vec3f(0.1, 0.1, 0.1); rigid-\u0026gt;addBox(box, rigidBody); }  创建两个四面体碰撞场景：  void createTwoTets(std::shared_ptr\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt; rigid) { RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.0, 0, 0); TetInfo tet0; tet0.v[0] = Vec3f(0.45f, 0.3f, 0.45f); tet0.v[1] = Vec3f(0.45f, 0.55f, 0.45f); tet0.v[2] = Vec3f(0.7f, 0.3f, 0.45f); tet0.v[3] = Vec3f(0.45f, 0.3f, 0.7f); rigid-\u0026gt;addTet(tet0, rigidBody); TetInfo tet1; tet1.v[0] = Vec3f(0.45f, 0.0f, 0.45f); tet1.v[1] = Vec3f(0.45f, 0.25f, 0.45f); tet1.v[2] = Vec3f(0.7f, 0.0f, 0.45f); tet1.v[3] = Vec3f(0.45f, 0.0f, 0.7f); rigid-\u0026gt;addTet(tet1, rigidBody); }  创建四面体和正方体碰撞场景：  void createTetBox(std::shared_ptr\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt; rigid) { RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.0, 0, 0); BoxInfo box; box.center = Vec3f(1.3, 0.1, 0.5); box.halfLength = Vec3f(0.1, 0.1, 0.1); rigid-\u0026gt;addBox(box, rigidBody); TetInfo tet0; tet0.v[0] = Vec3f(1.25f, 0.25f, 0.45f); tet0.v[1] = Vec3f(1.25f, 0.5f, 0.45f); tet0.v[2] = Vec3f(1.5f, 0.25f, 0.45f); tet0.v[3] = Vec3f(1.25f, 0.25f, 0.7f); rigid-\u0026gt;addTet(tet0, rigidBody); } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/tutorials/gl_instancevisualizer/",
	"title": "实例渲染",
	"tags": [],
	"description": "",
	"content": "1、实例渲染 案例位置：examples/Cuda/Tutorials/GL_InstanceVisualizer\n功能介绍：该案例展示了如何创建了Instances实例。PeriDyno引擎允许用户自定义实例节点，并支持对模型的位置，尺寸大小、颜色及旋转进行定义。\n案例说明：案例中展示了5个Armadillo模型实例的创建，并按照先后顺序进行旋转、缩放以及作色。\n2、创建过程 接下来介绍案例的实现过程：\n 自定义Instance类，该类继承于Node节点  class Instances : public Node  通过this-\u0026gt;stateTransforms()-\u0026gt;allocate()-\u0026gt;assign()函数设置模型的位置，尺寸，旋转等变换，并绑定拓扑结构。  // geometry \tstd::shared_ptr\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt; triSet = std::make_shared\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); triSet-\u0026gt;loadObjFile(getAssetPath() + \u0026#34;armadillo/armadillo.obj\u0026#34;); this-\u0026gt;stateTopology()-\u0026gt;setDataPtr(triSet); // instance transforms and colors \tCArray\u0026lt;Transform3f\u0026gt; instanceTransforms; CArray\u0026lt;Vec3f\u0026gt;\tinstanceColors; for (uint i = 0; i \u0026lt; 5; i++) { Transform3f tm; tm.translation()\t= Vec3f(0.4 * i, 0, 0); tm.scale()\t= Vec3f(1.0 + 0.1*i, 1.0 - 0.1*i, 1.0); tm.rotation()\t= Quat\u0026lt;float\u0026gt;(i * (-0.2), Vec3f(1, 0, 0)).toMatrix3x3(); instanceTransforms.pushBack(tm); instanceColors.pushBack(Vec3f(i * 0.2f, i * 0.2f, 1.f - i * 0.1f)); } this-\u0026gt;stateTransforms()-\u0026gt;allocate()-\u0026gt;assign(instanceTransforms); this-\u0026gt;stateColors()-\u0026gt;allocate()-\u0026gt;assign(instanceColors); instanceTransforms.clear(); DEF_ARRAY_STATE(Transform3f, Transforms, DeviceType::GPU, \u0026#34;Instance transform\u0026#34;); DEF_ARRAY_STATE(Vec3f, Colors, DeviceType::GPU, \u0026#34;Instance color\u0026#34;); DEF_INSTANCE_STATE(TopologyModule, Topology, \u0026#34;Topology\u0026#34;);  创建instance节点，并添加渲染节点：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); // create a instance node \tauto instanceNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;Instances\u0026gt;()); // config instance rendering \tauto instanceRender = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); instanceRender-\u0026gt;setColor(Vec3f(0, 1, 0)); //instanceRender-\u0026gt;setAlpha(0.5f); \t//instanceRender-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true);  instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(instanceRender-\u0026gt;inTriangleSet()); instanceNode-\u0026gt;stateTransforms()-\u0026gt;connect(instanceRender-\u0026gt;inInstanceTransform()); instanceNode-\u0026gt;stateColors()-\u0026gt;connect(instanceRender-\u0026gt;inInstanceColor()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(instanceRender); scn-\u0026gt;setUpperBound({ 4, 4, 4}); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/peridynamics/gl_elasticity/",
	"title": "弹性体仿真",
	"tags": [],
	"description": "",
	"content": "1、弹性体仿真 案例位置：examples/Cuda/Peridynamics/GL_Elasticity\n功能介绍：该案例主要用于测试弹性体仿真功能。案例展示了 ElasticBody 类的基本使用。在计算机图形学领域，基于物理方法的三维弹性体变形仿真有着广泛的应用需求。弹性体能在除去外力后恢复原状。弹性体只在弱应力下形变显著，应力松弛后能迅速恢复到接近原有状态和尺寸。\n案例说明：案例中展示了弹性体兔子模型从空中掉落后，与地面发生碰撞的弹性运动过程。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真边界以及弹性体节点：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); root-\u0026gt;loadCube(Vec3f(0), Vec3f(1), 0.005f, true); auto bunny = scn-\u0026gt;addNode(std::make_shared\u0026lt;ElasticBody\u0026lt;DataType3f\u0026gt;\u0026gt;()); bunny-\u0026gt;connect(root-\u0026gt;importParticleSystems()); bunny-\u0026gt;loadParticles(getAssetPath() + \u0026#34;bunny/bunny_points.obj\u0026#34;); bunny-\u0026gt;scale(1.0f); bunny-\u0026gt;translate(Vec3f(0.5f, 0.1f, 0.5f)); bunny-\u0026gt;setVisible(true);  创建渲染节点：  auto pointRenderer = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRenderer-\u0026gt;setColor(Vec3f(1, 0.2, 1)); pointRenderer-\u0026gt;setColorMapMode(GLPointVisualModule::PER_OBJECT_SHADER); bunny-\u0026gt;statePointSet()-\u0026gt;connect(pointRenderer-\u0026gt;inPointSet()); bunny-\u0026gt;stateVelocity()-\u0026gt;connect(pointRenderer-\u0026gt;inColor()); bunny-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRenderer); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/sph/gl_particleemitter/",
	"title": "粒子发射器",
	"tags": [],
	"description": "",
	"content": "1、粒子发射器 案例位置：examples/Cuda/SPH/GL_ParticleEmitter\n功能介绍：该案例主要用于测试流体发射器的仿真功能。案例展示了 SquareEmitter 类的的基本使用。粒子发射器通过限定粒子活动范围的，并给定随机产生的粒子一个初始位移和速度，来模拟流体发射。\n案例说明：案例中展示了流体粒子从空中发射，与地面的流体发生碰撞的过程。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建粒子发射器以及粒子流体节点：  //Create a particle emitter \tauto emitter = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleEmitterSquare\u0026lt;DataType3f\u0026gt;\u0026gt;()); emitter-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.5f)); //Create a particle-based fluid solver \tauto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(0.0f), Vec3f(0.2f), 0.005f); emitter-\u0026gt;connect(fluid-\u0026gt;importParticleEmitters());  计算法线：  auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm);  创建渲染节点：  auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); ptRender-\u0026gt;setColorMapRange(0, 5); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;currentTopology()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender);  创建矩形边界：  auto container = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); container-\u0026gt;loadCube(Vec3f(0.0f), Vec3f(1.0), 0.02, true); fluid-\u0026gt;connect(container-\u0026gt;importParticleSystems()); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_clothontable/",
	"title": "桌、布碰撞模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_ClothOnTable\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。布料在重力作用下，从空中掉落到桌上，并形成褶皱的过程。\n2、程序实现  创建场景图、边界以及静态桌子模型：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, 0, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); auto object = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticTriangularMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); object-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;cloth_shell/table/table.obj\u0026#34;);  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.3,8000,0.003,7e-4)); //also try: \t//auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.3, 8000, 0.03,7e-4)); \t//auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.3, 8000, 0.3,7e-4)); \t//auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.3, 8000, 0.0,7e-4)); \tcloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/mesh40k_1_h90.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems());  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(0.4, 0.4, 1.0)); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRenderer-\u0026gt;setColor(Color(0.8, 0.8, 0.8)); surfaceRenderer-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); object-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); object-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); cloth-\u0026gt;setVisible(true); object-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/heightfield/gl_ocean/",
	"title": "海洋仿真",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/HeigthField/GL_Ocean\n功能介绍：该案例展示了 Ocean 类、CapillaryWave 类和 OceanPatch 类的基本使用。PeriDyno引擎支持模拟海浪以及水面涟漪的模拟。用户可以设置不同等级的海浪大小，支持0-12级海浪。案例将海浪与水面涟漪的效果进行了耦合。\n案例说明：该案例主要用于模拟测试海洋仿真功能。OceanPatch类用于模拟不同等级的海浪；CapillaryWave类用于模拟水面涟漪；Ocean类将两者的仿真结果耦合在一起。如下图所示，海洋中不仅有海浪的运动，同时水面中间有涟漪效果。\n2、程序实现  创建场景图：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建海洋节点，其中通过多个OceanPatch组合成一个大的Ocean。CapillaryWave是用于模拟水上的波纹。  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto oceanPatch = scn-\u0026gt;addNode(std::make_shared\u0026lt;OceanPatch\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;Ocean\u0026lt;DataType3f\u0026gt;\u0026gt;()); root-\u0026gt;varExtentX()-\u0026gt;setValue(2); root-\u0026gt;varExtentZ()-\u0026gt;setValue(2); oceanPatch-\u0026gt;connect(root-\u0026gt;importOceanPatch()); auto capillaryWave = scn-\u0026gt;addNode(std::make_shared\u0026lt;CapillaryWave\u0026lt;DataType3f\u0026gt;\u0026gt;(512, 512.0f)); capillaryWave-\u0026gt;connect(root-\u0026gt;importCapillaryWaves());  创建渲染节点：  auto mapper = std::make_shared\u0026lt;HeightFieldToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); root-\u0026gt;stateHeightField()-\u0026gt;connect(mapper-\u0026gt;inHeightField()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(0, 0.2, 1.0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/heightfield/",
	"title": "基于高度场的海洋模拟",
	"tags": [],
	"description": "",
	"content": "大规模海洋场景的仿真受到各领域工作者的关注。在民用方面，对海洋场景的实时绘制已经成为计算机游戏、动画制作、电影制作和工程应用方面强有力的辅助工具；在军用方面，海洋仿真技术为各国海军战斗人员提供经济，安全，可靠的训练环境；在科研方面，海洋仿真可以把抽象的，专业的图表和数据转化成直观的动画，为船舶设计人员提供帮助。\n海面模拟一直是计算机图形领域研究热门的问题，也是一个挑战，主要研究点是对大面积开阔水域的模拟。然后在这种情况下使用传统模拟3D流体的方法意味着需要构建极其巨大的网格，海量的运算使得这种方法在普通的计算机上是几乎不可能模拟出来的。\nJerry Tessendorf[1]等人提出基于高度场y=h(x,z)的方法模拟水面，为普通计算机模拟海面提供了可能，甚至在大规模GPU计算下也能达到实时模拟的效果。接下来介绍基于高度场的海洋模拟相关案例：\n  水面涟漪仿真: 介绍水面涟漪的模拟；\n  海洋仿真: 介绍不同等级的海浪和水面涟漪的耦合仿真；\n  海浪模拟：介绍不同等级的海浪仿真；\n  浮力模拟: 介绍在Qt框架下，使用不同等级的海浪，模拟刚体浮在海浪表面的物理过程；\n  基于Qt的海洋模拟：介绍在Qt框架下，海浪的仿真以及如何调整相关属性。\n  [1] Tessendorf J . Simulating Ocean Water[J]. simulating nature realistic \u0026amp; interactive techniques siggraph, 2001.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/rigidbodydynamics/narrowphase/",
	"title": "窄阶段碰撞检测",
	"tags": [],
	"description": "",
	"content": "1、功能简介 Peridyno提供了多种几何基本单元之间的碰撞检测算法函数。用户可以通过位置信息对几何基本单元进行初始化，进而调用相关函数进行位置关系的判断。\n2、几何基本单元介绍 Peridyno提供了13种几何基本单元的构造以及相关的碰撞检测算法，具体实现可以参考src/Framework/Topology/Primitive3D.inl。\nTPoint3D TPoint3D定义了三维空间中的一个点。既通过点坐标进行初始化，\nCoord3D position = Coord(0,1,0); Point3D point0(position); //使用坐标三元数进行初始化 Point3D point1(0,1,0);//使用三个坐标进行初始化 也可以用另一个TPoint3D进行初始化\nPoint3D point0(0,1,0); Point3D point1(point_0);\tTAlignedBox3D TAlignedBox3D定义了轴对齐包围盒，是几何单元计算轴对齐包围盒的方法aabb()的返回对象。它可以通过两个三维点坐标v0、v1（v0的三个坐标值均需要小于v1对应坐标值）进行初始化\nCoord v0(0,0,0); Coord v1(1,1,1); AABB aabb(v0, v1);\t//v0的三个坐标值均需要小于v1对应坐标值 也可以通过另一个TAlignedBox3D进行初始化\nAABB aabb1; ... AABB aabb2(aabb1);\tTAlignedBox3D中提供的方法如下：\n  intersect intersect计算了该AABB与另一个aabb之间是否相交以。返回值为布尔类型，代表两个AABB是否相交。如果发生相交，那么将交叠的AABB以传引用的方式返回。\n例如\n  AABB aabb1, aabb2; ... AABB interBox; if(aabb1.intersect(aabb2, interBox)) //如果aabb1和aabb2发生交叉，返回1并且将交叉的AABB存入interBox { ... }\t  isValid\nisValid返回值为布尔类型，判断v0的三个坐标值均需要小于v1对应坐标值，\n  return v1[0] \u0026gt; v0[0] \u0026amp;\u0026amp; v1[1] \u0026gt; v0[1] \u0026amp;\u0026amp; v1[2] \u0026gt; v0[2];\t使用方法如\nAABB aabb; ... if(aabb.isValid()) //判断aabb的v0的三个坐标值是否不大于v1的对应坐标值 { ... }\t length length(unsigned int i)计算了aabb在i轴边长v1[i] - v0[i]，例如  AABB aabb; ... Real l_x = aabb.length(0);//x轴的边长 Real l_y = aabb.length(1);//y轴的边长 Real l_z = aabb.length(2);//z轴的边长 TSphere3D TSphere3D定义了三维空间中的一个球体。既通过球心坐标和球半径进行初始化，\nCoord3D center = Coord(0,1,0); Real radius = 0.5f; Sphere3D sphere(center, radius); 也可以用另一个TSphere3D进行初始化\nSphere3D sphere0(center, radius); Sphere3D sphere1(sphere0);\tTSphere3D中提供的方法如下：\n  aabb\naabb计算了该球体的轴对齐包围盒，主要应用于宽阶段碰撞检测，例如\n  AABB box; switch (eleType) { case ET_SPHERE: { box = spheres[tId].aabb(); //计算该球体的轴对齐包围盒 \tbreak; } ... }   volume\nvolume计算了球体的体积，可以用于初始化例子质量等，例如\n  mass = sphere.volume() * density; //计算该球体的体积 TTet3D TTet3D定义了三维空间中的四面体，初始化方法包括使用四个顶点坐标进行初始化\nCoord3D p1,p2,p3,p4; ... Tet3D tet(p1,p2,p3,p4); 以及使用另一个TTet3D进行初始化\nTet3D tet0; ... Tet3D tet1(tet0); TTet3D中提供的方法如下：\n  aabb\naabb计算了该四面体的轴对齐包围盒，主要应用于宽阶段碰撞检测，例如\n  AABB box; TTet3D tet; ... box = tet.aabb(); //计算该球体的轴对齐包围盒  volume volume计算该四面体的体积，返回值为一个Real类型的实数。  TTet3D tet; ... Real volume_tet = tet.volume(); //计算该球体的轴对齐包围盒   circumcenter\ncircumcenter计算该四面体的外接圆圆心，返回值为一个TPoint3D类型的变量。\n计算方法可参考http://rodolphe-vaillant.fr/entry/127/find-a-tetrahedron-circumcenter。\n  TTet3D tet; ... TPoint3D circumcenter_tet = tet.circumcenter();   barycenter\nbarycenter计算该四面体的重心，返回值为一个TPoint3D类型的变量。\n  TTet3D tet; ... TPoint3D barycenter_tet = tet.barycenter(); TOrientedBox3D TOrientedBox3D定义了三维空间中的长方体，有三种初始化方法。\n第一种初始化方法使用长方体的中心、三个轴的方向以及三个轴方向边长的一半初始化。\nCoord3D center;//长方体中心坐标 Coord3D dir0, dir1, dir2;//均为三维向量，应两两相互垂直，分别代表长方体边的三个方向 Coord3D ext;//三维向量，第1、2、3维的数值均应非负，分别代表dir0、dir1、dir2方向边长的一半 ... Box3D obb(center, dir0, dir1, dir2, ext); 第二种初始化方法使用长方体的中心、用四元数表达的旋转角度以及三个轴方向边长的一半初始化。\nCoord3D center;//长方体中心坐标 Quat rot;//四元数代表的三个轴方向的旋转角 Coord3D ext;//三维向量，第1、2、3维的数值均应非负，分别代表dir0、dir1、dir2方向边长的一半 ... Box3D obb(center, rot, ext); 这里，长方体的三条边以(1,0,0),(0,1,0),(0,0,1)为初始方向，使用四元数进行旋转后即为长方体边的方向，具体可参考实现\nauto mat = rot.toMatrix3x3(); u = mat.col(0); v = mat.col(1); w = mat.col(2); 第三种初始化方法为使用另一个TOrientedBox3D进行初始化\nBox3D Box0; ... Box3D Box1(Box0); TOrientedBox3D中提供的方法如下：\n  aabb\naabb计算了该长方体的轴对齐包围盒，主要应用于宽阶段碰撞检测，例如\n  AABB box; Box3D obb; ... box = obb.aabb(); //计算该球体的轴对齐包围盒  volume volume计算该长方体的体积，返回值为一个Real类型的实数。  AABB box; Box3D obb; ... box = obb.volume(); //计算该球体的轴对齐包围盒 3、碰撞检测算法介绍 Peridyno可以检测几何基本单元之间的接触点、接触点法向和穿透距离，具体实现可以参考src/Framework/Collision/CollisionDetectionAlgorithm.inl。\n进行一次碰撞检测包含如下步骤：\n 定义一个TManifold用来存储碰撞信息  TManifold\u0026lt;Real\u0026gt; manifold; 其中TManifold在src/Framework/Collision/CollisionData.h中的定义如下，\ntemplate\u0026lt;typename Real\u0026gt; struct TManifold { public: Vector\u0026lt;Real, 3\u0026gt; normal;\t//接触点法向\t\tTContact\u0026lt;Real\u0026gt; contacts[8];\t//接触点位置以及穿透距离 \tint contactCount = 0; //两个几何基本单元的接触点数量 }; 其中contacts的定义如下，存储接触点的坐标以及穿透距离\ntemplate\u0026lt;typename Real\u0026gt; class TContact { public: Vector\u0026lt;Real, 3\u0026gt; position;\t// 接触点坐标 \tReal penetration;\t// 穿透距离 \t};   调用CollisionDetection::request进行碰撞检测\n定义好TManifold后，可以调用CollisionDetection::request系列函数进行碰撞检测。CollisionDetection::request为定义在src/Framework/Collision/CollisionDetectionAlgorithm.h中的一系列函数，其功能为计算并返回两个几何单元几何单元1和几何单元2之间的碰撞信息，存储在manifold中。它可以在CPU和GPU上调用，调用方法为\n  CollisionDetection\u0026lt;Real\u0026gt;::request(manifold, 几何单元1, 几何单元2); 例如，如果希望进行长方体（OBB）和四面体的碰撞检测，可以进行如下操作\nTet3D tetA; //创建一个四面体 tetA.v[0] = tetPos0; //初始化四面体顶点位置 tetA.v[1] = tetPos1; tetA.v[2] = tetPos2; tetA.v[3] = tetPos3; Box3D boxB;//创建一个长方体 boxB.center = center; //长方体中心点位置 boxB.extent = halfLength;//长方体三个方向的边长  Mat3f rot = rotation.toMatrix3x3(); //用长方体的旋转角初始化长方体的边方向 boxB.u = rot * Vec3f(1, 0, 0); boxB.v = rot * Vec3f(0, 1, 0); boxB.w = rot * Vec3f(0, 0, 1); TManifold\u0026lt;Real\u0026gt; manifold; //定义manifold用于存储穿透信息 CollisionDetection\u0026lt;Real\u0026gt;::request(manifold, tetA, boxB); //调用request，将穿透信息存储在manifold中 目前CollisionDetection::request支持的几何单元类型如下\nDYN_FUNC static void request(Manifold\u0026amp; m, const OBox3D box0, const OBox3D box1); //长方体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Sphere3D\u0026amp; sphere, const OBox3D\u0026amp; box); //长方体和球体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const OBox3D\u0026amp; box, const Sphere3D\u0026amp; sphere);//长方体和球体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Sphere3D\u0026amp; sphere0, const Sphere3D\u0026amp; sphere1);//球体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Tet3D\u0026amp; tet0, const Tet3D\u0026amp; tet1);//四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Tet3D\u0026amp; tet, const OBox3D\u0026amp; box);//长方体和四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const OBox3D\u0026amp; box, const Tet3D\u0026amp; tet);//长方体和四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Sphere3D\u0026amp; sphere, const Tet3D\u0026amp; tet);//球体和四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Tet3D\u0026amp; tet, const Sphere3D\u0026amp; sphere);//球体和四面体之间的碰撞检测 对于长方体与四面体之间的碰撞检测，peridyno中采用分离轴定理（http://www.randygaul.net/2014/05/22/deriving-obb-to-obb-intersection-sat/）进行碰撞检测。\n 查询TManifold中的碰撞信息  在调用后，几何单元之间的碰撞信息被存储在TManifold中，可以通过访问TManifold中的信息获得碰撞接触点数量、接触点位置、接触点法向量和穿透距离。其中，接触点法向量由几何单元1指向几何单元2；穿透距离为一个负数，其绝对值代表两个该接触点沿接触点法向量的穿透的深度；如果两个集合体没有发生碰撞，那么接触点数量为0。\n例如，可以遍历TManifold中的contacts获得每个接触点的穿透深度。\nfor (int n = 0; n \u0026lt; manifold.contactCount; n++)//遍历每个穿透点 { ... cp.pos1 = manifold.contacts[n].position; //获取穿透点位置 \tcp.normal1 = -manifold.normal;//获取穿透法向量，对于相同的一对几何单元，每个接触点的穿透的法向量都相同 \tcp.interpenetration = -manifold.contacts[n].penetration;//获取穿透深度 \t... } "
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/rendering/",
	"title": "渲染管线",
	"tags": [],
	"description": "",
	"content": "1、渲染管线运行时序图 2、支持模块类型 渲染管线兼容所有仿真管线支持的模块，渲染管线特有的功能模块包括：\n 可视化模块VisualModule，虚函数接口为：  virtual void updateGraphicsContext(); 子类主要包括ImWidget、GLVisualModule、VtkVisualModule等，详情参加渲染章节内容。\n"
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/nodes/",
	"title": "节点",
	"tags": [],
	"description": "",
	"content": "1、功能简介 节点为功能相对独立的、封装了特定模块的算法集合，主要包含以下几个部分：\n 控制变量：采用宏定义DEF_VAR形式定义的数据； 输入节点：利用宏定义DEF_NODE_PORT或者DEF_NODE_PORTS形式定义； 输出节点：当前实现只支持节点自身作为默认输出，不需显式定义； 输入数据：采用宏定义DEF_*_IN形式定义的数据； 输出数据：采用宏定义DEF_*_OUT形式义的数据； 状态变量：采用宏定义DEF_*_STATE形式定义的数据； 模块管线：主要包含仿真管线和渲染管线，分别采用animationPipeline()和graphicsPipeline()函数进行调用。  2、如何实现一个自定义节点 创建一个完整的节点包含如下步骤：\n  定义输入节点（可选）：\nDEF_NODE_PORT(T, name, desc) 该宏定义定义单一节点输入，其中T表示节点类型，name表示名称，desc表示输入节点描述信息，访问方式为import+数据名称。\nDEF_NODE_PORTS(T, name, desc)\r该宏定义可定义输入节点数组，其可接入0到任意数量类型为T的节点作为输入，访问方式为import+数据名称+s。\n  定义输入数据（可选）：\nDEF_VAR_IN(T, name, desc)\r定义输入类型为T、名称为name的单一数据类型作为输入。\nDEF_ARRAY_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维数组作为输入。\nDEF_ARRAY2D_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的二维数组作为输入。\nDEF_ARRAY3D_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的三维数组作为输入。\nDEF_INSTANCE_IN(T, name, desc)\r定义输入类型为T、名称为name的实例作为输入。\nDEF_ARRAYLIST_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维动态列表数组作为输入。\n  定义输出数据（可选）：\nDEF_VAR_OUT(T, name, desc)\r定义输入类型为T、名称为name的单一数据类型作为输出。\nDEF_ARRAY_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维数组作为输出。\nDEF_ARRAY2D_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的二维数组作为输出。\nDEF_ARRAY3D_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的三维数组作为输出。\nDEF_INSTANCE_OUT(T, name, desc)\r定义输入类型为T、名称为name的实例作为输出。\nDEF_ARRAYLIST_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维动态列表数组作为输出。\n  定义状态变量：\nDEF_VAR(T, name, value, desc)\r定义类型为T、名称为name、初值类型为value的单一数据类型作为状态变量。\nDEF_ARRAY_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维数组作为状态变量。\nDEF_ARRAY2D_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的二维数组作为状态变量。\nDEF_ARRAY3D_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的三维数组作为状态变量。\nDEF_INSTANCE_STATE(T, name, desc)\r定义输入类型为T、名称为name的实例作为状态变量。\nDEF_ARRAYLIST_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维动态列表数组作为状态变量。\n  创建功能模块：\n以RigidBodySystem为例，其构造函数中创建的功能模块如下：\n//创建自碰撞检测模块 auto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;currentTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); this-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(elementQuery); //创建边界包围盒碰撞检测功能模块 auto cdBV = std::make_shared\u0026lt;CollistionDetectionBoundingBox\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;currentTopology()-\u0026gt;connect(cdBV-\u0026gt;inDiscreteElements()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(cdBV); //创建合并触点功能模块 auto merge = std::make_shared\u0026lt;ContactsUnion\u0026lt;TDataType\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(merge-\u0026gt;inContactsA()); cdBV-\u0026gt;outContacts()-\u0026gt;connect(merge-\u0026gt;inContactsB()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(merge); //创建刚体动力学求解模块 auto iterSolver = std::make_shared\u0026lt;IterativeConstraintSolver\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;varTimeStep()-\u0026gt;connect(iterSolver-\u0026gt;inTimeStep()); this-\u0026gt;varFrictionEnabled()-\u0026gt;connect(iterSolver-\u0026gt;varFrictionEnabled()); this-\u0026gt;stateMass()-\u0026gt;connect(iterSolver-\u0026gt;inMass()); this-\u0026gt;stateCenter()-\u0026gt;connect(iterSolver-\u0026gt;inCenter()); this-\u0026gt;stateVelocity()-\u0026gt;connect(iterSolver-\u0026gt;inVelocity()); this-\u0026gt;stateAngularVelocity()-\u0026gt;connect(iterSolver-\u0026gt;inAngularVelocity()); this-\u0026gt;stateRotationMatrix()-\u0026gt;connect(iterSolver-\u0026gt;inRotationMatrix()); this-\u0026gt;stateInertia()-\u0026gt;connect(iterSolver-\u0026gt;inInertia()); this-\u0026gt;stateQuaternion()-\u0026gt;connect(iterSolver-\u0026gt;inQuaternion()); this-\u0026gt;stateInitialInertia()-\u0026gt;connect(iterSolver-\u0026gt;inInitialInertia()); merge-\u0026gt;outContacts()-\u0026gt;connect(iterSolver-\u0026gt;inContacts()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(iterSolver);   节点构造函数仅包含默认管线，管线功能模块可在外部进行动态添加和删除。详情参加GL_ParticleFluid样例阐述如何为节点渲染管线添加自动渲染模块。\n\r  重载虚函数：\nvirtual void preUpdateStates(); 状态更新前处理函数。\nvirtual void updateStates(); 状态更新函数，若子类不重载该函数，默认调用pipeline执行内置算法流程。\nvirtual void postUpdateStates(); 状态更新后处理函数。\n  3、QT GUI视图 一个节点对应的GUI视图由两部分组成，即Node Editor视图和Property Editor视图。\nNode Editor主要展示节点对应的输入和输出，支持利用鼠标进行数据之间的连接和断开连接操作，典型视图如下：\nProperty Editor窗口则显示每个节点的状态变量以及控制参数信息。例如，当鼠标单击StaticBoundary节点时，Property Editor窗口显示的属性信息如下图所示： （1）控制变量 控制变量用于展示通过Fvar定义的变量，Property Editor窗口可以实现对控制变量进行快速更改。\n  bool：\n  例如当FVar中Visible勾选时，仿真过程中，将会把该节点渲染出来；如果取消勾选，则仿真过程中，不会渲染该节点。\n  float或者double：\n  Vec3f或者Vec3d：\n  FilePath：\n  其中FilePath对应系统路径，用于支持本地文件读取功能。\n（2）状态变量 FState属性允许将Node Editor窗口中，节点FState类型的属性信息显示和隐藏。例如，ParticleFluid节点把Velocity属性勾选时，Node Editor窗口中对应输出会增加Velocity属性，从而使Velocity可以作为其他节点输入。 "
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/",
	"title": "管线",
	"tags": [],
	"description": "",
	"content": "1、什么是管线 PeriDyno中的管线代表模块的集合，通过模块间的数据连接实现模块的依次调用，最终实现节点的状态变量更新或者为渲染及后处理提供输出数据。\n相比于其他管线（如OpenGL管线），PeriDyno管线具备如下特点：\n 管线入口：统一以节点的状态变量作为管线入口，支持直接对模块状态变量的更新； 模块类型：管线支持的功能模块既可以是仿真计算模块，也可以是渲染模块或者交互模块。不同功能模块可以自由排列组合，从而支持复杂实时可交互场景的建模与仿真； 管线类型：当前实现支持仿真管线和渲染管线两种； 更新机制：利用Field的tick()、tack()机制实现数据时间戳同步，保证每个模块只在输入数据或者控制变量更新之后才执行，从而降低冗余计算，具体参见数据同步。  以刚体动力学为例，其仿真管线的可视化效果图如下：\n2、管线功能 管线继承自模块（Module），除了继承Module的功能之外（如数据管理），还具备如下管线特有功能：\n  添加模块：\nvoid pushModule(std::shared_ptr\u0026lt;Module\u0026gt; m);   删除模块：\nvoid popModule(std::shared_ptr\u0026lt;Module\u0026gt; m);   更新模块序列：\nvoid updateExecutionQueue(); 该部分算法通过调用有向无环图的拓扑排序（Topological Sorting）实现。\n  启用/禁用管线：\nvoid enable(); void disable();   导出模块输出到节点输出：\nvoid promoteOutputToNode(FBase* base);   撤销模块输出：\nvoid demoteOutputFromNode(FBase* base); \r更多管线实现细节，参加 src/Framework/Module/Pipeline.h(cpp)实现。\n\r  "
},
{
	"uri": "https://peridyno.github.io/zh/framework/",
	"title": "引擎架构",
	"tags": [],
	"description": "PeriDyno 框架细节介绍。
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_fields/",
	"title": "创建节点和Field数据",
	"tags": [],
	"description": "",
	"content": "1、Fields数据 案例位置：examples/Cuda/QtGUI/Qt_Fields\n功能介绍：该案例主要向用户展示如何创建一个节点和Field数据。Field是对基本数据类型的封装，从而实现节点以及模块之间的数据传递。\n案例说明：案例中定义了一个Fields节点。节点中定义了以下数据：\n 标量数据：bool、int、float； 矢量数据：Vec3f； 枚举类型数据：ENum； 静态数组数据：FloatArray； 状态变量：Value。  其中，标量数据、矢量数据和枚举型数据可在Qt界面展示出来： 2、程序实现 接下来介绍案例的实现过程：\n Fields节点定义以及数据定义：  class Fields : public Node { DECLARE_CLASS(Fields); public: Fields() { this-\u0026gt;varFloat()-\u0026gt;setRange(0.01, 10.0f); this-\u0026gt;inFloatArray()-\u0026gt;tagOptional(true); }; ~Fields() {}; DECLARE_ENUM(ENum, Key0 = 0, Key1 = 1); public: DEF_VAR(bool, Boolean, false, \u0026#34;Define a boolean field\u0026#34;); DEF_VAR(int, Int, 1, \u0026#34;Define an int\u0026#34;); DEF_VAR(float, Float, 1.0f, \u0026#34;Define a float field\u0026#34;); DEF_VAR(Vec3f, Vector, Vec3f(1.0f), \u0026#34;Define a vector field\u0026#34;); DEF_ENUM(ENum, Enum, ENum::Key0, \u0026#34;Define an enum\u0026#34;); DEF_ARRAY_IN(float, FloatArray, DeviceType::GPU, \u0026#34;Define a float array as input\u0026#34;); DEF_ARRAY_OUT(float, FloatArray, DeviceType::GPU, \u0026#34;Define a float array as output\u0026#34;); DEF_ARRAY_STATE(float, Value, DeviceType::GPU, \u0026#34;Define a float array as state\u0026#34;); protected: void resetStates() { std::cout \u0026lt;\u0026lt; \u0026#34;resetStates() \u0026#34; \u0026lt;\u0026lt; \u0026#34; is called \u0026#34; \u0026lt;\u0026lt; std::endl; } }; IMPLEMENT_CLASS(Fields);  创建场景图以及窗口：  int main() { std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto source1 = scn-\u0026gt;addNode(std::make_shared\u0026lt;Fields\u0026gt;()); QtApp app; app.setSceneGraph(scn); app.initialize(1366, 800); app.mainLoop(); return 0; } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/sph/gl_particlefluid/",
	"title": "基于粒子的流体模拟",
	"tags": [],
	"description": "",
	"content": "1、基于粒子的流体模拟 案例位置：examples/Cuda/SPH/GL_ParticleFluid\n功能介绍：该案例主要用于测试基于粒子的流体仿真功能。案例展示了 ParticleFluid 类的的基本使用。SPH方法将连续的流体用相互作用的粒子来描述，各个粒子上承载各种物理量，包括质量、速度和压强等。通过求解粒子的动力学方程，并跟踪每个粒子的运动轨迹，求得整个系统的力学行为。理论上，只要粒子的数量足够多的，就能精确地描述力学过程。\n案例说明：案例中展示了流体粒子落入碗中后飞溅出来的效果。在仿真过程中给每个粒子速度赋予了颜色属性。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真边界以及粒子流体节点，这里的边界是一个静态的碗模型：  auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); ; boundary-\u0026gt;loadCube(Vec3f(-0.5, 0, -0.5), Vec3f(1.5, 2, 1.5), 0.02, true); boundary-\u0026gt;loadSDF(\u0026#34;../../data/bowl/bowl.sdf\u0026#34;, false); auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(0.5, 0.2, 0.4), Vec3f(0.7, 1.5, 0.6), 0.005); fluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems());  计算法线：  auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm);  创建渲染节点：  auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); ptRender-\u0026gt;setColorMapRange(0, 5); fluid-\u0026gt;currentTopology()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender);  创建一个colorBar，在显示的时候，会将不同速度的粒子渲染成不同的颜色：  // A simple color bar widget for node \tauto colorBar = std::make_shared\u0026lt;ImColorbar\u0026gt;(); colorBar-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorBar-\u0026gt;inScalar()); // add the widget to app \tfluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorBar); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/rigidbody/gl_collisionmask/",
	"title": "碰撞掩码功能",
	"tags": [],
	"description": "",
	"content": "1、刚体动力学 案例位置：examples/Cuda/Rigidbody/GL_CollisionMask\n功能介绍：该案例展示了 RigidBodyInfo 类 CollisionMask 属性的的基本使用。案例展示了三维几何模型碰撞掩码功能。该功能能屏蔽指定形状的几何体间的碰撞，支持几何基本单元之间的接触点、接触点法向和穿透距离等计算。\n案例说明：案例中最大的球体和正方体设置了掩码功能，所以在掉落的时候不会发生碰撞。其它球体与球体，正方体与正方体能正常发生碰撞。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建刚体模型，包括正方体、四面体和球体，并指定掩码：  // Boxes are set to being able to collided with other boxes only \trigidBody.collisionMask = CT_BoxOnly; BoxInfo box; for (int i = 8; i \u0026gt; 1; i--) for (int j = 0; j \u0026lt; i + 1; j++) { box.center = 0.5f * Vec3f(0.5f, 1.1 - 0.13 * i, 0.12f + 0.21 * j + 0.1 * (8 - i)); box.halfLength = 0.5f * Vec3f(0.065, 0.065, 0.1); rigid-\u0026gt;addBox(box, rigidBody); } SphereInfo sphere; sphere.center = Vec3f(0.5f, 0.75f, 0.5f); sphere.radius = 0.025f; RigidBodyInfo rigidSphere; // Spheres are set to being able to collided with other spheres only \trigidSphere.collisionMask = CT_SphereOnly; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.95f, 0.5f); sphere.radius = 0.025f; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.65f, 0.5f); sphere.radius = 0.05f; rigid-\u0026gt;addSphere(sphere, rigidSphere); TetInfo tet; tet.v[0] = Vec3f(0.5f, 1.1f, 0.5f); tet.v[1] = Vec3f(0.5f, 1.2f, 0.5f); tet.v[2] = Vec3f(0.6f, 1.1f, 0.5f); tet.v[3] = Vec3f(0.5f, 1.1f, 0.6f); rigid-\u0026gt;addTet(tet, rigidSphere);  创建渲染节点：  auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/peridynamics/gl_plasticity/",
	"title": "塑性材料",
	"tags": [],
	"description": "",
	"content": "1、塑性材料 案例位置：examples/Cuda/Peridynamics/GL_Cloth\n功能介绍：该案例主要用于测试塑性材料仿真功能。案例展示了 ElastoplasticBody 类的的基本使用。塑性材料在发生小应变时，材料性质基本为线弹性，弹性模量为常数；当应力超过屈服应力后，刚度会显著下降。\n案例说明：案例中展示了塑性材料从空中掉落，发生塑性变形的运动过程。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建一个塑性节点：  //Create a elastoplastic object \tauto elastoplasticBody = scn-\u0026gt;addNode(std::make_shared\u0026lt;ElastoplasticBody\u0026lt;DataType3f\u0026gt;\u0026gt;());\telastoplasticBody-\u0026gt;setVisible(false); elastoplasticBody-\u0026gt;loadParticles(Vec3f(-1.1), Vec3f(1.15), 0.1); elastoplasticBody-\u0026gt;scale(0.05); elastoplasticBody-\u0026gt;translate(Vec3f(0.3, 0.2, 0.5));  对塑性节点创建表面网格及渲染节点：  //Create a surface mesh loader \tauto surfaceMeshLoader = scn-\u0026gt;addNode(std::make_shared\u0026lt;SurfaceMeshLoader\u0026lt;DataType3f\u0026gt;\u0026gt;()); surfaceMeshLoader-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;standard/standard_cube20.obj\u0026#34;); surfaceMeshLoader-\u0026gt;varScale()-\u0026gt;setValue(Vec3f(0.05f)); surfaceMeshLoader-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.3, 0.2, 0.5)); //Create a topology mapper \tauto topoMapper = scn-\u0026gt;addNode(std::make_shared\u0026lt;PointSetToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto outTop = elastoplasticBody-\u0026gt;statePointSet()-\u0026gt;promoteOuput(); outTop-\u0026gt;connect(topoMapper-\u0026gt;inPointSet()); surfaceMeshLoader-\u0026gt;outTriangleSet()-\u0026gt;connect(topoMapper-\u0026gt;inInitialShape()); auto surfaceVisualizer = scn-\u0026gt;addNode(std::make_shared\u0026lt;GLSurfaceVisualNode\u0026lt;DataType3f\u0026gt;\u0026gt;()); topoMapper-\u0026gt;outShape()-\u0026gt;connect(surfaceVisualizer-\u0026gt;inTriangleSet());  创建另一个塑性节点：  //Create a elastoplastic object \tauto elasticBody = scn-\u0026gt;addNode(std::make_shared\u0026lt;ElasticBody\u0026lt;DataType3f\u0026gt;\u0026gt;()); elasticBody-\u0026gt;setVisible(false); elasticBody-\u0026gt;loadParticles(Vec3f(-1.1), Vec3f(1.15), 0.1); elasticBody-\u0026gt;scale(0.05); elasticBody-\u0026gt;translate(Vec3f(0.5, 0.2, 0.5)); auto surfaceMeshLoader2 = scn-\u0026gt;addNode(std::make_shared\u0026lt;SurfaceMeshLoader\u0026lt;DataType3f\u0026gt;\u0026gt;()); surfaceMeshLoader2-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;standard/standard_cube20.obj\u0026#34;); surfaceMeshLoader2-\u0026gt;varScale()-\u0026gt;setValue(Vec3f(0.05f)); surfaceMeshLoader2-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.5, 0.2, 0.5));  对塑性节点创建表面网格及渲染节点：  auto topoMapper2 = scn-\u0026gt;addNode(std::make_shared\u0026lt;PointSetToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto outTop2 = elasticBody-\u0026gt;statePointSet()-\u0026gt;promoteOuput(); outTop2-\u0026gt;connect(topoMapper2-\u0026gt;inPointSet()); surfaceMeshLoader2-\u0026gt;outTriangleSet()-\u0026gt;connect(topoMapper2-\u0026gt;inInitialShape()); auto surfaceVisualizer2 = scn-\u0026gt;addNode(std::make_shared\u0026lt;GLSurfaceVisualNode\u0026lt;DataType3f\u0026gt;\u0026gt;()); topoMapper2-\u0026gt;outShape()-\u0026gt;connect(surfaceVisualizer2-\u0026gt;inTriangleSet());  创建固体边界：  auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(0), Vec3f(1), 0.005, true); elastoplasticBody-\u0026gt;connect(boundary-\u0026gt;importParticleSystems()); elasticBody-\u0026gt;connect(boundary-\u0026gt;importParticleSystems()); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/tutorials/gl_mouseinteraction/",
	"title": "鼠标交互",
	"tags": [],
	"description": "",
	"content": "1、鼠标交互 案例位置：examples/Cuda/Tutorials/GL_MouseInteraction\n功能介绍：该功能主要用于展示鼠标点击事件。案例展示了 CustomMouseInteraction 类的的基本使用。\n案例说明：当鼠标在仿真界面中点击时，后台程序打印出鼠标点击的位置信息。同时当鼠标选中多个实例时，系统能将选中的实例的数量显示出来。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真实例模型：  auto triSet = std::make_shared\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); triSet-\u0026gt;loadObjFile(getAssetPath() + \u0026#34;armadillo/armadillo.obj\u0026#34;); for (uint i = 0; i \u0026lt; 5; i++) { Transform3f tm; tm.translation() = Vec3f(0.4 * i, 0, 0); tm.scale() = Vec3f(1.0 + 0.1 * i, 1.0 - 0.1 * i, 1.0); tm.rotation() = Quat\u0026lt;float\u0026gt;(i * (-0.2), Vec3f(1, 0, 0)).toMatrix3x3(); auto node = scn-\u0026gt;addNode(std::make_shared\u0026lt;TransformNode\u0026gt;()); node-\u0026gt;setName(\u0026#34;TN-\u0026#34; + std::to_string(i)); //node-\u0026gt;loadMesh(\u0026#34;armadillo/armadillo.obj\u0026#34;); \tnode-\u0026gt;setMesh(triSet); node-\u0026gt;setTransform(tm); auto sm = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); sm-\u0026gt;setColor(Vec3f(i * 0.2f, i * 0.2f, 1.f - i * 0.1f)); sm-\u0026gt;setAlpha(0.8f); node-\u0026gt;setSurfaceVisualModule(sm); } scn-\u0026gt;setUpperBound({ 4, 4, 4 });  创建鼠标交互相应事件：  void CustomMouseInteraction::onEvent(PMouseEvent event) { if (event.actionType == AT_PRESS) { printf(\u0026#34;Mouse pressed: Origin: %f %f %f; Direction: %f %f %f \\n\u0026#34;, event.ray.origin.x, event.ray.origin.y, event.ray.origin.z, event.ray.direction.x, event.ray.direction.y, event.ray.direction.z); } else if (event.actionType == AT_RELEASE) { printf(\u0026#34;Mouse released: Origin: %f %f %f; Direction: %f %f %f \\n\u0026#34;, event.ray.origin.x, event.ray.origin.y, event.ray.origin.z, event.ray.direction.x, event.ray.direction.y, event.ray.direction.z); } else { printf(\u0026#34;%f %f \\n\u0026#34;, event.x, event.y); printf(\u0026#34;Mouse repeated: Origin: %f %f %f; Direction: %f %f %f \\n\u0026#34;, event.ray.origin.x, event.ray.origin.y, event.ray.origin.z, event.ray.direction.x, event.ray.direction.y, event.ray.direction.z); } } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/heightfield/gl_oceanpatch/",
	"title": "海浪模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/HeigthField/GL_OceanPatch\n功能介绍：该案例展示了 OceanPatch 类的基本使用。通过对海洋的波形及运动的模拟来实现对不同海洋等级的仿真。利用一系列单元波的振幅、频率、传播方向等参数，经线性叠加合成海浪。根据快速傅里叶变换（FFT）的海浪模拟的思想，利用Phillips波普得到海面的高度场（也就是傅里叶变换的频域），然后将其逆傅里叶变换（IFFT）得到海面（也就是时域），从何实现对海浪的模拟。\n案例说明：该案例主要用于模拟测试不同等级的海浪功能。海平面在风的作用力下形成海浪，不同等级的风可以产生不同的海浪。用户通过设定风速等级，从何达到模拟不同等级海浪的效果。\n2、程序实现  创建场景图：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建OceanPatch节点，并将海浪等级设置为8。  auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;OceanPatch\u0026lt;DataType3f\u0026gt;\u0026gt;()); root-\u0026gt;varWindType()-\u0026gt;setValue(8);  创建渲染节点：  auto mapper = std::make_shared\u0026lt;HeightFieldToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); root-\u0026gt;stateHeightField()-\u0026gt;connect(mapper-\u0026gt;inHeightField()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(0, 0.2, 1.0)); sRender-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_clothoverball_1/",
	"title": "球与1块布碰撞模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_ClothOverBall_1\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。布料在重力作用下，从空中掉落到静态球体，并形成褶皱的过程。\n2、程序实现  创建场景图、边界以及静态球杆模型：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, 0, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); auto object = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticTriangularMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); object-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;cloth_shell/ball/ball_model.obj\u0026#34;); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;VolumeBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-1.5, 0, -1.5), Vec3f(1.5, 3, 1.5), 0.005f, true); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;cloth_shell/ball/ball_small_size_15.sdf\u0026#34;, false);  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15, 500, 0.0005, 1e-3)); cloth-\u0026gt;setDt(0.001f); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/cloth_size_17_alt/cloth_40k_1.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems()); cloth-\u0026gt;setGrad_ite_eps(0); cloth-\u0026gt;setMaxIteNumber(10); auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(0.4, 0.4, 1.0));  创建渲染节点：  auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRenderer-\u0026gt;setColor(Color(0.4, 0.4, 0.4)); surfaceRenderer-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); object-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); object-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); cloth-\u0026gt;setVisible(true); object-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/peridynamics/",
	"title": "近场动力学",
	"tags": [],
	"description": "",
	"content": "近场动力学(PeriDynamics，PD)兼有分子动力学方法和无网格方法的优点，避免了基于连续性假设建模和求解空间微分方程的传统宏观方法在面临不连续问题时的奇异性，又突破了经典分子动力学方法在计算尺度上的局限，在宏/微观不连续力学问题分析中均表现出很高的求解精度和效率。PD方法适用于不同尺度的不连续力学问题，包括均匀与非均匀材料和结构的大变形、损伤、断裂、冲击、穿透和失稳问题。\n案例中介绍了基于近场动力学的布料、弹性体以及塑性材料的仿真。\n  布料模拟: 介绍布料材料仿真；\n  弹性体模拟: 介绍弹性体仿真；\n  塑性材料: 介绍塑性材料仿真；\n  "
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/fieldsync/",
	"title": "数据同步",
	"tags": [],
	"description": "",
	"content": "1、Field数据同步 为了有效实现数据的同步，避免冗余的计算开销，PeriDyno引入时间戳的概念。通过维护一个全局变量的计数器来记录数据修改的时间，具体实现如下：\nclass TimeStamp { public: TimeStamp() {}; ~TimeStamp(); void mark(); bool operator \u0026gt; (TimeStamp\u0026amp; ts) { return (mTickTime \u0026gt; ts.mTickTime); } bool operator \u0026lt; (TimeStamp\u0026amp; ts) { return (mTickTime \u0026lt; ts.mTickTime); } private: uint64 mTickTime = 0; }; 此外，每个Field维护两个时间戳并分别用tick()和tack()接口函数进行标记：\nvoid tick();\rvoid tack();\r其中tick()函数表示数据更新的时间，tack()函数表示数据使用的时间。\n以下图为例，当Module 1更新完之后，依次调用所有输出数据的tick()接口记录Field 8的更新时间。Module 2执行过程首先进行Field 9的tack()时间与Field 8的tick()时间进行比较，只有当Field 9的tack()时间早于Field 8的tick()才执行Module 2内部算法，完成Module 2状态标量的更新。当Module 2完成更新之后首先调用所有输入Field的tack()函数标记使用时间，然后再调用所有输出Field的tick()函数标记数据修改时间，从而完成模块更新。 当检测到Field 9的tack()时间不早于Field 8的tick()时间时，Module 2不需要更新因此会跳过执行。\n\r2、管线数据同步 多线程运行环境下，仿真管线和渲染管线可能存在读写冲突，PeriDyno通过互斥锁来实现管线之间的数据同步。\n如上图所示，渲染管线与仿真管线分别运行独立线程。当渲染需要更新数据时，需要尝试锁住仿真管线。只有当仿真管线被锁之后，渲染管线才能调用SceneGraph()的updateGraphicsContext()函数更新渲染数据。更新完了之后释放互斥锁，仿真管线恢复运行。\n上述同步机制的设计主要为了充分保证渲染和交互的流畅性，防止进程因为仿真计算任务过大而出现卡死的情况。\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/modules/",
	"title": "模块",
	"tags": [],
	"description": "",
	"content": "1、功能简介 模块为节点内部独立的算法单元，由输入数据、输出数据和控制变量构成。模块与节点最大的差别在于输入输出类型。模块只接受Field类型的数据。\n2、如何实现一个模块功能 实现一个模块功能的步骤如下：\n  定义输入数据（通常至少要求一个）：\n与节点中定义类似，采用DEF_{*}_IN的宏定义完成。\n  定义输出数据（可选）：\n与节点中定义类似，采用DEF_{*}_OUT的宏定义完成。\n  定义控制变量：\n与节点中定义类似，采用DEF_VAR的宏定义完成。\n控制变量必须在模块执行之前完成初始化。\n\r  重载模块函数：\n重载接口有特定模块类型决定，详情参加Module相应模块。\n\r  3、模块样例 /** * @brief The standard summation density * * @tparam TDataType */ template\u0026lt;typename TDataType\u0026gt; class SummationDensity : public virtual ParticleApproximation\u0026lt;TDataType\u0026gt; { DECLARE_TCLASS(SummationDensity, TDataType) public: typedef typename TDataType::Real Real; typedef typename TDataType::Coord Coord; SummationDensity(); ~SummationDensity() override {}; void compute() override; public: void compute( DArray\u0026lt;Real\u0026gt;\u0026amp; rho, DArray\u0026lt;Coord\u0026gt;\u0026amp; pos, DArrayList\u0026lt;int\u0026gt;\u0026amp; neighbors, Real smoothingLength, Real mass); void compute( DArray\u0026lt;Real\u0026gt;\u0026amp; rho, DArray\u0026lt;Coord\u0026gt;\u0026amp; pos, DArray\u0026lt;Coord\u0026gt;\u0026amp; posQueried, DArrayList\u0026lt;int\u0026gt;\u0026amp; neighbors, Real smoothingLength, Real mass); public: DEF_VAR(Real, RestDensity, 1000, \u0026#34;Rest Density\u0026#34;); ///Define inputs \t/** * @brief Particle positions */ DEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Particle position\u0026#34;); /** * @brief Particle positions */ DEF_ARRAY_IN(Coord, Other, DeviceType::GPU, \u0026#34;Particle position\u0026#34;); /** * @brief Neighboring particles * */ DEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;Neighboring particles\u0026#39; ids\u0026#34;); ///Define outputs \t/** * @brief Particle densities */ DEF_ARRAY_OUT(Real, Density, DeviceType::GPU, \u0026#34;Return the particle density\u0026#34;); private: void calculateParticleMass(); Real m_particle_mass; Real m_factor; }; IMPLEMENT_TCLASS(SummationDensity, TDataType) 4、Qt GUI中的模块视图 鼠标双击Node Editor窗口中的节点，会出现该节点的详细属性信息。例如，双击ParticleFluid节点后，其详细的属性信息如下图所示： "
},
{
	"uri": "https://peridyno.github.io/zh/framework/interaction/",
	"title": "交互",
	"tags": [],
	"description": "",
	"content": "1、PeriDyno中仿真、渲染与交互的关系 为保证架构上的统一，PeriDyno将任意交互行为抽象为功能模块，并嵌入到每个节点的仿真管线和渲染管线中，来完成一些较为复杂场景的建模。针对PC环境，典型的交互模块包括如下三类：\n 鼠标交互 键盘交互 算法交互  下图展示了一个典型的带仿真、渲染以及交互功能节点。\n其中的交互模块可以是鼠标交互、键盘交互或者是算法交互，同时注意到渲染交互模块既然可以嵌入仿真管线也可以嵌入渲染管线，分别用于辅助仿真计算和渲染。\n2、仿真、渲染与交互运行时序图 以GLFW为例，PeriDyno中仿真、渲染和交互的模块调用时序图如下：\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_glvisualmodule/",
	"title": "渲染模块",
	"tags": [],
	"description": "",
	"content": "1、渲染模块 案例位置：examples/Cuda/QtGUI/Qt_GLVisualModule\n功能介绍：该案例展示了Qt框架下 GLPointVisualModule 类的的基本使用。渲染模块是渲染节点的一部分，在渲染模块中可以对渲染节点的属性进行修改，同时通过场景图更换其他的渲染模块。\n案例说明：案例渲染了一个球体形状的流体粒子群。粒子群在重力的作用下向下掉落。随着掉落速度的增加，粒子的颜色随之发生改变。案例中点击GLPointVisualNode节点可对该节点中的渲染模块进行修改，例如粒子颜色、粒子大小等。\n  渲染节点：   渲染模块：   2、程序实现 接下来介绍案例的实现过程：\n 创建场景图及边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setUpperBound(Vec3f(1.5, 1, 1.5)); scn-\u0026gt;setLowerBound(Vec3f(-0.5, 0, -0.5));  创建球体模型，并将其转为流体粒子:  //Create a sphere \tauto sphere = scn-\u0026gt;addNode(std::make_shared\u0026lt;SphereModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); sphere-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.6, 0.85, 0.5)); sphere-\u0026gt;varRadius()-\u0026gt;setValue(0.1f); sphere-\u0026gt;graphicsPipeline()-\u0026gt;disable(); //Create a sampler \tauto sampler = scn-\u0026gt;addNode(std::make_shared\u0026lt;SphereSampler\u0026lt;DataType3f\u0026gt;\u0026gt;()); sampler-\u0026gt;varSamplingDistance()-\u0026gt;setValue(0.005); sampler-\u0026gt;graphicsPipeline()-\u0026gt;disable(); sphere-\u0026gt;outSphere()-\u0026gt;connect(sampler-\u0026gt;inSphere()); auto initialParticles = scn-\u0026gt;addNode(std::make_shared\u0026lt;MakeParticleSystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); sampler-\u0026gt;statePointSet()-\u0026gt;promoteOuput()-\u0026gt;connect(initialParticles-\u0026gt;inPoints()); auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); //fluid-\u0026gt;loadParticles(Vec3f(0.5, 0.2, 0.4), Vec3f(0.7, 1.5, 0.6), 0.005); \tinitialParticles-\u0026gt;connect(fluid-\u0026gt;importInitialStates()); auto testNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;NodePortConnectionTest\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;connect(testNode-\u0026gt;importParticleSystem());  创建渲染节点:  auto ptVisulizer = scn-\u0026gt;addNode(std::make_shared\u0026lt;GLPointVisualNode\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto outTop = fluid-\u0026gt;statePointSet()-\u0026gt;promoteOuput(); auto outVel = fluid-\u0026gt;stateVelocity()-\u0026gt;promoteOuput(); outTop-\u0026gt;connect(ptVisulizer-\u0026gt;inPoints()); outVel-\u0026gt;connect(ptVisulizer-\u0026gt;inVector()); auto nullNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;InputFieldTest\u0026lt;DataType3f\u0026gt;\u0026gt;()); testNode-\u0026gt;outPointSetOut()-\u0026gt;connect(nullNode-\u0026gt;inPointSet()); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/",
	"title": "Qt框架",
	"tags": [],
	"description": "",
	"content": "Qt是一个跨平台 C++ 图形用户界面应用程序开发框架。PeriDyno引擎中GUI界面由Qt框架开发。 PeriDyno物理方向引擎Qt框架包含以下几个部分：\n 菜单栏：菜单栏提供常见的功能，包括新建、打开、保存以及关闭场景图等功能。同时允许用户自定义功能以插件的形式导入菜单栏； 仿真显示区域：将仿真结果可视化； 日志输出区域：输出系统日志以及程序相关运行结果； 节点编辑区域：提供场景图和节点编辑功能，允许用户通过节点连接的方式创建仿真任务； 属性修改区域：对指定节点属性进行修改。  Qt框架相关案例介绍：\n 刚体仿真: 介绍刚体运动仿真； 节点连接关系: 介绍节点的连接关系； 创建节点和Field数据:介绍如何创建一个节点和field数据； 渲染模块: 介绍渲染管线的功能； 渲染节点: 介绍渲染节点的功能； GUI示例：提供一个Qt GUI示例； 插件: 介绍如何在Qt GUI框架中添加插件； 等值面提取: 介绍Marching Cubes体素级重建方法； 拾取功能: 介绍在鼠标拾取功能； 鼠标交互: 介绍在Qt框架下，鼠标的交互； 重置节点: 介绍NodeEditor中节点重置功能； 三维模型变换: 介绍三维模型变换功能； 中文展示: 介绍如何在Qt框架中使用中文； 变化视角: 介绍在Qt框架下，相机视角的变化。  "
},
{
	"uri": "https://peridyno.github.io/zh/examples/rigidbody/gl_timing/",
	"title": "模块性能测试",
	"tags": [],
	"description": "",
	"content": "1、模块性能测试 案例位置：examples/Cuda/RigidBody/GL_Timing\n功能介绍：该案例主要用于测试程序模块的执行效率。\n案例说明：案例展示了在程序执行之后，各模块的执行时间，便于用户分析程序节点和模块的性能。\n2、程序实现 接下来介绍案例的实现过程：\n 创建刚体碰撞仿真任务:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto rigid = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.5, 0, 0); BoxInfo box; for (int i = 8; i \u0026gt; 1; i--) for (int j = 0; j \u0026lt; i + 1; j++) { box.center = 0.5f * Vec3f(0.5f, 1.1 - 0.13 * i, 0.12f + 0.21 * j + 0.1 * (8 - i)); box.halfLength = 0.5f * Vec3f(0.065, 0.065, 0.1); rigid-\u0026gt;addBox(box, rigidBody); } SphereInfo sphere; sphere.center = Vec3f(0.5f, 0.75f, 0.5f); sphere.radius = 0.025f; RigidBodyInfo rigidSphere; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.95f, 0.5f); sphere.radius = 0.025f; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.65f, 0.5f); sphere.radius = 0.05f; rigid-\u0026gt;addSphere(sphere, rigidSphere); TetInfo tet; tet.v[0] = Vec3f(0.5f, 1.1f, 0.5f); tet.v[1] = Vec3f(0.5f, 1.2f, 0.5f); tet.v[2] = Vec3f(0.6f, 1.1f, 0.5f); tet.v[3] = Vec3f(0.5f, 1.1f, 0.6f); rigid-\u0026gt;addTet(tet, rigidSphere); auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); //TODO: to enable using internal modules inside a node \t//Visualize contact normals \tauto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); rigid-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(elementQuery); auto contactMapper = std::make_shared\u0026lt;ContactsToEdgeSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactMapper-\u0026gt;inContacts()); contactMapper-\u0026gt;varScale()-\u0026gt;setValue(0.02); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactMapper); auto wireRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); wireRender-\u0026gt;setColor(Vec3f(0, 1, 0)); contactMapper-\u0026gt;outEdgeSet()-\u0026gt;connect(wireRender-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(wireRender); //Visualize contact points \tauto contactPointMapper = std::make_shared\u0026lt;ContactsToPointSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactPointMapper-\u0026gt;inContacts()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactPointMapper); auto pointRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRender-\u0026gt;setColor(Vec3f(1, 0, 0)); contactPointMapper-\u0026gt;outPointSet()-\u0026gt;connect(pointRender-\u0026gt;inPointSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRender);  打印模块执行时间:  scn-\u0026gt;printNodeInfo(true); scn-\u0026gt;printModuleInfo(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/tutorials/gl_mouseinteractioningraphicspipeline/",
	"title": "渲染管线中鼠标交互",
	"tags": [],
	"description": "",
	"content": "1、渲染管线中鼠标交互 案例位置：examples/Cuda/Tutorials/GL_MouseInteractionInGraphicsPipeline\n功能介绍：主要用于测试鼠标交互功能。该案例展示了 CustomMouseInteraction 类的的基本使用。\n案例说明：该功能主要用于响应鼠标事件，包括鼠标移动、点击和释放等。当鼠标发出不同指令时，程序会调用不同的接口，便于用户和仿真程序的交互。案例中展示了鼠标在仿真界面移动、点击时，程序打印出相应的状态、位置坐标等信息。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真实例模型：  auto triSet = std::make_shared\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); triSet-\u0026gt;loadObjFile(getAssetPath() + \u0026#34;armadillo/armadillo.obj\u0026#34;); for (uint i = 0; i \u0026lt; 5; i++) { Transform3f tm; tm.translation() = Vec3f(0.4 * i, 0, 0); tm.scale() = Vec3f(1.0 + 0.1 * i, 1.0 - 0.1 * i, 1.0); tm.rotation() = Quat\u0026lt;float\u0026gt;(i * (-0.2), Vec3f(1, 0, 0)).toMatrix3x3(); auto node = scn-\u0026gt;addNode(std::make_shared\u0026lt;TransformNode\u0026gt;()); node-\u0026gt;setName(\u0026#34;TN-\u0026#34; + std::to_string(i)); //node-\u0026gt;loadMesh(\u0026#34;armadillo/armadillo.obj\u0026#34;); \tnode-\u0026gt;setMesh(triSet); node-\u0026gt;setTransform(tm); auto sm = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); sm-\u0026gt;setColor(Vec3f(i * 0.2f, i * 0.2f, 1.f - i * 0.1f)); sm-\u0026gt;setAlpha(0.8f); node-\u0026gt;setSurfaceVisualModule(sm); } scn-\u0026gt;setUpperBound({ 4, 4, 4 });  创建鼠标交互相应节点：  //Create a CustomMouseInteraction object to handle the mouse event, \t//Press/release the mouse button to show the information \tauto mouseInterator = std::make_shared\u0026lt;CustomMouseInteraction\u0026gt;(); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(mouseInterator-\u0026gt;inTopology()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mouseInterator);  创建渲染节点及边界：  auto instanceRender = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); instanceRender-\u0026gt;setColor(Vec3f(0, 1, 0)); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(instanceRender-\u0026gt;inTriangleSet()); instanceNode-\u0026gt;stateTransforms()-\u0026gt;connect(instanceRender-\u0026gt;inTransform()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(instanceRender); scn-\u0026gt;setUpperBound({ 4, 4, 4 }); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/heightfield/qt_buoyancy/",
	"title": "浮力模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/HeigthField/Qt_Buoyancy\n功能介绍：该案例展示了 Coupling 类的基本使用。浸在流体内的物体受到流体竖直向上的作用力，与重力的方向相反。物体在液体中所受浮力的大小，只跟它排开液体体积和液体的密度有关，与物体本身的密度、运动状态、浸没在液体中的深度等因素无关。此场景为高度场技术的综合应用，模拟测试浮力仿真效果。\n案例说明：案例主要展示物体在浮力的作用下漂浮在水面的效果。该案例通过Ocean节点模拟海面，使用RigidMesh类模拟刚体，最后通过Coupling节点对两者进行耦合，从而实现帆船浮在水面的效果。\n案例中使用的是Qt框架，用户可以点击节点调整节点的属性。例如可以点击OceanPatch节点，通过更改Wind Type属性来设置不同的海浪等级。\n2、程序实现  创建场景图：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建Ocean节点和OceanPatch节点，构建海洋环境：  auto ocean = scn-\u0026gt;addNode(std::make_shared\u0026lt;Ocean\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto patch = scn-\u0026gt;addNode(std::make_shared\u0026lt;OceanPatch\u0026lt;DataType3f\u0026gt;\u0026gt;()); patch-\u0026gt;varWindType()-\u0026gt;setValue(3); patch-\u0026gt;connect(ocean-\u0026gt;importOceanPatch());  创建海洋渲染节点：  auto mapper = std::make_shared\u0026lt;HeightFieldToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); ocean-\u0026gt;stateHeightField()-\u0026gt;connect(mapper-\u0026gt;inHeightField()); ocean-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(0, 0.2, 1.0)); sRender-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); sRender-\u0026gt;varAlpha()-\u0026gt;setValue(0.6); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); ocean-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender);  创建帆船RigidMesh节点，帆船RigidMesh节点继承于刚体节点RigidBody，并为其加载表面网格：  auto boat = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); boat-\u0026gt;varScale()-\u0026gt;setValue(Vec3f(5)); boat-\u0026gt;varDensity()-\u0026gt;setValue(150.0f); boat-\u0026gt;stateVelocity()-\u0026gt;setValue(Vec3f(10, 0, 0)); boat-\u0026gt;varEnvelopeName()-\u0026gt;setValue(getAssetPath() + \u0026#34;obj/boat_boundary.obj\u0026#34;); boat-\u0026gt;varMeshName()-\u0026gt;setValue(getAssetPath() + \u0026#34;obj/boat_mesh.obj\u0026#34;); auto dragging = std::make_shared\u0026lt;DragBoat\u0026lt;DataType3f\u0026gt;\u0026gt;(); boat-\u0026gt;stateVelocity()-\u0026gt;connect(dragging-\u0026gt;inVelocity()); boat-\u0026gt;stateQuaternion()-\u0026gt;connect(dragging-\u0026gt;inQuaternion()); boat-\u0026gt;animationPipeline()-\u0026gt;pushModule(dragging);  创建渲染节点，对帆船进行可视化：  auto rigidMeshRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); rigidMeshRender-\u0026gt;setColor(Vec3f(0.8, 0.8, 0.8)); boat-\u0026gt;stateMesh()-\u0026gt;promoteOuput()-\u0026gt;connect(rigidMeshRender-\u0026gt;inTriangleSet()); boat-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(rigidMeshRender);  创建浮力节点，对帆船和海洋进行耦合：  auto coupling = scn-\u0026gt;addNode(std::make_shared\u0026lt;Coupling\u0026lt;DataType3f\u0026gt;\u0026gt;()); boat-\u0026gt;connect(coupling-\u0026gt;importRigidMesh()); ocean-\u0026gt;connect(coupling-\u0026gt;importOcean()); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_clothoverball_3/",
	"title": "球与3块布碰撞模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_ClothOverBall_3\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。3块布料在重力作用下，从空中掉落到静态球体，并形成褶皱的过程。测试布料算法稳定性。\n2、程序实现  创建场景图、边界以及静态球杆模型：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, 0, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); auto object = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticTriangularMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); object-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;cloth_shell/ball/ball_model.obj\u0026#34;); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;VolumeBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-1.5, 0, -1.5), Vec3f(1.5, 3, 1.5), 0.005f, true); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;cloth_shell/ball/ball_small_size_15.sdf\u0026#34;, false);  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15,500,0.0005,1e-3)); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/cloth_size_17_alt/cloth_40k_3.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems()); cloth-\u0026gt;setGrad_ite_eps(0); cloth-\u0026gt;setMaxIteNumber(10);  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(0.4, 0.4, 1.0)); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRenderer-\u0026gt;setColor(Color(0.4, 0.4, 0.4)); surfaceRenderer-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); object-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); object-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); cloth-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/topics/",
	"title": "技术专题",
	"tags": [],
	"description": "",
	"content": "技术专题主要分为如下几类：\n  粒子系统: 介绍基于PBD、SPH的流体仿真；\n  刚体动力学: 介绍刚体动力学相关算法；\n  有限元法：介绍基于FEM的仿真算法；\n  高度场: 介绍基于高度场的海洋模拟；\n  离线渲染与后处理：介绍peridyno的后处理;\n  程序化建模：介绍peridyno程序化建模。\n  "
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/fields/",
	"title": "数据",
	"tags": [],
	"description": "",
	"content": "1、Field功能简介 Field是对基本数据类型的封装，从而实现节点以及模块之间的数据传递。典型的数据类型包含如下几类：\n 基本类型：指数据量比较小，可以在CPU和GPU进行直接传递的数据，典型的包括bool、int、float、double等标量数据以及Vec3f、Vec3d、Mat3f、Mat3d等张量数据。Field可通过FVar来完成数据的定义和传递； 静态数组：指数据尺寸固定的连续存储空间，包括一维数组、二维数组、三维数组等。Field宏定义采用DEF_ARRAY{2D, 3D}_{*}的形式。 动态数组：指数据尺寸动态变化的连续存储空间，包括List、Map、Set、MultiSet、Pair、Stack等类型的数据。Field宏定义采用DEF_ARRAYLIST_{*}的形式。 引用类型：针对复杂类型，采用类似C++指针的方式进行数据定义。Field宏定义采用DEF_INSTANCE_{*}的形式。  Field之间的连接和断开主要依赖以下两个函数实现，连接过程中会进行数据有效性验证，如有效则返回true，无效返回false。\nvirtual bool connect(FBase* dst) = 0; virtual bool disconnect(FBase* dst); FBase作为所有Field的基类，其功能主要是对Field的连接状态进行统一管理。\nconnect(FBase* dst)在FBase中被定义为纯虚函数，因而其具体实现依赖于特定Field。该设计主要为了对数据连接行为进行有效的验证，防止将数据连接到错误的类型。\n\r假设存在A、B、C三个Field类型数据，他们的连接关系设置为A-\u0026gt;B-\u0026gt;C。此时为了降低数据转换和存储开销，当我们对C的数据进行操作时，会根据其连接关系返回最顶端（这里对应的是A）的数据指针进行操作。\n2、Field数据类型   FVar：继承自FBase，是对单一数据类型的封装，包括标量数据，如int、float、double等；矢量数据，如Vec3f等；二阶张量数据，如Mat3f；文件路径类型数据，如FilePath。节点和模块中可以通过使用DEF_VAR/DEF_VAR_IN等宏定义来进行定义：\nDEF_VAR(Real, TangentialFriction, 0.0, \u0026#34;Tangential friction\u0026#34;); 其中Real代表数据类型，TangentialFriction代表数据名称，0.0代表初值，\u0026ldquo;Tangential friction\u0026quot;则表示数据的说明。通过DEF_VAR定义的数据实际使用过程中可以通var+数据名称的方式对数据进行操作。假设我们需要将上述Field连接到另一个功能模块，则可以调用如下接口进行：\nthis-\u0026gt;varRestDensity()-\u0026gt;connect(...);\r常见数据类型定义及GUI视图如下：\n（1）FVar，int类型：\nC++代码定义：\nDEF_VAR(int, Types, 4, \u0026#34;winds Types\u0026#34;); Qt视图：\n（2）FVar，float类型：\nC++代码定义：\nDEF_VAR_IN(Real, Radius, \u0026#34;Search radius\u0026#34;); Qt视图：\n（3）FVar，bool类型：\nC++代码定义：\nDEF_VAR(bool, Active, true, \u0026#34;Indicating whether the simulation is on for this node!\u0026#34;); Qt视图： （4）FVar，FilePath类型：\nC++代码定义：\nDEF_VAR(FilePath, FileName, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); Qt视图： （5）FVar，Vec3f类型：\nC++代码定义：\nDEF_VAR(Vec3f, Location, 0, \u0026#34;Node location\u0026#34;); Qt视图： （6）FVar，PEnum数据：枚举数据类型。通过DEF_ENUM定义数据，通过var+数据名称的对数据进行操作。ENUM类型定义如下：\nC++代码定义：\nDECLARE_ENUM(EKernelType, KT_Smooth = 0, KT_Spiky = 1); DEF_ENUM(EKernelType, KernelType, EKernelType::KT_Spiky, \u0026#34;Rendering mode\u0026#34;); Qt视图： 参数类型为int、uint、Vec3f、Vec3d的FVar数据需要调用setRange()函数设置数据的有效范围，否则Qt界面可能会显示异常。\n\r  FArray：对Array.h中定义的一维数组进行封装，类似于STL中的vector。根据其在节点/模块中的不同功能，我们采用如下三种形式定义：\nDEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//输入 输入数据，访问方式为in+数据名称，即inPosition()。\nDEF_ARRAY_OUT(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//输出 输出数据，访问方式为out+数据名称，即outPosition()。\nDEF_ARRAY_STATE(Coord, Position, DeviceType::GPU, \u0026#34;Internal state\u0026#34;);\t//内部状态变量 状态变量，访问方式为state+数据名称，即statePosition()。\n  FArrayList：对ArrayList.h数据进行封装，用于支持CPU/GPU兼容的动态数据类型。其定义方式与FArray类似，即：\nDEF_ARRAYLIST_IN(Coord, Position, DeviceType::GPU, \u0026#34;Input\u0026#34;);\t//输入 输入数据，访问方式为in+数据名称，即inPosition()。\nDEF_ARRAYLIST_OUT(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//输出 输出数据，访问方式为out+数据名称，即outPosition()。\nDEF_ARRAYLIST_STATE(Coord, Position, DeviceType::GPU, \u0026#34;Internal state\u0026#34;);\t//内部状态变量 状态变量，访问方式为state+数据名称，即statePosition()。\n  FInstance：主要为了支持存在继承关系的数据之间的连接，典型应用为利用FInstance定义不同拓扑结构数据：\nDEF_INSTANCE_IN(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;PointSet is derived from TopologyModule\u0026#34;);\t//输入 输入数据，访问方式为in+数据名称，任意继承自PointSet的子类都可以连接到该数据。\nDEF_INSTANCE_OUT(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;Output\u0026#34;);\t//输出 输出数据，访问方式为out+数据名称。\nDEF_INSTANCE_STATE(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;Internal state\u0026#34;);\t//内部状态变量 状态变量，访问方式为state+数据名称，在Qt界面中，显示如下：   "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_glvisualnode/",
	"title": "渲染节点",
	"tags": [],
	"description": "",
	"content": "1、渲染节点 案例位置：examples/Cuda/QtGUI/Qt_GLVisualNode\n功能介绍：案例展示了渲染节点的使用。PeriDyno引擎中包括多种类型的渲染节点，例如粒子渲染、三角面片渲染、线条渲染等。相关渲染节点请参考 Module模块 。\n案例说明：由粒子系统组成的水体，在重力的作用下向下运动，粒子颜色随速度的变化而发生改变。用户可以通过双击NodeEditor中的节点，修改节点中模块的属性。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图及边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setUpperBound(Vec3f(1.5, 1, 1.5)); scn-\u0026gt;setLowerBound(Vec3f(-0.5, 0, -0.5));  创建基于矩形，并将其转化为流体粒子:  //Create a cube \tauto cube = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); cube-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.6, 0.85, 0.5)); cube-\u0026gt;varLength()-\u0026gt;setValue(Vec3f(0.1, 0.65, 0.1)); cube-\u0026gt;graphicsPipeline()-\u0026gt;disable(); //Create a sampler \tauto sampler = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeSampler\u0026lt;DataType3f\u0026gt;\u0026gt;()); sampler-\u0026gt;varSamplingDistance()-\u0026gt;setValue(0.005); sampler-\u0026gt;graphicsPipeline()-\u0026gt;disable(); cube-\u0026gt;outCube()-\u0026gt;connect(sampler-\u0026gt;inCube()); auto initialParticles = scn-\u0026gt;addNode(std::make_shared\u0026lt;MakeParticleSystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); sampler-\u0026gt;statePointSet()-\u0026gt;promoteOuput()-\u0026gt;connect(initialParticles-\u0026gt;inPoints()); auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); //fluid-\u0026gt;loadParticles(Vec3f(0.5, 0.2, 0.4), Vec3f(0.7, 1.5, 0.6), 0.005); \tinitialParticles-\u0026gt;connect(fluid-\u0026gt;importInitialStates());  创建边界及渲染节点:  //Create a boundary \tauto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); ; boundary-\u0026gt;loadCube(Vec3f(-0.5, 0, -0.5), Vec3f(1.5, 2, 1.5), 0.02, true); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;bowl/bowl.sdf\u0026#34;, false); fluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems()); auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); fluid-\u0026gt;statePointSet()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender); // A simple color bar widget for node \tauto colorBar = std::make_shared\u0026lt;ImColorbar\u0026gt;(); colorBar-\u0026gt;varMax()-\u0026gt;setValue(5.0f); colorBar-\u0026gt;varFieldName()-\u0026gt;setValue(\u0026#34;Velocity\u0026#34;); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorBar-\u0026gt;inScalar()); // add the widget to app \tfluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorBar); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/rigidbody/gl_wireframe/",
	"title": "线框渲染",
	"tags": [],
	"description": "",
	"content": "1、线框渲染 案例位置：examples/Cuda/RigidBody/GL_Wireframe\n功能介绍：该案例展示将模型表面绘制成线框。\n案例说明：该案例主要展示如何使用渲染节点，并以GLWireframeVisualModulel节点为例，将仿真物体以线框的形式展示。线条的形式有两种，一种是线段模式，一种是圆柱模式（加粗的线段）。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  常见一些正方体，四面体和球体等刚体模型:  auto rigid = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.5, 0, 0); BoxInfo box; for (int i = 8; i \u0026gt; 1; i--) for (int j = 0; j \u0026lt; i + 1; j++) { box.center = 0.5f * Vec3f(0.5f, 1.1 - 0.13 * i, 0.12f + 0.21 * j + 0.1 * (8 - i)); box.halfLength = 0.5f * Vec3f(0.065, 0.065, 0.1); rigid-\u0026gt;addBox(box, rigidBody); } SphereInfo sphere; sphere.center = Vec3f(0.5f, 0.75f, 0.5f); sphere.radius = 0.025f; RigidBodyInfo rigidSphere; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.95f, 0.5f); sphere.radius = 0.025f; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.65f, 0.5f); sphere.radius = 0.05f; rigid-\u0026gt;addSphere(sphere, rigidSphere); TetInfo tet; tet.v[0] = Vec3f(0.5f, 1.1f, 0.5f); tet.v[1] = Vec3f(0.5f, 1.2f, 0.5f); tet.v[2] = Vec3f(0.6f, 1.1f, 0.5f); tet.v[3] = Vec3f(0.5f, 1.1f, 0.6f); rigid-\u0026gt;addTet(tet, rigidSphere);  将单元转化为三角网格，并创建GLWireframeVisualModule渲染节点:  auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); sRender-\u0026gt;varRenderMode()-\u0026gt;getDataPtr()-\u0026gt;setCurrentKey(GLWireframeVisualModule::LINE); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/tutorials/gl_segmentvisualizer/",
	"title": "线框渲染",
	"tags": [],
	"description": "",
	"content": "1、线框材料 案例位置：examples/Cuda/Tutorials/GL_SegmentVisualizer\n功能介绍：案例展示了大规模网格线框渲染功能。线框渲染有两种模式：一种是普通的线条渲染，这种线条较细；另一种是圆柱线框渲染，这种模式使用圆柱代替线段，使得模型边界更具有辨识性。\n案例说明：通过指定 GLWireframeVisualModule 节点中 EEdgeMode 属性的类型，选择不同的线框模式。LINE表示线段模式；CYLINDER表示圆柱模式。\n  线段模式：   圆柱模式：   2、程序实现 接下来介绍案例的实现过程：\n 创建场景图和渲染示例:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); // create a hexahedron node \tauto instanceNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;HexahedronNode\u0026gt;());  指定线条渲染模块，渲染类型：  // wireframe rendering \tauto edgeRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); edgeRender-\u0026gt;setColor(Vec3f(0, 1, 0)); edgeRender-\u0026gt;varRenderMode()-\u0026gt;getDataPtr()-\u0026gt;setCurrentKey(GLWireframeVisualModule::LINE); edgeRender-\u0026gt;varLineWidth()-\u0026gt;setValue(2.f); instanceNode-\u0026gt;stateHexahedrons()-\u0026gt;connect(edgeRender-\u0026gt;inEdgeSet()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(edgeRender); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/heightfield/qt_heightfild/",
	"title": "基于Qt的海洋模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/HeigthField/Qt_HeightField\n功能介绍：该案例主要展示Qt框架下的高度场海洋仿真功能。用户可以在工具架上便捷的创建高度场相关的仿真任务，并通过节点编辑界面对节点进行编辑，通过属性编辑器对节点的属性进行修改。\n案例说明：该案例仿真效果与GL_OceanPatch示例一样，主要展示Qt界面。用户点击OceanPatch节点时，可以动态调节以下属性。例如通过调节Wind Type属性，来控制风速大小，不同的数值可产生不同等级的海浪。目前支持0-12级风速。通过调节Wind Direction来控制风的方向。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建Ocean节点和OceanPatch节点，构建海洋环境。  auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;OceanPatch\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto mapper = std::make_shared\u0026lt;HeightFieldToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); root-\u0026gt;stateHeightField()-\u0026gt;connect(mapper-\u0026gt;inHeightField()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper);  创建海洋渲染节点：  auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(0, 0.2, 1.0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender);  在Qt框架中创建高度场导航栏。用户可以在导航中快速创建相关案例。  HeightFieldLibrary::initStaticPlugin(); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_clothoverball_6/",
	"title": "球与6块布碰撞模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_ClothOverBall_6\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。6块布料在重力作用下，从空中掉落到静态球体，并形成褶皱的过程。测试布料算法稳定性。\n2、程序实现  创建场景图、边界以及静态球杆模型：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, 0, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); auto object = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticTriangularMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); object-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;cloth_shell/ball/ball_model.obj\u0026#34;); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;VolumeBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-1.5, 0, -1.5), Vec3f(1.5, 3, 1.5), 0.005f, true); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;cloth_shell/ball/ball_small_size_15.sdf\u0026#34;, false);  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15,500,0.0005,1e-3)); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/cloth_size_17_alt/cloth_40k_3.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems()); cloth-\u0026gt;setGrad_ite_eps(0); cloth-\u0026gt;setMaxIteNumber(10);  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(0.4, 0.4, 1.0)); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRenderer-\u0026gt;setColor(Color(0.4, 0.4, 0.4)); surfaceRenderer-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); object-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); object-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); cloth-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/rigidbody/",
	"title": "刚体动力学",
	"tags": [],
	"description": "",
	"content": "刚体（ Rigid Body ）是指在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变的物体。绝对刚体实际上是不存在的，只是一种理想模型。因为任何物体在受力作用后，都或多或少会发生变形。如果变形的程度相对于物体本身几何尺寸来说极为微小，在研究物体运动时变形就可以忽略不计。把许多固体视为刚体，所得到的结果在工程上一般已有足够的准确度。本节主要介绍PeriDyno引擎中刚体动力学系统。\n  刚体动力学: 介绍刚体系统的仿真功能；\n  刚体碰撞：介绍刚体的碰撞功能；\n  碰撞掩码功能: 介绍刚体碰撞掩码功能；\n  模块性能测试: 介绍如何测试模块性能；\n  线框渲染: 介绍模型线框渲染。\n  "
},
{
	"uri": "https://peridyno.github.io/zh/examples/",
	"title": "仿真案例",
	"tags": [],
	"description": "A set of examples guiding users on how to set up different case
",
	"content": "仿真案例位于 {PROJECT_ROOT/example/} 目录下。本章节案例的介绍顺序与代码中样例顺序一一对应。主要向用户展示了PeriDyno引擎的功能，包括布料模拟、弹性体模拟、流体模拟、刚体模拟和基于高度场技术的海洋模拟等。同时也为新用户提供了教学常规案例，位于 {PROJECT_ROOT/example/Cuda/Tutorials} 目前下。用户可以从教学常规案例入手，学习PeriDyno引擎功能。\nPeriDyno支持三种模式，分别是CUDA、Vulkan和NoGPU。大部分示例位于CUDA模式下，Vulkan和NoGPU模式示例较少。因此使用CUDA模式，介绍PeriDyno示例。\n\r  5.1 基于高度场的海洋模拟：介绍高度场技术模拟海洋；\n  5.2 近场动力学: 介绍基于近场动力学的仿真算法；\n  5.3 Qt框架: 介绍PeriDyno交互式Qt框架；\n  5.4 刚体动力学: 介绍刚体动力学；\n  5.5 光滑粒子流体动力学: 介绍基于粒子的流体模拟；\n  5.6 常规案例: 常规教学案例，为新用户提供入门教程的仿真案例。\n  "
},
{
	"uri": "https://peridyno.github.io/zh/framework/rendering/",
	"title": "渲染",
	"tags": [],
	"description": "",
	"content": "1、功能简介 PeriDyno通过渲染模块提供对场景图中各类节点的基础可视化功能。\nclass VisualModule : public Module 目前PeriDyno实现了一套基础OpenGL的渲染引擎和对应的各类节点（Nodes）的渲染模块，以支持用户图像界面（Qt/GLFW）的可视化与交互支功能。\n2、使用渲染模块 在PeriDyno用户图形界面框架（Qt/GLFW）下，通过设置渲染模块的属性，并将其加入到目标节点的图形管线（graphicsPipeline）中，以实现节点的可视化功能。\n2.1、表面三角网格可视化（GLSurfaceVisualModule） 参考样例GL_Bricks。\n\rPeriDyno提供GLSurfaceVisualModule节点来实现物体表面的渲染。以刚体系统为例，为了渲染物体，首先需要通过拓扑映射（TopologyMapping）将数据映射成为可渲染的三角片网格。\nauto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); 如上所示，首先构造DiscreteElementsToTriangleSet对象，并将刚体系统（rigid）的对应数据连接至mapper的输入；再将mapper对象加入到rigid对象的图形管线中，以便在调用图形管线时对内容进行更新。在构造好映射对象mapper后，我们就可以使用GLSurfaceVisualModule，通过将mapper输出到渲染模块来实现当前节点的可视化：\nauto renderModule = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); renderModule-\u0026gt;setColor(Vec3f(1, 1, 0)); // 配置可视化数据来源 mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(renderModule-\u0026gt;inTriangleSet()); // 将渲染模块加入到对应节点的图形管线中 rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(renderModule); 2.1、粒子（点）可视化（GLPointVisualModule） 参考代码GL_ParticleFluid。\n\r与GLSurfaceVisualModule相同，我们首先需要构造对应的映射（mapper）。例如我们首先根据流体粒子的速度计算出法向量，通过法向量来计算粒子的颜色：\nauto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); 接着，我们构造GLPointVisualModule，并将流体系统的点与刚才构造的颜色映射进行连接：\nauto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); fluid-\u0026gt;stateTopology()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); 2.1、线框可视化（GLWireframeVisualModule） 参考代码GL_Wireframe。\n\r使用GLWireframeVisualModule对三角形网格的线框进行可视化，使用方法与GLSurfaceVisualModule类似。先进行数据映射，将三角形网格数据连接到可视化模块上即可：\nauto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto wireframe = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); wireframe-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(wireframe-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(wireframe); 2.1、实例可视化（GLInstanceVisualModule） 参考代码GL_InstanceVisualizer。\n\r在PeriDyno中，可以通过额外的变换矩阵数组来表示实例化的节点。与其他可视化模块类似，只需要将对应的变换矩阵传给GLInstanceVisualModule：\nauto instanceRender = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); instanceRender-\u0026gt;setColor(Vec3f(0, 1, 0)); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(instanceRender-\u0026gt;inTriangleSet()); instanceNode-\u0026gt;stateTransforms()-\u0026gt;connect(instanceRender-\u0026gt;inTransform()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(instanceRender); 3、扩展渲染模块 PeriDyno对节点的可视化提供统一父类（GLVisualModule），实现新的可视化效果需继承该类并重载相应的方法。\n参考代码GLVisualModule.h。\n\rvirtual bool initializeGL() = 0; virtual void updateGL() = 0; virtual void paintGL(RenderPass pass) = 0; 其中，initializeGL()方法在对象初始化时仅被调用一次。通常用于加载对应的Shader，创建所需的Buffer等对象。当仿真更新时，updateGL()方法将被调用，用于同步仿真数据与渲染数据（例如将当前帧修改后的三角形网格更新到OpenGL的VertexBuffer中、更新当前粒子颜色等）。paintGL()在具体执行渲染时被调用。目前PeriDyno提供的基础OpenGL渲染引擎包含两个简单的RenderPass：ShadowPass和ColorPass，其中ShadowPass用于更新ShadowMap来得到阴影效果，ColorPass用于得到最终窗口中所展示的彩色图像。\n"
},
{
	"uri": "https://peridyno.github.io/zh/framework/platform/",
	"title": "三种交互平台",
	"tags": [],
	"description": "",
	"content": "平台介绍 PeriDyno物理引擎针对不同的任务、不同的研发对象，构建了多个开发平台，包括轻量级GLFW平台、交互式Qt平台以及端云协同WT平台。\n1、轻量级GLFW平台 简介： GLFW是配合OpenGL使用的轻量级工具程序库，缩写自Graphics Library Framework（图形库框架）。GLFW的主要功能是创建并管理窗口和OpenGL上下文，同时还提供了处理键盘、鼠标输入的功能。\nPeriDyno引擎中轻量级GLFW框架安装简单，运行效率较高，适用于学生及科研工作人员。引擎中还提供大量GLFW示例。在程序中以GLFW框架运行的示例均以GL开头。\n界面介绍： GLFW界面相对简介，只包含仿真界面和工具栏。\n 仿真界面：用于显示仿真结果； 工具栏：   Camera：视角变换，通过调节相机相关属性来改变视角;\n Use Camera：提供orbit和Trackball两种相机模式 ; Perspective：透视投影，物体大小和观测距离相关，距离越近物体越大，距离越远物体越小； Orthogonal：正交投影，物体大小和观测距离无关。 Top：俯视图； Bottom：仰视图； Left：左视图； Right：右视图； Front：主视图； Back：后视图； Auto Focue：自动聚焦； DistanceUnit：快速调节相机距离；     Lighting：光线相关属性；\n BG color：灯光的颜色，鼠标右键点击数值框，拖动改变数值； Ambient Light：环境光； Main Light：主要光； Main Light Direction：主要光照射方向； Main Light Shadow：是否显示主要光照射阴影；     Auxiliary：辅助功能；\n Lock Camera：是否锁定摄像机； Show View Mainipulator：是否显示左下角的方位魔方； Show Background：是否显示背景网格； Print Node Info：是否打印节点输出信息； Print Module Info：是否打印模块输出信息； Show Bounding Box：是否显示box边界； Lower Bound：下边界设置； Upper Bound：上边界设置；     Edit：三维模型变换；\n Translate：平移变换； Scale：尺寸变换； Rotate：旋转变换； Focus：模型聚焦功能；       操作说明：\n 调节视角：Alt + 鼠标移动； 调节视角距离：Alt + 滚动鼠标中键； 开始仿真任务：空格键（程序启动时，默认停在第0帧。按下空格键后，开始仿真任务）。  2、交互式设计Qt平台 简介： Qt一个跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可以用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏。Qt易于扩展，而且允许组件编程。\nPeriDyno引擎中交互式设计Qt框架以Qt组件为基础，在仿真界面的基础上额外添加了许多组件，包括工具栏、日志栏、节点编辑区域，节点属性编辑区域以及模块编辑区域等。交互式设计Qt框架在安装部署时需要额外安装Qt组件，具备比GLFW框架更强大的交互功能，适用于工程开发人员。用户可以在节点编辑器中创建仿真节点，在节点属性编辑器中更改节点属性，在模块编辑界面编辑功能模块，方便用户搭建复杂场景以及二次开发与集成。在PeriDyno引擎中以Qt平台运行的示例均以Qt开头。\n界面介绍：\n 菜单栏：菜单栏提供常见的功能，包括新建、打开、保存以及关闭场景图等功能。同时允许用户自定义功能以插件的形式导入菜单栏； 仿真显示区域：将仿真结果可视化； 日志输出区域：输出系统日志以及程序相关运行结果； 节点编辑区域：提供场景图和节点编辑功能，允许用户通过节点连接的方式创建仿真任务； 属性修改区域：对指定节点属性进行修改。   操作说明：\n  菜单栏：鼠标左键点击对应的功能；\n  仿真显示区域：请参考GLFW界面操作方法；\n  开始仿真和重置：刻度表示当前帧数；数字表示最大帧数；绿色按钮点击开始仿真，点击之后会变成暂停键；红色按钮点击重新开始仿真；   日志输出区域：打印输出信息。默认不输出日志信息，如需要输出日志信息，点击菜单栏Edite-\u0026gt;Logging选项卡。其中Node节点和Module模块的输出信息，只需要勾选Auxiliary中的Print Node Info和Print Module Info选项；\n  节点编辑区域：\n 创建仿真节点： 鼠标右键，选择相应的节点； 删除节点： 点击待删除的节点，按键盘delete键； 节点连接： 鼠标左键拖动。注意每个节点接口都有自己定义的类型，不同类型的接口无法连接；将鼠标放到接口旁边会显示接口信息；  节点排序： 当节点过多的时候，点击菜单栏Help-\u0026gt;ReOrder选项卡，节点将自动排序； 模块信息： 双击场景图中的节点，例如双击RigidBodySystem节点，其模块信息如下：     属性修改区域：点击节点，可以修改节点属性：\n Control Variable：控制变量属性，包括int、float、Vertor、bool等类型的数据；  State Variable：状态变量数据。勾选后，节点会显示相应的状态数据。     3、端云协同WT平台 简介： WT是一个针对Web应用开发的C++ widget库，同时也是开发和部署web应用的服务器。WT应用模型和现存的GUI库（例如微软的MFC或者TrolTech的Qt）很相似。WT web应用服务器占用较低的内存，因此可以提供基于web的图形用户界面(GUI)。\nPeriDyno引擎中端云协同WT平台需要额外配置云端服务器，通过视频流的形式将仿真结果从服务器传到用户浏览器中，适用于工程应用人员。端云协同WT框架中，支持Python语言，用户不需要搭建复杂的仿真环境。\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_gui_empty/",
	"title": "GUI示例",
	"tags": [],
	"description": "",
	"content": "1、Qt GUI 案例位置：examples/Cuda/QtGUI/Qt_GUI_Empty\n功能介绍：该案例主要展示PeriDyno引擎交互式Qt界面。\n案例说明： 该项目是一个空的Qt GUI项目，向用户介绍如何创建一个Qt GUI工程。\n2、程序实现 接下来介绍案例的实现过程：\n 创建Qt界面:  int main() { QtApp app; //创建Qt 窗口 \tapp.initialize(1366, 800); app.mainLoop(); return 0; } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/sph/",
	"title": "光滑粒子流体动力学",
	"tags": [],
	"description": "",
	"content": "光滑粒子流体动力学方法 (Smoothed Particle Hydrodynamics， SPH) 是一种无网格方法。该方法的基本思想是将视作连续的流体(或固体)用相互作用的质点组来描述，各个物质点上承载各种物理量，包括质量、速度等。通过求解质点组的动力学方程和跟踪每个质点的运动轨道，求得整个系统的力学行为。这类似于物理学中的粒子云 （particle-in-cell) 模拟。从原理上说，只要质点的数目足够多，就能精确地描述力学过程。\n  幽灵粒子: 介绍基于SPH的幽灵粒子流体仿真；\n  粒子发射器: 介绍基于粒子的流体发射器；\n  基于粒子的流体仿真: 介绍基于粒子的流体仿真；\n  "
},
{
	"uri": "https://peridyno.github.io/zh/examples/tutorials/gl_topology/",
	"title": "拓扑结构",
	"tags": [],
	"description": "",
	"content": "1、拓扑结构 案例位置：examples/Cuda/Tutorials/GL_Topology\n功能介绍：该案例主要向用户展示如何使用渲染模块对模型进行渲染。\n案例说明：案例中创建了一个SurfaceMesh类，将一个标准球体的点、线以及三角面片进行渲染可视化。\n2、程序实现 接下来介绍案例的实现过程：\n 创建一个SurfaceMesh节点:  class SurfaceMesh : public Node { public: SurfaceMesh() { // geometry \tstd::shared_ptr\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt; triSet = std::make_shared\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); triSet-\u0026gt;loadObjFile(getAssetPath() + \u0026#34;standard/standard_sphere.obj\u0026#34;); triSet-\u0026gt;update(); this-\u0026gt;stateTriangles()-\u0026gt;setDataPtr(triSet); //Point visualizer \tauto pointRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRender-\u0026gt;varBaseColor()-\u0026gt;setValue(Vec3f(1.0f, 0.0f, 0.0)); pointRender-\u0026gt;varPointSize()-\u0026gt;setValue(0.02f); this-\u0026gt;stateTriangles()-\u0026gt;connect(pointRender-\u0026gt;inPointSet()); this-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRender); //Wireframe visualizer \tauto edgeRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); edgeRender-\u0026gt;varBaseColor()-\u0026gt;setValue(Vec3f(0, 1, 0)); edgeRender-\u0026gt;varRenderMode()-\u0026gt;getDataPtr()-\u0026gt;setCurrentKey(GLWireframeVisualModule::LINE); edgeRender-\u0026gt;varLineWidth()-\u0026gt;setValue(3.f); this-\u0026gt;stateTriangles()-\u0026gt;connect(edgeRender-\u0026gt;inEdgeSet()); this-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(edgeRender); //Triangle visualizer \tauto triRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); triRender-\u0026gt;varBaseColor()-\u0026gt;setValue(Vec3f(0, 0, 1)); this-\u0026gt;stateTriangles()-\u0026gt;connect(triRender-\u0026gt;inTriangleSet()); this-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(triRender); }; public: DEF_INSTANCE_STATE(TriangleSet\u0026lt;DataType3f\u0026gt;, Triangles, \u0026#34;Topology\u0026#34;); };  创建场景:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; createScene() { std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto mesh = scn-\u0026gt;addNode(std::make_shared\u0026lt;SurfaceMesh\u0026gt;()); return scn; } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_realtimecloth_v1/",
	"title": "实时连衣裙仿真",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_RealTimeCloth_v1\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。人体模型穿上连衣裙后的仿真情况。\n2、程序实现  创建场景图：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, 0, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); auto object = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticTriangularMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); object-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;cloth_shell/ball/ball_model.obj\u0026#34;); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;VolumeBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-1.5, 0, -1.5), Vec3f(1.5, 3, 1.5), 0.005f, true); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;cloth_shell/ball/ball_small_size_15.sdf\u0026#34;, false);  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15, 500, 0.0005, 1e-3)); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/cloth_size_17_alt/cloth_40k_6.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems()); cloth-\u0026gt;setGrad_ite_eps(0); cloth-\u0026gt;setMaxIteNumber(10);  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(0.4, 0.4, 1.0)); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRenderer-\u0026gt;setColor(Color(0.4, 0.4, 0.4)); surfaceRenderer-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); object-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); object-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); cloth-\u0026gt;setVisible(true); object-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_gui_plugin/",
	"title": "插件",
	"tags": [],
	"description": "",
	"content": "1、插件添加 案例位置：examples/Cuda/QtGUI/Qt_GUI_Plugin\n功能介绍：由于PeriDyno引擎实现了刚体、流体、弹性体、高度场及渲染等众多功能。后续开发过程中可能还会扩展到更多的功能。为了避免工具栏中图标过于冗余。PeriDyno引擎使用插件的形式在工具栏上创建与项目相关的图标按钮。\n案例说明： 该案例主要展示如何添加插件到工具栏。下图添加了与建模相关的工具栏。\n2、程序实现 接下来介绍案例的实现过程：\n 在main函数中添加插件语句:  PaticleSystem::initStaticPlugin(); //添加粒子系统相关的工具栏 \tModeling::initStaticPlugin();//添加建模相关的工具栏 \tInteraction::initStaticPlugin();//添加交互相关的工具栏  "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_realtimecloth_v2/",
	"title": "实时衬衫模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_RealTimeCloth_v2\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。人体模型穿上衣服后的仿真情况。\n2、程序实现  创建场景图：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, -0.1, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); auto object = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticTriangularMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); object-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;cloth_shell/v2/woman_model_smaller.obj\u0026#34;); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;VolumeBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-1.5,0,-1.5), Vec3f(1.5,3,1.5), 0.005f, true); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;cloth_shell/v2/woman_v2.sdf\u0026#34;, false);  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;()); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/v2/cloth_v2.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems()); cloth-\u0026gt;setMaxIteNumber(10); cloth-\u0026gt;setContactMaxIte(20);  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(0.08,0.021,0.0)); surfaceRendererCloth-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRenderer-\u0026gt;setColor(Color(1,1,0.6)); surfaceRenderer-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); object-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); object-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); cloth-\u0026gt;setVisible(true); object-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/tutorials/",
	"title": "常规案例",
	"tags": [],
	"description": "",
	"content": "该部分为PeriDyno引擎的教学案例。案例中包含基本的布料、弹性体、流体、交互、渲染、性能等仿真计算示例。读者可从以下简单的案例入手学习PeriDyno引擎，熟悉引擎的开发模式，节点式仿真建模思想，节点属性编辑等工作。\n  创建GLFW窗口: 介绍如何创建一个Glfw窗口；\n  实例渲染: 介绍仿真实例渲染；\n  鼠标交互: 介绍鼠标交互功能；\n  渲染管线中的鼠标交互: 介绍鼠标在渲染管线中的应用；\n  线框渲染: 介绍模型网格的不同线框渲染模式；\n  拓扑结构: 介绍模型渲染模块；\n  "
},
{
	"uri": "https://peridyno.github.io/zh/reference/",
	"title": "相关资料",
	"tags": [],
	"description": "External resources related to physical-based simulations.
",
	"content": "扩展阅读： 如何实现C++反射\n参考文献（待补充）\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_marchingcubes/",
	"title": "等值面提取",
	"tags": [],
	"description": "",
	"content": "1、等值面提取 案例位置：examples/Cuda/QtGUI/Qt_MarchingCubes\n功能介绍：该案例包含两个示例，介绍 MarchingCubes 类与 VolumeClipper 类的使用。示例1展示了等值面提取 （Marching Cubes，MC） 算法功能。等值面提取算法 （MC） 一种用三维标量场表示的等值面来创建多面体表面。示例2展示了有向距离场 （Signed Distance Field，SDF） 的切平面的数值可视化功能。在模型有向距离场 （Signed Distance Field，SDF） 空间中切一个平面，将有向距离场 （Signed Distance Field，SDF） 的数值投影到平面上，并根据数值大小将赋予平面不同的颜色。\n案例说明： 示例1展示了等值面提取算法 （Marching Cubes，MC） 算法功能。通过修改 MarchingCubes 节点的 Grid Spacing 属性，可以动态的增加或减少模型的面片数。示例2展示有向距离场 （Signed Distance Field，SDF） 可视化功能。通过修改 VolumeClipper 节点的 Rotation 和 Translation 属性，可以对模型不同位置的切面进行有向距离场 （Signed Distance Field，SDF） 可视化。\n  等值面提取算法 （Marching Cubes，MC）:   有向距离场 （Signed Distance Field，SDF） 可视化：   2、程序实现 接下来介绍案例的实现过程：\n示例1：\n 创建场景图及边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建MarchingCubes类:  auto marchingCubes = scn-\u0026gt;addNode(std::make_shared\u0026lt;MarchingCubes\u0026lt;DataType3f\u0026gt;\u0026gt;());  创建渲染节点:  auto isoSurfaceVisualizer = scn-\u0026gt;addNode(std::make_shared\u0026lt;GLSurfaceVisualNode\u0026lt;DataType3f\u0026gt;\u0026gt;()); marchingCubes-\u0026gt;outTriangleSet()-\u0026gt;connect(isoSurfaceVisualizer-\u0026gt;inTriangleSet()); 示例2：\n 创建场景图及边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建VolumeClipper类:  auto clipper = scn-\u0026gt;addNode(std::make_shared\u0026lt;VolumeClipper\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMin()-\u0026gt;setValue(-0.5); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(0.5); clipper-\u0026gt;stateField()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); clipper-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); auto surfaceVisualizer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceVisualizer-\u0026gt;varColorMode()-\u0026gt;getDataPtr()-\u0026gt;setCurrentKey(1); colorMapper-\u0026gt;outColor()-\u0026gt;connect(surfaceVisualizer-\u0026gt;inColor()); clipper-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceVisualizer-\u0026gt;inTriangleSet()); clipper-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceVisualizer); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_rotatecylinder/",
	"title": "布料旋转模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_RotateCylinder\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。一个圆柱形的布料，旋转两端出现的褶皱效果。\n2、程序实现  创建场景图：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, -1, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); scn-\u0026gt;setGravity(Vec3f(0)); auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15, 120, 0.001, 0.0005)); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/cylinder400.obj\u0026#34;);  创建CodimensionalPD节点，用于模拟布料：  cloth-\u0026gt;setMaxIteNumber(10); cloth-\u0026gt;setGrad_ite_eps(0); auto custom = std::make_shared\u0026lt;ManualControl\u0026lt;DataType3f\u0026gt;\u0026gt;(); cloth-\u0026gt;statePosition()-\u0026gt;connect(custom-\u0026gt;inPosition()); cloth-\u0026gt;stateVelocity()-\u0026gt;connect(custom-\u0026gt;inVelocity()); cloth-\u0026gt;stateFrameNumber()-\u0026gt;connect(custom-\u0026gt;inFrameNumber()); cloth-\u0026gt;stateAttribute()-\u0026gt;connect(custom-\u0026gt;inAttribute()); cloth-\u0026gt;animationPipeline()-\u0026gt;pushModule(custom);  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(1, 1, 1)); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); cloth-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/contributing/",
	"title": "关于我们",
	"tags": [],
	"description": "See the list of contributors.
",
	"content": "PeriDyno现有框架及核心算法主要贡献主要来自北京大学图形与交互技术实验室、中科院软件所人机交互技术与智能信息处理实验室、中科院软件所计算机科学国家重点实验室、中科院自动化所模式识别国家重点实验室、湖南大学汽车车身先进设计制造国家重点实验室、迈曦软件等研发团队。\n已开源 主体框架：何小伟、常悦、郭煜中、叶子萌、任丽欣、徐力有\n渲染引擎及云端框架：石剑、罗旭锟、何小伟\n光滑粒子动力学：何小伟、刘树森、夏提\n近场动力学：何小伟、郭德闻\n刚体及多体动力学：常悦、叶子萌\n基于高度场的洋流模拟：何浩、何小伟\n文档维护：何浩、常悦、石剑、刘树森、郭煜中、何小伟、冯宇轩\n即将开源 工业CAE软件集成开发与应用：蔡勇、蔡元添、王宇杰、赵博伟光、王强\n超弹性模拟：郭德闻、卢子璇、何小伟\n欧拉流体及实体建模：任丽欣\n多物理场耦合：常悦、缪冉\n最后也欢迎更多开发者一起贡献更多仿真、渲染及交互相关的算法，如有兴趣可联系xiaowei(AT)iscas.ac.cn或者直接与研发团队成员联系！！！\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/contributing/docs/",
	"title": "如何完善文档",
	"tags": [],
	"description": "See the list of contributors.
",
	"content": "1、安装Hugo 你需要下一个较新的extended版本 (推荐0.53以上) 的 Hugo。 确保下载的是extended版的hugo,千万不要下载relese版的Hugo,因为它不支持 SCSS.\n有关全面的 Hugo开发文档，请参阅 gohugo.io。\n查看是否已经安装hugo ,或查看hugo安装的版本，请运行以下命令：\nhugo version\r2、不同平台的安装   windows平台\n（1）下载 hugo extended 版\n点击 hugo下载 下载。记得下载extended 版。例如，64位的windows系统可以下载hugo_extended_0.75.1_Windows-64bit.zip.\n（2）配置环境变量\n将hugo.exe加入windows系统环境变量，记得路径中不要有空格，否则出现一些奇奇怪怪的错误。例如，路径D:\\Hugo\\bin是正确的。D:\\Program Files (x86)\\Hugo\\bin就不正确。\n  Linux平台 不要使用 sudo apt-get install hugo来安装hugo, 因为这样不会安装hugo extended 版。\n如果您已经安装了hugo，可以通过以下指令查看您安装的版本:\nhugo version\r如果您安装的是 v0.52 或更早的版本。那您需要更新hugo：\n  下载Hugo\n  找到Hugo extended版\n  下载(例如：hugo_extended_0.5X_Linux-64bit.tar.gz).\n  创建一个文件夹:\nmkdir hugo\r   加压下载的hugo压缩包。\n  进入该文件夹:\ncd hugo\r   安装hugo:\nsudo install hugo /usr/bin      macOS平台\n使用 Brew安装hugo。\n  3、安装 Node.js 和 npm 如果您已经安装了Node.js和npm, 通过以下指令可以查看当前的版本：\nnode -v\rnpm -v\r点击 下载 Node.js并安装。\n4、安装 PostCSS 安装了最新Node.js后，通过命令行可以安装 PostCSS:\nnpm install postcss --save-dev\rnpm install -D --save autoprefixer\rnpm install -D --save postcss-cli\r5、克隆 Peridyno-docs 网站代码   使用git 克隆网站源码:\ngit clone https://github.com/peridyno/peri-docs.git\r   进入文件夹:\ncd peri-docs\r   运行完整:\nhugo server\r   在浏览器中输入 http://localhost:1313/ 就能访问peridyno本地网站。通过 Ctrl + c 来关闭。\n在windows的cmd中，进入当前文件夹，输入hugo server启动本地服务器。\n6、Pull requests指令 最后，您可以在我们的 github 存储库中发出“Pull requests”指令。 感谢您对 Peridyno 开源项目的贡献！\n7、发布Peridyno网站   生成public文件夹\n cd peridyno-doc\rhugo\r   推送项目文件（如果有权限的话）\n cd public git init\rgit add -A\rgit commit -am \u0026quot;init\u0026quot;\rgit remote add origin https://github.com/peridyno/peri-docs.github.io\rgit push -f origin master\r   修改域名（如果有权限的话）\n 在 peridynoTeam.github.io 项目设置（https://github.com/peridyno/peri-docs.github.io/settings）中自定义域中添加“www.peridyno.com”。\r等待几分钟，您可以在 `www.peridyno.com` 上看到 Peridyno 网站。\r   如果您觉得我们这个项目有意义，那就加入我们吧!!!\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_mouseinteractioningraphicspipeline/",
	"title": "鼠标交互",
	"tags": [],
	"description": "",
	"content": "1、鼠标交互 案例位置：examples/Cuda/QtGUI/Qt_MouseInteractionInGraphicsPipeline\n功能介绍：主要用于测试在Qt框架下鼠标交互功能。该案例展示了 CustomMouseInteraction 类的的基本使用。该功能主要用于响应鼠标事件，包括鼠标移动、点击和释放。当鼠标发出不同指令时，程序会调用不同的接口，便于用户和仿真程序的交互。案例中展示了当鼠标在仿真界面移动、点击时，程序会打印出相应的状态、位置坐标等信息。\n案例说明：如下图所示，当鼠标在仿真界面移动，点击模型，选择多个模型时，后台程序会打印出相应的信息。\n2、程序实现 接下来介绍案例的实现过程：\n 创建Instances实例:  class Instances : public Node { public: Instances() { Transform3f tm; CArray\u0026lt;Transform3f\u0026gt; hTransform; for (uint i = 0; i \u0026lt; 5; i++) { tm.translation() = Vec3f(0.4 * i, 0, 0); tm.scale() = Vec3f(1.0 + 0.1 * i, 1.0 - 0.1 * i, 1.0); tm.rotation() = Quat\u0026lt;float\u0026gt;(i * (-0.2), Vec3f(1, 0, 0)).toMatrix3x3(); hTransform.pushBack(tm); } this-\u0026gt;stateTransforms()-\u0026gt;allocate()-\u0026gt;assign(hTransform); std::shared_ptr\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt; triSet = std::make_shared\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); triSet-\u0026gt;loadObjFile(getAssetPath() + \u0026#34;armadillo/armadillo.obj\u0026#34;); this-\u0026gt;stateTopology()-\u0026gt;setDataPtr(triSet); hTransform.clear(); }; DEF_ARRAY_STATE(Transform3f, Transforms, DeviceType::GPU, \u0026#34;Instance transform\u0026#34;); DEF_INSTANCE_STATE(TopologyModule, Topology, \u0026#34;Topology\u0026#34;); };  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建Instances实例:  auto instanceNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;Instances\u0026gt;());  创建鼠标交互事件:  //Create a CustomMouseIteraction object to handle the mouse event, \t//Press/release the mouse button to show the information \tauto mouseInterator = std::make_shared\u0026lt;CustomMouseInteraction\u0026gt;(); mouseInterator-\u0026gt;setUpdateAlways(true); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(mouseInterator-\u0026gt;inTopology()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mouseInterator);  创建渲染节点:  auto instanceRender = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); instanceRender-\u0026gt;setColor(Vec3f(0, 1, 0)); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(instanceRender-\u0026gt;inTriangleSet()); instanceNode-\u0026gt;stateTransforms()-\u0026gt;connect(instanceRender-\u0026gt;inInstanceTransform()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(instanceRender); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/cpd_shootingcloth/",
	"title": "布料小游戏",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/CPD_ShootingCloth\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。一个刚体模型，给定一定的初速度，向右撞击布料，用于测试布料仿真的稳定性。\n2、程序实现  创建场景图：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, -1, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); scn-\u0026gt;setGravity(Vec3f(0)); auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15, 120, 0.001, 0.0005)); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/cylinder400.obj\u0026#34;);  创建CodimensionalPD节点，用于模拟布料：  cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/shootingCloth.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems()); auto custom = std::make_shared\u0026lt;ManualControl\u0026lt;DataType3f\u0026gt;\u0026gt;(); cloth-\u0026gt;statePosition()-\u0026gt;connect(custom-\u0026gt;inPosition()); cloth-\u0026gt;stateVelocity()-\u0026gt;connect(custom-\u0026gt;inVelocity()); cloth-\u0026gt;stateFrameNumber()-\u0026gt;connect(custom-\u0026gt;inFrameNumber()); cloth-\u0026gt;stateAttribute()-\u0026gt;connect(custom-\u0026gt;inAttribute()); cloth-\u0026gt;animationPipeline()-\u0026gt;pushModule(custom);  创建渲染节点：  auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(1,1,1)); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); cloth-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_pickers/",
	"title": "拾取功能",
	"tags": [],
	"description": "",
	"content": "1、拾取功能 案例位置：examples/Cuda/QtGUI/Qt_Pickers\n功能介绍：通过鼠标交互拾取场景中的图元：\n  PickerNode： 对三角形面片\\四边形面片、边、顶点的拾取, 支持输入TriangleSet\\QuadSet；\n  EdgePickerNode: 对边、顶点的拾取, 支持输入EdgeSet、TriangleSet\\QuadSet；\n  PointPickerNode：对顶点的拾取, 支持输入PointSet、EdgeSet、TriangleSet\\QuadSet。\n    节点属性：\n  PickingElementType：拾取图元种类：点、线、三角面片或三者全部；\n  PickingType：鼠标交互方式：单击、拖拽、两者同时启用；\n  MultiSelectionType：多选时的交并策略：或运算（快捷键shift）、抑或运算（快捷键ctrl）、差集运算；\n  ToggleQuad：四边形面片拾取开关（在输入是QuadSet时启用）；\n  ToggleFlood：扩散拾取开关：根据FloodAngle大小扩散拾取周围的面；\n  ToggleVisibleFilter：不可见面过滤开关；\n  FloodAngle：扩散拾取时周围面角度阈值；\n  InteractionRadius：在点拾取和线拾取时，鼠标射线的误差范围；\n  TriQuadIndex,EdgeIndex,PointIndex: 分别是三角/四边形面片、边拾取、点拾取拾取的结果序列；\n  其他参数主要控制拾取和未拾取部分的渲染效果。\n    案例介绍：\n  在用户需要拾取图元时，通过鼠标单击或拖拽的方式进行拾取;\n  需要多选时，按住快捷键ctrl或shift来进行或运算或抑或运算的多选拾取;\n  需要扩散拾取某一面时，打开ToggleFlood开关，并将FloodAngle调到适宜位置;\n  需要对不可见面过滤时，打开ToggleVisibleFilter开关;\n  可以根据节点参数进行拾取功能调整选择。\n  2、程序实现 接下来介绍案例的实现过程：\n 创建场景图及边界：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  对三角形面片\\四边形面片、边、顶点的拾取功能：  auto pickerNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;PickerNode\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto cube1 = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); cube1-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.0f, 0.0f, 0.0f)); cube1-\u0026gt;setVisible(false); cube1-\u0026gt;varSegments()-\u0026gt;setValue(Vec3i((uint)6, (uint)6, (uint)6)); cube1-\u0026gt;stateQuadSet()-\u0026gt;connect(pickerNode-\u0026gt;inTopology()); cube1-\u0026gt;stateQuadSet()-\u0026gt;promoteOuput();  对边、顶点的拾取功能：  auto pointPickerNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;PointPickerNode\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto cube2 = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); cube2-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(-1.25f, 0.0f, 1.25f)); cube2-\u0026gt;setVisible(false); cube2-\u0026gt;varSegments()-\u0026gt;setValue(Vec3i((uint)6, (uint)6, (uint)6)); auto cubeSampler = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeSampler\u0026lt;DataType3f\u0026gt;\u0026gt;()); cube2-\u0026gt;outCube()-\u0026gt;connect(cubeSampler-\u0026gt;inCube()); cubeSampler-\u0026gt;statePointSet()-\u0026gt;connect(pointPickerNode-\u0026gt;inTopology()); cubeSampler-\u0026gt;statePointSet()-\u0026gt;promoteOuput();  对顶点的拾取功能:  auto edgePickerNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;EdgePickerNode\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto cube3 = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); cube3-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(1.25f, 0.0f, -1.25f)); cube3-\u0026gt;setVisible(false); cube3-\u0026gt;varSegments()-\u0026gt;setValue(Vec3i((uint)6, (uint)6, (uint)6)); cube3-\u0026gt;stateQuadSet()-\u0026gt;connect(edgePickerNode-\u0026gt;inTopology()); cube3-\u0026gt;stateQuadSet()-\u0026gt;promoteOuput(); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/gl_clothwithcollision/",
	"title": "布料碰撞模拟",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/GL_ClothWithCollision\n功能介绍：案例中展示了 CodimensionalPD 类的的基本使用。\n案例说明：该案例主要用于模拟布料。布料在重力作用下，从空中掉落到静态球体，并形成褶皱的过程。\n2、程序实现  创建场景图、边界以及静态球杆模型：  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); scn-\u0026gt;setLowerBound(Vec3f(-1.5, 0, -1.5)); scn-\u0026gt;setUpperBound(Vec3f(1.5, 3, 1.5)); auto object = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticTriangularMesh\u0026lt;DataType3f\u0026gt;\u0026gt;()); object-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026#34;cloth_shell/model_ball.obj\u0026#34;); auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;VolumeBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(-1.5,0,-1.5), Vec3f(1.5,3,1.5), 0.005f, true); //boundary-\u0026gt;loadShpere(Vec3f(0.5, 0.6f, 0.5), 0.15f, 0.005f, false, true); \tboundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;cloth_shell/model_sdf.sdf\u0026#34;);  创建CodimensionalPD节点，用于模拟布料：  auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;CodimensionalPD\u0026lt;DataType3f\u0026gt;\u0026gt;(0.15f,2e1f,0.0f)); cloth-\u0026gt;loadSurface(getAssetPath() + \u0026#34;cloth_shell/mesh_120.obj\u0026#34;); cloth-\u0026gt;connect(boundary-\u0026gt;importTriangularSystems()); cloth-\u0026gt;setDt(0.001f); cloth-\u0026gt;setGrad_ite_eps(1e-4); cloth-\u0026gt;setMaxIteNumber(10); cloth-\u0026gt;setAccelerated(true); auto surfaceRendererCloth = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRendererCloth-\u0026gt;setColor(Color(0.4,0.4,1.0));  创建渲染节点：  auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); surfaceRenderer-\u0026gt;setColor(Color(0.4,0.4,0.4)); surfaceRenderer-\u0026gt;varUseVertexNormal()-\u0026gt;setValue(true); cloth-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRendererCloth-\u0026gt;inTriangleSet()); object-\u0026gt;stateTriangleSet()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRendererCloth); object-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); cloth-\u0026gt;setVisible(true); object-\u0026gt;setVisible(true); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_resetnode/",
	"title": "重置节点",
	"tags": [],
	"description": "",
	"content": "1、重置节点 案例位置：examples/Cuda/QtGUI/Qt_ResetNode\n功能介绍：该案例主要向用户展示节点属性更新的过程。PeriDyno引擎仿真任务以场景图的形式。数据从一个节点计算完之后传向下一个节点。当更新节点的时候，只更新修改过的节点和之后的节点，而修改之前的节点不会被更新。\n案例说明： 案例中有Source、Summation（1）[第一个Summation节点]、Summation(2)[第二个Summation节点] 三个节点。初始化时，每个一个节点都有一个 Value 值，初始化都为1。节点会将上一个节点的 Value 值输入，并当前节点 Value 值相加，并将结果传到下一个节点。案例中 Source 的 Value 值为1； Summation(1) 的值为 Source 传入的 Value 值与当前 Value 值相加，为2；同理 Summation(2) 的值为上一个节点传入的值与当前节点的值的和，为3。如果将 Summation（1） 的 Value 值改为2。此时 Source、Summation（1）、Summation(2) 的值分别为1，3，4。因此，从后台打印信息可以看出，改变 Summation（1） 节点的属性值，并不会改变上一个节点 Source 的值，也就是上一个节点不会被更新。\n2、程序实现 接下来介绍案例的实现过程：\n 创建Source节点:  class Source : public Node { DECLARE_CLASS(Source); public: Source() { }; ~Source() {}; DEF_VAR(int, Value, 1, \u0026#34;Define a scalar\u0026#34;); DEF_VAR_OUT(int, Value, \u0026#34;Output value\u0026#34;); protected: void resetStates() { this-\u0026gt;outValue()-\u0026gt;setValue(this-\u0026gt;varValue()-\u0026gt;getData()); std::cout \u0026lt;\u0026lt; \u0026#34;Node \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;getName() \u0026lt;\u0026lt; \u0026#34; is reset, and the new value is \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;varValue()-\u0026gt;getData() \u0026lt;\u0026lt; std::endl; } };  创建Summation节点:  class Summation : public Node { DECLARE_CLASS(Summation); public: Summation() { }; ~Summation() {}; DEF_VAR(int, Value, 1, \u0026#34;Define a scalar\u0026#34;); DEF_VAR_IN(int, Value, \u0026#34;Input value\u0026#34;); DEF_VAR_OUT(int, Value, \u0026#34;Output value\u0026#34;); protected: void resetStates() { this-\u0026gt;outValue()-\u0026gt;setValue(this-\u0026gt;varValue()-\u0026gt;getData() + this-\u0026gt;inValue()-\u0026gt;getData()); std::cout \u0026lt;\u0026lt; \u0026#34;Node \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;getName() \u0026lt;\u0026lt; \u0026#34; is reset, and the new value is \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;outValue()-\u0026gt;getData() \u0026lt;\u0026lt; std::endl; } };  将节点连接起来:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;(); auto source1 = scn-\u0026gt;addNode(std::make_shared\u0026lt;Source\u0026gt;()); source1-\u0026gt;setName(\u0026#34;Source1\u0026#34;); auto sum1 = scn-\u0026gt;addNode(std::make_shared\u0026lt;Summation\u0026gt;()); sum1-\u0026gt;setName(\u0026#34;Sum1\u0026#34;); auto sum2 = scn-\u0026gt;addNode(std::make_shared\u0026lt;Summation\u0026gt;()); sum2-\u0026gt;setName(\u0026#34;Sum2\u0026#34;); source1-\u0026gt;outValue()-\u0026gt;connect(sum1-\u0026gt;inValue()); sum1-\u0026gt;outValue()-\u0026gt;connect(sum2-\u0026gt;inValue()); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/codimensionalpd/qt_clothstudio/",
	"title": "布料插件创建",
	"tags": [],
	"description": "",
	"content": "1、案例介绍 案例位置：examples/Cuda/CodimensionalPD/Qt_ClothStudio\n功能介绍：案例中展示了布料插件的创建。\n案例说明：该案例主要用于演示，如何创建布料模拟插件。\n2、程序实现  创建布料插件：  int main() { Modeling::initStaticPlugin(); Peridynamics::initStaticPlugin(); QtApp app; app.initialize(1024, 768); app.mainLoop(); return 0; } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_selectnode/",
	"title": "三维模型变换",
	"tags": [],
	"description": "",
	"content": "1、三维模型变换 案例位置：examples/Cuda/QtGUI/Qt_SelectNode\n功能介绍：该案例主要向用户展示PeriDyno引擎中，三维模型的变换，包括平移变换，缩放变换和旋转变换。\n案例说明： 案例中展示了两个三维模型，选择选项卡上的Translate、Scale、Rotate按钮可以通过鼠标直接在视图上对模型进行基本的变换。\n 平移变换：  缩放变换：  旋转变换：   2、程序实现 接下来介绍案例的实现过程：\n 创建球体模型:  //Create a sphere auto sphere0 = scn-\u0026gt;addNode(std::make_shared\u0026lt;SphereModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); sphere0-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(-0.5f, 0.1f, 0.0f)); sphere0-\u0026gt;varRadius()-\u0026gt;setValue(0.2f); //Create a sphere auto sphere1 = scn-\u0026gt;addNode(std::make_shared\u0026lt;SphereModel\u0026lt;DataType3f\u0026gt;\u0026gt;()); sphere1-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.5f, 0.1f, 0.0f)); sphere1-\u0026gt;varRadius()-\u0026gt;setValue(0.2f); 球体模型继承于ParametricModel类。ParametricModel类封装了这三种操作：\nDEF_VAR(Coord, Location, 0, \u0026#34;Node location\u0026#34;); DEF_VAR(Coord, Rotation, 0, \u0026#34;Node rotation\u0026#34;); DEF_VAR(Coord, Scale, Coord(1), \u0026#34;Node scale\u0026#34;); "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_showchinese/",
	"title": "中文展示",
	"tags": [],
	"description": "",
	"content": "1、中文展示 案例位置：examples/Cuda/QtGUI/Qt_ShowChinese\n功能介绍：在Node节点中默认属性使用的是英文字符。当用户如果需要使用中文字符进行显示时，需要重写相关的方法。如果是节点属性想使用中文字符，通过调用setObjectName函数即可实现。\n案例说明： 案例中主要展示节点和节点属性中文字符显示功能。\n2、程序实现 接下来介绍案例的实现过程：\n 设置中文节点及属性:  ChineseNode() { this-\u0026gt;varScalar()-\u0026gt;setObjectName(\u0026#34;标量\u0026#34;); this-\u0026gt;varVector()-\u0026gt;setObjectName(\u0026#34;矢量\u0026#34;); this-\u0026gt;stateTimeStep()-\u0026gt;setObjectName(\u0026#34;时间步长\u0026#34;); this-\u0026gt;stateElapsedTime()-\u0026gt;setObjectName(\u0026#34;时刻\u0026#34;); this-\u0026gt;stateFrameNumber()-\u0026gt;setObjectName(\u0026#34;当前帧\u0026#34;); }; ~ChineseNode() {}; std::string caption() override { return \u0026#34;测试中文\u0026#34;; } std::string description() override { return \u0026#34;这是一个中文节点\u0026#34;; } std::string getNodeType() override { return \u0026#34;中文节点\u0026#34;; } DEF_VAR(float, Scalar, 1.0f, \u0026#34;Define a scalar\u0026#34;); DEF_VAR(Vec3f, Vector, 0.0f, \u0026#34;Define a vector\u0026#34;); }; "
},
{
	"uri": "https://peridyno.github.io/zh/examples/qt/qt_viewtest/",
	"title": "变化视角",
	"tags": [],
	"description": "",
	"content": "1、变化视角 案例位置：examples/Cuda/QtGUI/Qt_ViewTest\n功能介绍：PeriDyno支持多视口仿真。每一个视口有一个渲染引擎窗口和移动相机。不同视口的渲染引擎和相机相互不影响。通过调用视口的相机setUnitScale的函数，来改变视口大小。\n案例说明： 该案例主要测试视口相机视角变化。\n2、程序实现 接下来介绍案例的实现过程：\n 创建场景图及边界:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建刚体节点以及渲染节点:  auto instanceNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;Instances\u0026gt;()); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); //surfaceRenderer-\u0026gt;setColor(Vec3f(0, 1, 0)); \t//instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); \t//instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer);  auto rigid = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0, 0, 0); BoxInfo box; box.center = 0.5f * Vec3f(0, 0.4, 0); box.halfLength = Vec3f(1.0, 1.0, 1.0); rigid-\u0026gt;addBox(box, rigidBody); scn-\u0026gt;setLowerBound(box.center - box.halfLength); scn-\u0026gt;setUpperBound(box.center + box.halfLength); auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); scn-\u0026gt;addNode(rigid);  在main函数中调用视口相机，对视角进行修改：  GlfwApp app; app.initialize(1024, 768); app.setSceneGraph(scn); //Set the distance unit for the camera, the fault unit is meter \tapp.renderWindow()-\u0026gt;getCamera()-\u0026gt;setUnitScale(3.0f); app.mainLoop(); "
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/",
	"title": "粒子系统",
	"tags": [],
	"description": "",
	"content": "PeriDyno中的粒子系统主要用于模拟流体材料。该系统中，流体材料会被离散为粒子。通过计算每个粒子在Navior Stokes 方程作用下的运动，即可实现流体的模拟。现阶段PeriDyno的粒子系统中包含有以下几部分模块：基于SPH的投影法求解器、人工粘性求解器和表面张力求解器，以及PBF（Position Based Fluid）求解器等。以下是粒子系统相关基础理论以及求解器的介绍。\n1. 基础理论 流体的Navior Stokes方程的具体形式如下：\n$$ \\begin{aligned} \u0026amp;\\rho\\frac{\\mathrm{D} \\mathbf{v} }{\\mathrm{D} t} = - \\nabla p + \\nabla\\cdot \\mu (\\nabla\\mathbf{V}+\\nabla\\mathbf{V}^T)+\\mathbf{F} \\end{aligned} $$ （公式1）\n其中,$\\rho$、$\\mathbf{v}$、$p$、$\\mu$、$\\mathbf{f}$ 分别为流体的密度场、速度场、压强场、粘性系数以及流体所受到的体积力。该方程的本质为的动量守恒定律，其等式右端各项的物理含义分别为流体不可压缩性引起的压强作用、流体的粘性引起的剪切力作用，以及流体所受到的重力、离心力等体积力的作用。\n除NS方程外，大多数流体在运动过程中还需要满足不可压缩性性条件，即：\n$$ \\nabla \\cdot \\mathbf{V} = \\frac{1}{\\rho}\\frac{\\mathrm{d} \\rho}{\\mathrm{d} t} = 0 $$\n（公式2）\n当流体某位置的不可压缩性条件存在被破坏的趋势时，相应位置上会产生一定的压强以抵抗不可压缩性的破坏。\n2. 流体模拟的基本方法 虽然理论上联立Navior Stokes 方程（公式一）和不可压缩性条件（公式二）求解出流体的速度场，即可实现流体运动的模拟。然而直接求解这两个方程是很困难的。为了简化上述量微分方程求解的难度，我们需要采用以下两种技术手段：\n   粒子离散化。使用携带有质量、压强等物理信息的粒子离散流体连续的物理场和微分算子，进而将上述连续形式的微分方程转化为线性方程组。   算子分裂法。将Navior Stokes方程拆分成三个较小的微分方程，以简化原微分方程求解的难度。\n   在使用粒子离散化与算子分裂法后，原Navior Stokes方程就被转化为如下三组方程组：\n   只有体积力项的速度微分方程。 流体粒子在体积力作用下速度的变化。 $$ \\frac{\\mathbf{v}_i^{n+\\frac{1}{3}} - \\mathbf{v}_i^{old} }{\\delta t} = \\mathbf{F}\n$$\n  只有粘性项的微分方程（流体的粘性）。 不可压缩性作用下的流体速度场变化。 $$ \\frac{\\mathbf{v}_i^{n+\\frac{2}{3}} - \\mathbf{v}_i^{n+\\frac{1}{3} }}{\\delta t} = \\nabla_i\\cdot \\mu (\\nabla\\mathbf{V}+\\nabla\\mathbf{V}^T) $$\n  只有压强项的微分方程（不可压缩性）。 不可压缩性作用下的流体速度场变化。 $$ \\frac{\\mathbf{v}_i^{new} - \\mathbf{v}_i^{n+\\frac{2}{3}} }{\\delta t} = - \\frac{1}{\\rho_i} \\nabla_i p $$\n   上式中的$\\delta t$为仿真时间步长，$i$为某粒子的编号。其中压强场可以通过流体速度散度误差$\\nabla_i\\cdot\\mathbf{v}$或密度误差$\\rho_i-\\rho_0$来获得（$\\rho_0$为流体的静止密度）。\n该系统中包含有以下几种基础方法，即：SPH(Smoothed Particle Hydrodynamics)、PBF（Position Based Fluid）法、投影法（Projection Method）等。\n3. SPH（Smoothed Particle Hydrodynamics）离散化方法简介 SPH法是最常被使用的一类粒子法。该方法中任意位置 $\\mathbf{x}$ 的物理量都可以通过其邻域粒子（邻近粒子）$j$ 插值计算得到，即： $$ A(\\mathbf{x})={\\sum_{j,\\left |\\mathbf{x} -\\mathbf{x}_j \\right | \u0026lt;h}A_j *W(\\left |\\mathbf{x} -\\mathbf{x}_j \\right |,h)} $$ （公式3） 其中$h$为平滑半径（SPH支持域半径），$j$为与点$\\mathbf{x}$距离小于$h$的粒子编号，$W(r,h)$为高斯函数或具有类似特性样条函数。如果相对于$h$的粒子间距足够小，则由上述方程重建的物理场$A(\\mathbf{x})$是较为平滑的。\n基于公式3可以实现密度等物理场以及微分算子的离散化。略去推导过程几种常用的微分算子离散化形式为：\n4. 粒子系统的核心求解器 基于算子分裂策略，原Navior Stokes方程的求解过程被划分为了三个独立的求解步骤，其中最重要的求解步骤是不可压缩性求解。不可压缩性是指流体运动中始终保持密度不变的特性，该特性直接地影响了流体的运动。目前PeriDyno中不可压缩性的实现方法有两种，分别为“基于位置约束的方法”和“投影法”。这两部分的算法介绍见4.2.2节和4.2.3节。\n除不可压缩性计算之外，粘性求解也是流体模拟的重要步骤。PeriDyno中包含有基于非物理的人工粘性求解器，该求解器可以显著提高低流体的稳定性，也能够模拟大粘性流体运动。这部分的介绍见4.2.3节。\n此外，为了更准确地模拟小尺度的不可压缩流体运动，也要考虑流体的表面张力作用。这一部分的介绍请参考4.2.4节。\n参引文献 [1] Bridson R. Fluid simulation for computer graphics[M]. AK Peters/CRC Press, 2015. [2] Koschier D, Bender J, Solenthaler B, et al. Smoothed particle hydrodynamics techniques for the physics based simulation of fluids and solids[J]. arXiv preprint arXiv:2009.06944, 2020. [3] Monaghan J J. Smoothed particle hydrodynamics[J]. Annual review of astronomy and astrophysics, 1992, 30: 543-574.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/rigidbodydynamics/",
	"title": "刚体动力学",
	"tags": [],
	"description": "To be continued...
",
	"content": "刚体是在运动过程中，形状和大小不变，而且内部各点的相对位置不发生改变的物体。绝对刚体实际上是不存在的，只是一种理想模型，因为任何物体在受力作用后，都或多或少会产生变形。如果变形的程度相对于物体本身几何尺寸来说极为微小，在研究物体运动时变形就可以忽略不计。\n1、刚体的三种类型 系统中刚体一共有三种类别，分别是：\n（1）动态刚体（dynamic）\n 正质量 每帧都更新自己的位置  （2）Kinematic刚体\n 零个质量 -由用户设置  （3）静态的刚体（static）\n 零质量 不能移动，但能发生碰撞  2、刚体仿真计算过程 刚体仿真计算过程主要可分为以下几个步骤：\n（1）加载模型和场景\n（2）根据用户的需求添加约束和碰撞\n（3）计算刚体的加速度\n（4）更新刚体的速度和位置信息\n（5）重复迭代（3）和（4），直到程序结束\n接下来对刚体程序的计算过程进行解释（具体代码参考RigidBody/RigidBodySystem.cu和RigidBody/IterativeConstraintSolver.cu）： 在刚体动力学计算过程中，首先处理刚体的碰撞和约束： enforceConstraints()//约束 handleCollision()//碰撞\n在处理完刚体约束和碰撞之后，我们先将刚体与地面碰撞的点对信息和刚体与刚体间碰撞的点对信息累加起来。所有的碰撞点对信息记录在allContacts变量中，将碰撞点的总数信息保存到Contacts变量中。\n接下来判断刚体是否设置了摩擦力约束。如果没有设置摩擦力约束，刚体是非穿透类型，则只有法线1个约束。如果设置了摩擦力，那么刚体的切平面还有两个约束。因此碰撞点对需要额外开辟2倍法线的空间，即约束的数量是碰撞点对的3倍。\ntemplate \u0026lt;typename ContactPair\u0026gt; __global__ void SetupFrictionConstraints( DArray\u0026lt;ContactPair\u0026gt; nbq, int contact_size) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= contact_size) return; Coord3D n = nbq[pId].normal1; n /= n.norm(); Coord3D n1, n2; if (abs(n[1]) \u0026gt; EPSILON || abs(n[2]) \u0026gt; EPSILON) { n1 = Coord3D(0, n[2], -n[1]); n1 /= n1.norm(); n2 = n1.cross(n); n2 /= n2.norm(); } else if (abs(n[0]) \u0026gt; EPSILON) { n1 = Coord3D(n[2], 0, -n[0]); n1 /= n1.norm(); n2 = n1.cross(n); n2 /= n2.norm(); } nbq[pId * 2 + contact_size].bodyId1 = nbq[pId].bodyId1; nbq[pId * 2 + contact_size].bodyId2 = nbq[pId].bodyId2; nbq[pId * 2 + contact_size] = nbq[pId]; nbq[pId * 2 + contact_size].contactType = ContactType::CT_FRICTION; nbq[pId * 2 + contact_size].normal1 = n1; nbq[pId * 2 + 1 + contact_size].bodyId1 = nbq[pId].bodyId1; nbq[pId * 2 + 1 + contact_size].bodyId2 = nbq[pId].bodyId2; nbq[pId * 2 + 1 + contact_size] = nbq[pId]; nbq[pId * 2 + 1 + contact_size].contactType = ContactType::CT_FRICTION; nbq[pId * 2 + 1 + contact_size].normal1 = n2; } 将所有碰撞点对的信息保存到Contacts变量中。\n接下来开始进行刚体动力学计算。在解释代码之前，先补充说明整个动力学计算的过程。假设速度从${{\\rm{V}}^1}$变化到${{\\rm{V}}^2}$的时间步长为$\\Delta t $，则此时的加速度可表示为 ： $$ \\dot{V}\\approx \\frac{V^2-V^1}{\\bigtriangleup t} $$\n根据牛顿第二定律可得到： $$ m\\dot V = {F_c} + {F_{ext}} $$\n其中${F_c}$表示约束力、${F_{ext}}$表示额外力。约束力可表示为${F_c} = {J^T}\\lambda$。根据上述两式有： $$ M({V^2} - {V^1}) = \\Delta t({J^T}\\lambda + {F_{ext}}) $$\n因此需要求解$[\\lambda ]$进而求出$[{V^2}]$。将问题转换为求解$[\\lambda ]$的线性方程$J{\\rm{B}}\\lambda {\\rm{ = }}\\eta $。同时根据$B{\\rm{ = }}{{\\rm{M}}^{ - 1}}{J^T}$，则有：\n$$ \\eta = \\frac{1}{{\\Delta t}}\\xi - J(\\frac{1}{{\\Delta t}}{V^1} + {M^{ - 1}}{F_{ext}}) $$\n如果约束是一致的，我们可以求解出$\\lambda $，进而计算出${V^2}$，从而可以推导出刚体的速度和位移：\n\\begin{array}{l} {x^{\\rm{2}}}{\\rm{ = }}{x^1} + \\Delta t{v^2}\\\\\n{q^2} = {q^1} = \\frac{{\\Delta t}}{2}{q^1}{w^2} \\end{array}\n接下来开始对程序进行解释，首先计算雅可比矩阵（Jacobian）J，以及B矩阵。\ntemplate \u0026lt;typename Coord, typename Matrix, typename ContactPair\u0026gt; __global__ void CalculateJacobians( DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Coord\u0026gt; B, DArray\u0026lt;Coord\u0026gt; pos, DArray\u0026lt;Matrix\u0026gt; inertia, DArray\u0026lt;Real\u0026gt; mass, DArray\u0026lt;ContactPair\u0026gt; nbc) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= J.size() / 4) return; int idx1 = nbc[pId].bodyId1; int idx2 = nbc[pId].bodyId2; //printf(\u0026#34;%d %d\\n\u0026#34;, idx1, idx2);  if (nbc[pId].contactType == ContactType::CT_NONPENETRATION) // contact, collision \t{ Coord p1 = nbc[pId].pos1; Coord p2 = nbc[pId].pos2; Coord n = nbc[pId].normal1; Coord r1 = p1 - pos[idx1]; Coord r2 = p2 - pos[idx2]; J[4 * pId] = n; J[4 * pId + 1] = (r1.cross(n)); J[4 * pId + 2] = -n; J[4 * pId + 3] = -(r2.cross(n)); B[4 * pId] = n / mass[idx1]; B[4 * pId + 1] = inertia[idx1].inverse() * (r1.cross(n)); B[4 * pId + 2] = -n / mass[idx2]; B[4 * pId + 3] = inertia[idx2].inverse() * (-r2.cross(n)); } else if (nbc[pId].contactType == ContactType::CT_BOUDNARY) // boundary \t{ Coord p1 = nbc[pId].pos1; //\tprintf(\u0026#34;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ %d %.3lf %.3lf %.3lf\\n\u0026#34;, idx1, p1[0], p1[1], p1[2]);  Coord n = nbc[pId].normal1; Coord r1 = p1 - pos[idx1]; J[4 * pId] = n; J[4 * pId + 1] = (r1.cross(n)); J[4 * pId + 2] = Coord(0); J[4 * pId + 3] = Coord(0); B[4 * pId] = n / mass[idx1]; B[4 * pId + 1] = inertia[idx1].inverse() * (r1.cross(n)); B[4 * pId + 2] = Coord(0); B[4 * pId + 3] = Coord(0); } else if (nbc[pId].contactType == ContactType::CT_FRICTION) // friction \t{ Coord p1 = nbc[pId].pos1; //printf(\u0026#34;~~~~~~~ %.3lf %.3lf %.3lf\\n\u0026#34;, p1[0], p1[1], p1[2]);  Coord p2 = Coord(0); if (idx2 != -1) p2 = nbc[pId].pos2; Coord n = nbc[pId].normal1; Coord r1 = p1 - pos[idx1]; Coord r2 = Coord(0); if (idx2 != -1) r2 = p2 - pos[idx2]; J[4 * pId] = n; J[4 * pId + 1] = (r1.cross(n)); if (idx2 != -1) { J[4 * pId + 2] = -n; J[4 * pId + 3] = -(r2.cross(n)); } else { J[4 * pId + 2] = Coord(0); J[4 * pId + 3] = Coord(0); } B[4 * pId] = n / mass[idx1]; B[4 * pId + 1] = inertia[idx1].inverse() * (r1.cross(n)); if (idx2 != -1) { B[4 * pId + 2] = -n / mass[idx2]; B[4 * pId + 3] = inertia[idx2].inverse() * (-r2.cross(n)); } else { B[4 * pId + 2] = Coord(0); B[4 * pId + 3] = Coord(0); } } } 其中B矩阵为$B=M^{-1}J^T$。 接下来计算D矩阵，D=JB。\ntemplate \u0026lt;typename Coord\u0026gt; __global__ void CalculateDiagonals( DArray\u0026lt;Real\u0026gt; D, DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Coord\u0026gt; B) { int tId = threadIdx.x + (blockIdx.x * blockDim.x); if (tId \u0026gt;= J.size() / 4) return; Real d = Real(0); d += J[4 * tId].dot(B[4 * tId]); d += J[4 * tId + 1].dot(B[4 * tId + 1]); d += J[4 * tId + 2].dot(B[4 * tId + 2]); d += J[4 * tId + 3].dot(B[4 * tId + 3]); D[tId] = d; } 接下来计算$\\eta $矩阵$\\eta = \\frac{1}{{\\Delta t}}\\xi - J(\\frac{1}{{\\Delta t}}{V^1} + {M^{ - 1}}{F_{ext}})$：\ntemplate \u0026lt;typename Coord, typename ContactPair\u0026gt; __global__ void CalculateEta( DArray\u0026lt;Real\u0026gt; eta, DArray\u0026lt;Coord\u0026gt; velocity, DArray\u0026lt;Coord\u0026gt; angular_velocity, DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Real\u0026gt; mass, DArray\u0026lt;ContactPair\u0026gt; nbq, Real dt) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= J.size() / 4) return; int idx1 = nbq[pId].bodyId1; int idx2 = nbq[pId].bodyId2; //printf(\u0026#34;from ita %d\\n\u0026#34;, pId); \tReal ita_i = Real(0); if (true) // test dist constraint \t{ ita_i -= J[4 * pId].dot(velocity[idx1]); ita_i -= J[4 * pId + 1].dot(angular_velocity[idx1]); if (idx2 != -1) { ita_i -= J[4 * pId + 2].dot(velocity[idx2]); ita_i -= J[4 * pId + 3].dot(angular_velocity[idx2]); } } eta[pId] = ita_i / dt; if (nbq[pId].contactType == ContactType::CT_NONPENETRATION || nbq[pId].contactType == ContactType::CT_BOUDNARY) { eta[pId] += min(nbq[pId].interpenetration, nbq[pId].interpenetration) / dt / dt / 15.0f; } } 接下来开始进行迭代求解 。迭代算法采用Jacobi迭代:\ntemplate \u0026lt;typename Coord, typename ContactPair\u0026gt; __global__ void TakeOneJacobiIteration( DArray\u0026lt;Real\u0026gt; lambda, DArray\u0026lt;Coord\u0026gt; accel, DArray\u0026lt;Real\u0026gt; d, DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Coord\u0026gt; B, DArray\u0026lt;Real\u0026gt; eta, DArray\u0026lt;Real\u0026gt; mass, DArray\u0026lt;ContactPair\u0026gt; nbq, DArray\u0026lt;Real\u0026gt; stepInv) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= J.size() / 4) return; int idx1 = nbq[pId].bodyId1; int idx2 = nbq[pId].bodyId2; Real eta_i = eta[pId]; { eta_i -= J[4 * pId].dot(accel[idx1 * 2]); eta_i -= J[4 * pId + 1].dot(accel[idx1 * 2 + 1]); if (idx2 != -1) { eta_i -= J[4 * pId + 2].dot(accel[idx2 * 2]); eta_i -= J[4 * pId + 3].dot(accel[idx2 * 2 + 1]); } } if (d[pId] \u0026gt; EPSILON) { Real delta_lambda = eta_i / d[pId]; Real stepInverse = stepInv[idx1]; if (idx2 != -1) stepInverse += stepInv[idx2]; delta_lambda *= (1.0f / stepInverse); //printf(\u0026#34;delta_lambda = %.3lf\\n\u0026#34;, delta_lambda);  if (nbq[pId].contactType == ContactType::CT_NONPENETRATION || nbq[pId].contactType == ContactType::CT_BOUDNARY) //\tPROJECTION!!!! \t{ Real lambda_new = lambda[pId] + delta_lambda; if (lambda_new \u0026lt; 0) lambda_new = 0; Real mass_i = mass[idx1]; if (idx2 != -1) mass_i += mass[idx2]; if (lambda_new \u0026gt; 25 * (mass_i / 0.1)) lambda_new = 25 * (mass_i / 0.1); delta_lambda = lambda_new - lambda[pId]; } if (nbq[pId].contactType == ContactType::CT_FRICTION) //\tPROJECTION!!!! \t{ Real lambda_new = lambda[pId] + delta_lambda; Real mass_i = mass[idx1]; if (idx2 != -1) mass_i += mass[idx2]; //if ((lambda_new) \u0026gt; 5 * (mass_i)) lambda_new = 5 * (mass_i); \t//if ((lambda_new) \u0026lt; -5 * (mass_i)) lambda_new = -5 * (mass_i); \tdelta_lambda = lambda_new - lambda[pId]; } lambda[pId] += delta_lambda; //printf(\u0026#34;inside iteration: %d %d %.5lf %.5lf\\n\u0026#34;, idx1, idx2, nbq[pId].s4, delta_lambda);  atomicAdd(\u0026amp;accel[idx1 * 2][0], B[4 * pId][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2][1], B[4 * pId][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2][2], B[4 * pId][2] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2 + 1][0], B[4 * pId + 1][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2 + 1][1], B[4 * pId + 1][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2 + 1][2], B[4 * pId + 1][2] * delta_lambda); if (idx2 != -1) { atomicAdd(\u0026amp;accel[idx2 * 2][0], B[4 * pId + 2][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2][1], B[4 * pId + 2][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2][2], B[4 * pId + 2][2] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2 + 1][0], B[4 * pId + 3][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2 + 1][1], B[4 * pId + 3][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2 + 1][2], B[4 * pId + 3][2] * delta_lambda); } } } 更新刚体的速度和位置信息。\ntemplate \u0026lt;typename Coord\u0026gt; __global__ void RB_UpdateVelocity( DArray\u0026lt;Coord\u0026gt; velocity, DArray\u0026lt;Coord\u0026gt; angular_velocity, DArray\u0026lt;Coord\u0026gt; accel, Real dt) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= accel.size() / 2) return; velocity[pId] += accel[2 * pId] * dt; velocity[pId] += Coord(0, -9.8f, 0) * dt; angular_velocity[pId] += accel[2 * pId + 1] * dt; } template \u0026lt;typename Coord, typename Matrix, typename Quat\u0026gt; __global__ void RB_UpdateGesture( DArray\u0026lt;Coord\u0026gt; pos, DArray\u0026lt;Quat\u0026gt; rotQuat, DArray\u0026lt;Matrix\u0026gt; rotMat, DArray\u0026lt;Matrix\u0026gt; inertia, DArray\u0026lt;Coord\u0026gt; velocity, DArray\u0026lt;Coord\u0026gt; angular_velocity, DArray\u0026lt;Matrix\u0026gt; inertia_init, Real dt) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= pos.size()) return; pos[pId] += velocity[pId] * dt; rotQuat[pId] = rotQuat[pId].normalize(); rotMat[pId] = rotQuat[pId].toMatrix3x3(); rotQuat[pId] += dt * 0.5f * Quat(angular_velocity[pId][0], angular_velocity[pId][1], angular_velocity[pId][2], 0.0) *(rotQuat[pId]); inertia[pId] = rotMat[pId] * inertia_init[pId] * rotMat[pId].inverse(); //inertia[pId] = rotMat[pId] * rotMat[pId].inverse(); \t} "
},
{
	"uri": "https://peridyno.github.io/zh/topics/fem/",
	"title": "有限元法",
	"tags": [],
	"description": "To be continued...
",
	"content": "敬请期待\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/heightfield/",
	"title": "高度场",
	"tags": [],
	"description": "把水面表示成为一个连续的平面网格
",
	"content": "1、总体介绍 高度场流体仿真分为两个部分，基于浅水方程（SWE）的浅水波模拟和基于快速傅里叶变换（FFT）的海浪模拟。浅水方程（SWE）是描述浅水流动的数学模型，同时也是水力学中的一个重要的数学模型。浅水方程建立在具有物理意义的物理量守恒基础上，也可以称为双曲守恒型方程组。基于快速傅里叶变换（FFT）的海浪模拟的主要思想就是按照Phillips波普得到海面的高度场（也就是傅里叶变换的频域），然后将其逆傅里叶变换（IFFT）得到海面（也就是时域）。\n2、浅水波仿真 目前实时系统大规模水体仿真广泛使用Gerstner模型，其核心思想是通过对计算格点的位置进行周期性的偏移来达到水波翻滚的效果。尽管Gerstner Wave适用于建模大范围的水体，然而其在展现精细尺度水波上能力有限，且无法反应水体与刚体的交互。鉴于此，本项目使用浅水方程来实现精细尺度的水波模拟：\n\\begin{array}{l} \\frac{{\\partial h}}{{\\partial t}} + \\frac{\\partial }{{\\partial x}}\\left( {hu} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {hv} \\right) = 0 \\\\\n\\frac{\\partial }{{\\partial t}}\\left( {hu} \\right) + \\frac{\\partial }{{\\partial x}}\\left( {\\frac{{h{u^2}}}{2}} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {huv} \\right) = - gh\\frac{{\\partial s}}{{\\partial x}} \\\\\n\\frac{\\partial }{{\\partial t}}\\left( {hv} \\right) + \\frac{\\partial }{{\\partial x}}\\left( {huv} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {\\frac{{h{v^2}}}{2}} \\right) = - gh\\frac{{\\partial s}}{{\\partial y}} \\end{array}\n其中u、v分别表示洋流水平速度的两个分量，h表示洋流的深度，s表示海面垂直坐标，g表示重力加速度。求解过程，首先基于高度场对仿真区域进行如图所示的离散。\n然后，通过求解波动方程计算每个时刻的高度场的位置。最终，将基于浅水方程（SWE）得到的高度场叠加到大区域水体上从而实现更加逼得水体仿真。\n首先初始化水面的初始高度。对于水面边界的高度进行处理，每次计算后：\na) x=0点的粒子高度值等于x=1点的粒子高度值； b) x= width - 1点的粒子高度值等于x= width - 2点的粒子高度值；\rc) y=0点的粒子高度值等于y=1点的粒子高度值；\rd) y= height- 1点的粒子高度值等于y= height - 2点的粒子高度值。\rsrc/Dynamics/HeightField/CapillaryWave.cu 中实现如下：\n__global__ void C_ImposeBC(Vec4f* grid_next, Vec4f* grid, int width, int height, int pitch) { int x = threadIdx.x + blockIdx.x * blockDim.x; int y = threadIdx.y + blockIdx.y * blockDim.y; if (x \u0026lt; width \u0026amp;\u0026amp; y \u0026lt; height) { if (x == 0) { Vec4f a = grid[(y)*pitch + 1]; grid_next[(y)*pitch + x] = a; } else if (x == width - 1) { Vec4f a = grid[(y)*pitch + width - 2]; grid_next[(y)*pitch + x] = a; } else if (y == 0) { Vec4f a = grid[(1) * pitch + x]; grid_next[(y)*pitch + x] = a; } else if (y == height - 1) { Vec4f a = grid[(height - 2) * pitch + x]; grid_next[(y)*pitch + x] = a; } else { Vec4f a = grid[(y)*pitch + x]; grid_next[(y)*pitch + x] = a; } } } 对每个时间内的高度场进行迭代：\n__global__ void C_OneWaveStep(Vec4f* grid_next, Vec4f* grid, int width, int height, float timestep, int pitch) 最后计算u、v洋流水平速度的两个分量，h洋流的深度，s海面垂直坐标。\n__global__ void C_InitHeightField( Vec4f* height, Vec4f* grid, int patchSize, float horizon, float realSize) { int i = threadIdx.x + blockIdx.x * blockDim.x; int j = threadIdx.y + blockIdx.y * blockDim.y; if (i \u0026lt; patchSize \u0026amp;\u0026amp; j \u0026lt; patchSize) { int gridx = i + 1; int gridy = j + 1; Vec4f gp = grid[gridx + patchSize * gridy]; height[i + j * patchSize].x = gp.x - horizon; float d = sqrtf((i - patchSize / 2) * (i - patchSize / 2) + (j - patchSize / 2) * (j - patchSize / 2)); float q = d / (0.49f * patchSize); float weight = q \u0026lt; 1.0f ? 1.0f - q * q : 0.0f; height[i + j * patchSize].y = 1.3f * realSize * sinf(3.0f * weight * height[i + j * patchSize].x * 0.5f * M_PI); } } 3、基于快速傅里叶变换（FFT）的海浪模拟 FFT模型是一种统计模型。不同于Gerstner模型采用多个正弦余弦函数去拟合，FFT模型采用傅里叶变换的方式。傅里叶变换的核心就是用sin(nx)和cos(nx)去模拟任意的周期函数。在FFT模型中，用时间和水平高度的随机函数h(x,t)来表示浪的高度。该方法仿真度高，易于建模，其计算公式如下[1]：\n$$h(X,t) = \\sum\\limits_K^{} {\\tilde h(K,t){{\\mathop{\\rm e}\\nolimits} ^{(iK{\\rm{X}})}}} $$\n式中，$X{\\rm{ = }}(x,z)$水平位置；$t$代表时间；$K$是一个二维向量；$\\tilde h(k,t)$表示海浪表面结构。\n构建FFT模型的高度场之后，接下来创建随机的高度场。引入高斯随机函数，有：\n$${\\tilde h_0}(K) = \\frac{1}{{\\sqrt 2 }}({\\xi _r} + i{\\xi _i})\\sqrt {{P_h}(K)} $$\n其中，${\\xi _r}$和${\\xi _i}$是相互独立的高斯随机数（均值为 0，方差为 1）。此时在$t$时刻波的振幅为：\n$$\\tilde h(K,t) = \\tilde h(K){e^{i\\omega (K)t}} + \\tilde h_0^*( - K){e^{ - i\\omega ({\\rm{K}})t}}$$ 其中，$\\omega (k)$是波$K$的角频率，可以根据${\\omega ^2}(k) = g|K|$计算得到；*号表示复数的共轭运算。根据FFT模型，海浪的高度最终一定为实数，所以一定满足$\\tilde h(-K)= \\tilde h_0^*(K)$。\ntemplate\u0026lt;typename TDataType\u0026gt; void OceanPatch\u0026lt;TDataType\u0026gt;::generateH0(Vec2f* h0) { for (unsigned int y = 0; y \u0026lt;= mResolution; y++) { for (unsigned int x = 0; x \u0026lt;= mResolution; x++) { float kx = (-( int )mResolution / 2.0f + x) * (2.0f * CUDART_PI_F / m_realPatchSize); float ky = (-( int )mResolution / 2.0f + y) * (2.0f * CUDART_PI_F / m_realPatchSize); float P = sqrtf(phillips(kx, ky, windDir, m_windSpeed, A, dirDepend)); if (kx == 0.0f \u0026amp;\u0026amp; ky == 0.0f) { P = 0.0f; } float Er = gauss(); float Ei = gauss(); float h0_re = Er * P * CUDART_SQRT_HALF_F; float h0_im = Ei * P * CUDART_SQRT_HALF_F; int i = y * mSpectrumWidth + x; h0[i].x = h0_re; h0[i].y = h0_im; } } } 初始化相位和振幅。频谱可以采用Phillips频谱。Phillips频谱适用于海面网格并行化计算。它是一种真实度较高的频谱，多用于在有风的影响下。Phillips频谱的定义如下：\n$${P_h}(K) = A\\frac{{\\exp ( - 1/{{(kL)}^2})}}{{{k^4}}}|\\hat K\\hat \\omega {|^2}$$\n其中，$g$表示重力加速度；$k = |K| = 2\\pi / \\lambda $；$\\lambda $表示波长；$A$表示一个常系数；$L = {V^2}/g$表示风速在$V$的情况下产生的最大波浪；$\\hat \\omega $表示风向；$|\\hat K\\hat \\omega {|^2}$表示消除了垂直于风向运动的波。\n// generate wave heightfield at time t based on initial heightfield and dispersion relationship __global__ void generateSpectrumKernel(Vec2f* h0, Vec2f* ht, unsigned int in_width, unsigned int out_width, unsigned int out_height, float t, float patchSize) { unsigned int x = blockIdx.x * blockDim.x + threadIdx.x; unsigned int y = blockIdx.y * blockDim.y + threadIdx.y; unsigned int in_index = y * in_width + x; unsigned int in_mindex = (out_height - y) * in_width + (out_width - x); // mirrored  unsigned int out_index = y * out_width + x; // calculate wave vector  Vec2f k; k.x = (-( int )out_width / 2.0f + x) * (2.0f * CUDART_PI_F / patchSize); k.y = (-( int )out_width / 2.0f + y) * (2.0f * CUDART_PI_F / patchSize); // calculate dispersion w(k)  float k_len = sqrtf(k.x * k.x + k.y * k.y); float w = sqrtf(9.81f * k_len); if ((x \u0026lt; out_width) \u0026amp;\u0026amp; (y \u0026lt; out_height)) { Vec2f h0_k = h0[in_index]; Vec2f h0_mk = h0[in_mindex]; // output frequency-space complex values  ht[out_index] = complex_add(complex_mult(h0_k, complex_exp(w * t)), complex_mult(conjugate(h0_mk), complex_exp(-w * t))); //ht[out_index] = h0_k;  } } 在使用FFT模型在流体仿真的过程中，需要根据每个点的斜率之计算表面的法向量。在实际的计算过程中，一般采用邻近网格点有限差分来计算斜率值。但为了减少小波波长的斜率误差，可使用反向FFT变换的方式进行求解：\n$$\\nabla h(X,t) = \\sum\\limits_K^{} {iK\\tilde h(K,t)\\exp (iKX)} $$\ncufftExecC2C(fftPlan, (float2*)m_ht, (float2*)m_ht, CUFFT_INVERSE); cufftExecC2C(fftPlan, (float2*)m_Dxt, (float2*)m_Dxt, CUFFT_INVERSE); cufftExecC2C(fftPlan, (float2*)m_Dzt, (float2*)m_Dzt, CUFFT_INVERSE); 此外，还需要一个偏置向量D(x,t)来模拟海水的浪尖，可以如下设置：\n$$D(x,t) = \\sum\\limits_k { - i\\frac{k}{{|k|}}h(k,t){e^{ikx}}} $$\n其中雅克比矩阵为： \\begin{equation} J\\left( x \\right) =\\left| \\begin{matrix} J_{xx}\u0026amp;\tJ_{xy}\\\\\nJ_{zx}\u0026amp;\tJ_{yy}\\\\\n\\end{matrix} \\right| \\end{equation}\n$$ \\begin{array}{l} J_{xx}=\\frac{\\partial x^{'}}{\\partial x}=1+\\lambda \\frac{\\partial D_x\\left( x,t \\right)}{\\partial x}\\\\\nJ_{yy}=\\frac{\\partial y^{'}}{\\partial y}=1+\\lambda \\frac{\\partial D_y\\left( x,t \\right)}{\\partial y}\\\\\nJ_{yx}=\\frac{\\partial y^{'}}{\\partial x}=\\lambda \\frac{\\partial D_y\\left( x,t \\right)}{\\partial x}\\\\\nJ_{xy}=\\frac{\\partial x^{'}}{\\partial y}=\\lambda \\frac{\\partial D_x\\left( x,t \\right)}{\\partial y}\\\\\n\\end{array} $$\n参考文献 [1] Tessendorf J. Simulating ocean water[J]. Simulating nature: realistic and interactive techniques. SIGGRAPH, 2001, 1(2): 5.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/postprocessing/",
	"title": "离线渲染与后处理",
	"tags": [],
	"description": "PeriDyno仿真案例的后处理专题介绍
",
	"content": "后处理文档概述  本部分文档将具体从：流程概述、数据导入、数据的查看与调整、数据可视化、渲染、合成6个方面对PeriDyno的后处理进行讲解。  一、流程概述   PeriDyno在数据的种类上主要分为网格、粒子、曲线三种，涉及abc、obj、txt等格式。在后处理过程中，主要选用Houdini作为数据整合、可视化及渲染的主要平台。\n  基于Houdini的特性，能够很好的进行数据整合、数据查看、数据调整、数据可视化、数据渲染等工作，并能够基于非破坏性的流程进行快速的迭代，使前处理与后处理工作在一定程度上得以并行推进，提高效率。 此外，Maya、Blender等全流程三维软件也是PeriDyno数据后处理工作可选择的平台，其也能够完成材质、灯光及渲染工作，但在兼容性及数据查看方面稍显逊色，本文档不做过多推荐与介绍。\n  最终上述三维软件所渲染出的序列帧可以使用Adobe After Effects、The Foundry Nuke、Adobe Premiere Pro等后期合成及剪辑软件完成合成与输出。\n  二、数据导入 PeriDyno输出的数据主要分为网格、粒子、曲线三种类型，涉及abc、obj、fbx、txt等格式。\n  网格数据以obj、obj序列的格式导入。\n  粒子数据abc、abc序列的格式导入。\n  曲线数据abc、abc序列的格式导入。\n  骨骼网格体数据以fbx格式 进行导入。\n  txt格式的粒子数据能够通过MeshlessSkinning工具转换为网格数据并输出为obj序列从而进行导入。\n  导入方法： 1.使用Houdini菜单栏File-Import进行文件的导入。\n 通过Houdini菜单栏File-import进行文件的导入，并根据需求选择相应的格式即可。在通常情况下可以使用Geometry选项进行导入。其会为我们在Object层级下创建一个Geo节点，并根据所选的格式适配合适的节点进行文件的导入（*注意：此方法不适用于骨骼网格体，骨骼网格体请详见本节的fbx character import部分）。  2.创建Geo节点，进入节点内，创建File、Alembic或fbx character import等节点进行进行导入。\n（1）通过File节点导入\n 在节点工作区Object层级按下Tab键，并搜索Geo，创建Geometry节点，并使用Enter键进入。    在Geometry层级下创建File节点。   File节点的Geometry File通道可以指定文件路径，其支持以下格式（不建议用此节点导入abc格式文件，其对abc没有单独的优化，运行效率较低，建议使用Alembic节点进行abc文件的导入）。 *.geo, *.bgeo, *.hclassic, *.bhclassic, *.geo.gz, *.geogz, *.bgeo.gz, *.bgeogz, *.hclassic.gz, *.hclassicgz, *.bhclassic.gz, *.bhclassicgz, *.geo.sc, *.geosc, *.bgeo.sc, *.bgeosc, *.hclassic.sc, *.hclassicsc, *.bhclassic.sc, *.bhclassicsc, *.json, *.bjson, *.json.gz, *.jsongz, *.bjson.gz, *.bjsongz, *.json.sc, *.jsonsc, *.bjson.sc, *.bjsonsc, *.poly, *.bpoly, *.d, *.rib, *.vrmesh, *.vrscene, *.flt, *.hgt, *.r16, *.r32, *.img, *.tif, *.tiff, *.png, *.jpg, *.exr, *.pic, *.GoZ, *.vdb, *.usd, *.usda, *.usdc, *.bhclassic.lzma, *.bgeo.lzma, *.hclassic.bz2, *.bgeo.bz2, *.pc, *.pmap, *.geo.lzma, *.off, *.iges, *.igs, *.ply, *.obj, *.pdb, *.hclassic.lzma, *.lw, *.lwo, *.geo.bz2, *.bstl, *.eps, *.ai, *.stl, *.dxf, *.bhclassic.bz2, *.abc, *.fbx\n  针对“name+序号.文件类型”的序列文件，如以name_001.obj为第一帧的文件序列可以通过将命名修改为name_$F.obj进行动画序列的导入。\n  （2）通过Alembic节点导入\n  在节点工作区Geometry层级下创建Alembic节点。在Alembic节点的File name通道指定文件路径。\n  针对“name+序号.文件类型”的序列文件，如以name_001.abc为第一帧的文件序列可以通过将命名修改为name_$F.abc进行动画序列的导入。\n  （3）通过fbx character import节点导入\n  本文档推荐使用Houdini 18.5及其后续版本进行骨骼网格体的导入，其Kine FX模块的角色功能能够大幅简化工作流程。\n  在节点工作区Geometry层级下创建FBX Character Import节点，并通过FBX File通道进行骨骼网格体文件导入。\n  三、数据的读取与查看 1.通过Transform节点调整模型变换\n 检查数据的变换及空间比例，并通过Transform节点进行空间比例与位置的调整。  2.通过Convert/Unpack节点进行数据读取\n  对于导入的打包数据应使用Convert或Unpack转化或解包，从而读取到文件中的数据。此处推荐使用Convert进行转化，其能够指定文件类型，选择合适的模式或优化模式进行转化，如NURBS Curve、Polygon、Polygon Soup等。\n  粒子及网格数据推荐将类型选择为Polygon。曲线转换为NURBS Curve。\n  （1）Convert节点的使用\n 在Geometry层级下创建Convert节点，并在Convert to通道选择合适的类型即可。粒子及网格数据需要将类型选择为Polygon或Polygon Soup。曲线转换为NURBS Curve。  （2）Unpack节点的使用\n  在Geometry层级下创建Unpack并与数据节点连接即可。\n  转化或解包后可以在节点上按下鼠标中间查看文件数据概况。\n  3.Geometry Spreadsheet数据查看\n 通过Geometry Spreadsheet可以查看模型、点、顶点、基元层级上的具体属性。如果Geometry Spreadsheet只显示一组数据，请检查是否进行了Convert或Unpack处理。  四、数据可视化  本节分为“粒子可视化”、“曲线可视化”、“网格可视化”三个部分。  （一）粒子可视化\n1.粒子着色\n①使用AttributeVop节点进行粒子着色：\n  在Geometry层级下创建Attribute Vop节点，并双击进入VEX Builder层级。\n  创建Length节点并连接到v，将速度转换为浮点值。\n  创建Fit节点，将val与length的输出相连，并在节点上右键-Vex/Vop Option-Create input parameters将参数暴露至当前的Attribute Vop节点中方便调整。\n  创建Ramp Parameter节点，并将input连接至fit的输出端，将ramp连接至Geometry Vop Output的Cd端实现顶点色的输出。\n  回到Attribute Vop并选择，此时能够看到Fit节点和Ramp Parameter节点所暴露出来的参数。根据粒子的实际运动速度调整Fit输入速度的最大值。将Fit的输出值调整为0-1，用以Ramp的输入（Ramp默认拾取0-1的float值）。最后调整Ramp进行调色，完成粒子着色。\n  ②使用AttributeWrangle节点进行粒子着色：\n  在Geometry层级下创建Attribute Wrangle节点。\n  将Run Over 为Points，确保其运行在点层级下。\n  在VEXpression中输入：f@speed=fit(length(@v),0,ch(\u0026ldquo;in_max\u0026rdquo;),0,1);@Cd=chramp(\u0026ldquo;ramp\u0026rdquo;,@speed);（1.创建一个浮点属性@speed。使用length函数转换为浮点值，并使用fit函数将其输出值设定为0-1，为输入值的最大值设定为“in_max”。2.使用chramp函数基于上述创建的@speed属性进行颜色映射，并将其指定到顶点色。）\n  \tf@speed=fit(length(@v),0,ch(\u0026quot;in_max\u0026quot;),0,1);\r@Cd=chramp(\u0026quot;ramp\u0026quot;,@speed)\r  选择VEXpression右侧（如图中黄色框1中的按钮）Creates spare parameters for each unique call of ch()按钮，根据ch函数创建参数。\n  根据粒子的实际运动速度的最大值调整in_max参数，通过Ramp调色，完成粒子着色。\n  2.粒子缩放\n使用AttributeWrangle节点设置粒子大小\n  Houdni中粒子大小属性为浮点属性@pscale。\n  创建一个AttributeWrangle节点，确保其Run Over为Points层级，并在VEXpression输入@pscale=0.2;将粒子大小设置为0.2或一个合适的值，该属性可以直接被渲染器读取，并默认渲染为一个相应大小的sphere。\n  \t@pscale=0.2;\r3.粒子网格化\n使用ParticleFluidSurface进行粒子网格化\n  粒子转网格主要通过Geometry层级下的Particle Fluid Surface节点完成。调整Paticle Separation以控制生成网格的距离阈值。\n  如需要对网格进行速度着色则应关闭Particle Fluid Surface的Adaptivity，保证网格布线均匀（@Cd是顶点色属性，需要足够数量且均匀的顶点分布以确保着色效果）。\n  在Transfer Attributes通道下增加Cd属性。\n  最后可以添加File Cache节点并在Geometry File通道指定一个路径进行网格文件的缓存。\n  使用MeshlessSkinning工具进行粒子网格化\n txt格式的粒子数据可以使用MeshlessSkinning工具进行网格化。具体使用方法如图所示：  （二）曲线可视化\n1.曲线网格化\n  曲线转网格主要通过Geometry层级下的Sweep节点完成。该节点需要一条目标曲线和一个扫描曲线进行工作。\n  首先将abc格式的曲线文件通过Alembic进行导入，而后使用convert节点将其转换为NURBS Curve类型（详情请见本文档“二、数据文件的导入”、“三、数据读取与查阅”）。\n  创建一个Circle节点作为扫描曲线，并通过Uniform Scale通道调节其缩放。\n  创建一个Sweep节点。将导入的目标曲线数据连接到输入端1，将Circle节点连接到输入端2。如需要进行贴图，可以在UVs and Attributes标签下勾选Compute UVs。\n  创建UVquickshade节点可视化检查UV。\n  （三）网格可视化\n1.UV处理流程\n 对于需要进行贴图绘制但没有UV的动画序列，可以先通过时间冻结或导出模型的方式选取其中一帧进行UV拆分，而后基于顶点序号使用AttributeCopy节点进行UV属性的拷贝。  2.UV展开\n（1）houdini UV展开\n  通过UV unwrap节点进行UV展开。\n  添加UV layout节点进行UV排布。\n  (2)其他方式的UV展开\n  您可以通过Maya、RizomUV、Zbrush、Substance Painter等软件进行手动或自动的UV展开。\n  UV展开请查阅相关软件具体说明。\n  3.使用AttributeCopy进行UV属性的拷贝\n  在Geometry层级下创建AttributeCopy节点，将原模型序列连接至输入端1，将完成UV展开的模型连接至输入端2。\n  设定Attribute Name通道为uv，完成uv属性的传递。\n  五、渲染 1.渲染概述：\n  Houdini中渲染方案较多，如Mantra、Arnold、V-Ray、Redshift以及最新的Karma等。本文档以Vray为例，对最为重点和核心的内容进行渲染指南和说明。\n  在渲染工作中主要需要完成“渲染设置”、“摄像机”、“灯光”、“材质”四部分工作。\n  本文档目前将主要以V-Ray渲染器为例进行讲解，其具有效率高、易学习的特点，能够快速上手，并适合3dsMax、Maya等平台用户进行快速迁移与查阅。此外其能够兼容到其他支持V-Ray Sence的三维平台，为后续的工作创造更大的空间。\n  2.渲染设置\n（1）渲染器指定\n  在Objects层级下创建Ropnet节点，并双击进入。详情可参见: https://docs.chaos.com/display/VRAYHOUDINI/out+Network\n  创建V-ray Renderer节点以指定渲染器，创建完成后将自动创建V-ray Ipr节点。\n  （2）V-Ray渲染器基本设置\n①Export标签\n  Export-Render Device选项卡：此部分可以选择渲染模式，如CPU/CUDA/RTX等，注意GPU渲染可能会不支持某些渲染特性。详情请参见: https://docs.chaos.com/display/VRAYHOUDINI/Set+Up+GPU+Rendering\n  Export-IPR选项卡：1.Use Denoiser开启降噪，其能够在较低的渲染采样下得到较高的渲染质量，提升渲染效率。2.Use Render Elements开启渲染元素，可根据是否需要多通道渲染酌情勾选。\n  ②Images标签\n  Images-File Path：指定渲染路径与渲染文件的格式，注意渲染器会自动识别文件名后缀的格式。如：G:/../ImageName.${AOV}.0001.png将会被渲染为.png的图像格式。\n  Render Elements：指定所需要使用的Render Elements，如：/obj/ropnet1/renderElements\n  ③Render-Sampler标签\n 将Render-Sampler标签下的Type由Progressive改为Bucket将在最终渲染时在一定程度上减少噪点。  ④Render-Global Illumination标签\n 将On选项勾选，开启全局光，产生光子反弹的效果，得到更接近真实的照明效果。注意其在得到更好的光照效果的同时大幅增加了渲染时间。可以根据项目需求决定是否开启全局光照明，开启该选项后需要注意调节Sampler标签下的采样值，以减少噪点。  （3）多通道渲染\n  如有进行后期合成的需求，则需要在Ropnet下创建Render Elements渲染元素节点，并在V-Ray Renderer节点的Image标签下的Render Elements通道指定此节点进行激活，以启用渲染通道。\n  关于分层渲染，其内容较为繁杂，详情请移步Vray帮助文档进行了解: https://docs.chaos.com/display/VRAYHOUDINI/List+of+Supported+Render+Elements\n  3.摄像机\n  在Objects层级下创建一个Camera节点，并选取一个合适的角度对对象进行拍摄，注意合理的构图能够对数据的展示和画面的美观程度进行较大的提升。\n  在View标签下调节Resolution，此分辨率为最终渲染图的分辨率。此外此标签下还有摄像机的投影模式、焦距、裁切等重要参数。您可以根据项目的需求酌情设置。\n  4.灯光\n  灯光在渲染中较为重要，合理的布光可以有效提升画面表现效果，并可能减少噪点。\n  本文档建议首先使用VrayLightDome节点创建穹顶灯，并勾选Use Texture 设置基于HDRI贴图的环境照明。\n  如需进行自定义打光，您可以在HDRI的基础照明之上创建VrayLight Rectangle节点，用面光源完成主光、补光等灯光环境的创建。详情请参见: https://docs.chaos.com/display/VRAYHOUDINI/Lights\n  4.材质\n  在Objects层级下创建一个Matnet节点并双击进入。详情请参见: https://docs.chaos.com/display/VRAYHOUDINI/mat+Network\n  创建V-ray Material Builder节点并进入。\n  创建V-Ray Material节点，该节点内容较多，您可以查阅官方网站根据图片了解和对比各参数的效果: https://docs.chaos.com/display/VRAYHOUDINI/V-Ray+Material\n  ①Diffuse标签：Diffuse控制漫反射颜色，可以在材质节点中调节颜色，或创建V-Ray User Color及V-Ray Image File节点完成颜色设置。Opacity不透明度，可以使用V-Ray Image File连入一张图像作为遮罩控制物体的透明度属性。\n  ②Bump标签：Bump Map通道可以指定一张凹凸贴图或法线贴图以模拟物体表面的凹凸细节。\n  ③Reflection标签：可以在Color通道调节反射颜色，并在Glossiness调节材质光泽度以表现不同的质感。\n  V-Ray image File节点可以读取图像文件作为贴图。\n  User Color用户颜色：该节点可以将顶点色（或您创建的其他属性），即Houdini中的Cd属性进行渲染。主要针对需要顶点色着色的粒子、网格等对象。您可以创建V-Ray UserColor节点，将Attribute设置为Cd以读取顶点色，并连接至V-ray Material的Diffuse通道。\n  六、合成  在PeriDyno中，主要使用Adobe AfterEffects进行序列帧的合成、调色，并最终输出成视频。  "
},
{
	"uri": "https://peridyno.github.io/zh/topics/proceduralmodeling/",
	"title": "程序化建模",
	"tags": [],
	"description": "PeriDyno程序化建模功能专题介绍
",
	"content": "PeriDyno程序化建模概述  本部分文档将着重介绍PeriDyno的程序化建模能力，包含基本几何体、车削模型、挤出模型、复制模型等。  一、基本几何体介绍   PeriDyno当前提供了立方体、球体、圆柱体、圆锥体四种基本几何体，均继承于ParametricModel类，且最终可以输出TriangleSet数据，以描述三角网格结构。四种基本几何体均具有位置（Location）、旋转（Rotation）、缩放（Scale）的共有属性，以便调整基本几何体变换。此外每个基本集合体又依据其特性有其独有的属性。\n  立方体Cube：具有Length及Segments属性以定义其三个轴向的边长与分段数。\n   球体Sphere：具有Radius及Theta属性以定义其半径与分段数。   圆柱体Cylinder：具有Columns、Row、End Segment、Radius、Height属性以定义其垂直分段数、水平分段数、端面分段数、半径、高度。   圆锥体Cone：具有Columns、Row、Radius、Height属性以定义其垂直分段数、水平分段数、半径、高度。  二、程序化模型的创建与编辑  在 图形界面 中的创建与编辑：  首先确保Main函数中调用了Modeling::initStaticPlugin()以构建工具架。\nModeling::initStaticPlugin();\r 创建方法1：在图形界面上方切换到Modeling标签，点击下方基本几何体按钮以创建对应节点（如图中红色框所标识的部分）。\n创建方法2：在节点工作区点击鼠标右键，搜索需要的几何体类名，点击以创建对应节点（如图中绿色框所标识的部分）。\n编辑：点击所需要修改的节点使其高亮显示，修改属性编辑面板Property Editor参数以编辑基本几何体参数。\n 在 C++ 中的创建与编辑：  本示例从Qt_GUI_Empty空场景示例为起点构建。\n1、引用所需要使用的类如立方体#include \u0026ldquo;CubeModel.h\u0026rdquo;\n2、构建场景图 std::shared_ptr \u0026lt; SceneGraph \u0026gt; scn = std::make_shared\u0026lt; SceneGraph \u0026gt;();\n3、为scn场景图添加CubeModel节点 auto Cube = scn-\u0026gt;addNode(std::make_shared\u0026lt; CubeModel\u0026lt; DataType3f \u0026gt; \u0026gt;());\n4、设置场景图window.setSceneGraph(scn);\n\t#include \u0026lt;QtApp.h\u0026gt;\r#include \u0026quot;initializeModeling.h\u0026quot;\r#include \u0026quot;initializeInteraction.h\u0026quot;\r#include \u0026quot;CubeModel.h\u0026quot;\rusing namespace dyno;\rint main()\r{\rstd::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();\rauto Cube = scn-\u0026gt;addNode(std::make_shared\u0026lt;CubeModel\u0026lt;DataType3f\u0026gt;\u0026gt;());\rModeling::initStaticPlugin();\rInteraction::initStaticPlugin();\rQtApp window;\rwindow.setSceneGraph(scn);\rwindow.createWindow(1366, 768);\rwindow.mainLoop();\rreturn 0;\r}\r构建完成后运行效果如下：\n创建基本几何体后可以通过-\u0026gt;获取变量，并使用SetValue()设置参数。\n\tCube-\u0026gt;varLength()-\u0026gt;setValue(Vec3f(0.5,0.2,0.5));\rCube-\u0026gt;varRotation()-\u0026gt;setValue(Vec3f(0,45,0));\rCube-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0,-0.1,0));\r修改完成后运行效果如下：\n三、其他程序化建模功能 1、TurningMode能够根据输入的PointSet创建车削模型。  TurningModel在图形界面中的使用：  首先点击ObjPointLoader按钮，创建ObjPoint节点，选择Obj点集文件路径，以作为TurningModel的输入。\n点击TurningModel按钮，创建TurningModel节点。将ObjPoint的PointSet输出连接到TurningModel的PointSet输入端。\n选择ObjPoint节点，点击节点右上角按钮隐藏显示。\n TurningModel在C++中的使用：  1、引用ObjPoint、TurningModel的头文件\n\t#include \u0026quot;Plugin/ObjIO/ObjPointLoader.h\u0026quot;\r#include \u0026quot;Turning.h\u0026quot;\r2、创建曲线\n\t//创建曲线\rauto Curve = scn-\u0026gt;addNode(std::make_shared\u0026lt;ObjPoint\u0026lt;DataType3f\u0026gt;\u0026gt;());\rCurve-\u0026gt;varFileName()-\u0026gt;setValue(getAssetPath() + \u0026quot;curve/curve06_subdivide.obj\u0026quot;);\r3、创建Turning模型，在场景图scn上添加TurningModel节点\n\t//创建Turning模型\rauto Turn = scn-\u0026gt;addNode(std::make_shared\u0026lt;TurningModel\u0026lt;DataType3f\u0026gt;\u0026gt;());\r4、将Curve的OutPointSet连接到TurningModel的inPointSet\n\tCurve-\u0026gt;outPointSet()-\u0026gt;connect(Turn-\u0026gt;inPointSet());\r5、修改Turning参数，将垂直分段数提高到50以使模型更加精细。\n\tTurn-\u0026gt;varColumns()-\u0026gt;setValue(50);\r构建完成后运行效果如下：\n2、合并Merge能够对输入的多个TriangleSet合并为一个TriangleSet。  Merge在图形界面中的使用：  本部分以上文构建的Turning和Cube为起点，展示Merge使用方法。以下为Merge前的场景展示。\n点击Merge创建Merge节点，将TurningModel的TriangleSet输出及Cube的QuadSet状态变量连接到Merge的输入。\n Merge在C++中的使用：  \t//创建Merge模型\rauto MergeModel = scn-\u0026gt;addNode(std::make_shared\u0026lt;Merge\u0026lt;DataType3f\u0026gt;\u0026gt;());\rCube-\u0026gt;stateQuadSet()-\u0026gt;promoteOuput()-\u0026gt;connect(MergeModel-\u0026gt;inTriangleSet01());\rTurn-\u0026gt;stateTriangleSet()-\u0026gt;promoteOuput()-\u0026gt;connect(MergeModel-\u0026gt;inTriangleSet02());\r3、 复制模型CopyModel能够根据输入的TriangleSet进行复制与递归变换。  CopyModel在图形界面中的使用：   CopyModel在C++中的使用：  \t//创建Copy模型\rauto Copy = scn-\u0026gt;addNode(std::make_shared\u0026lt;CopyModel\u0026lt;DataType3f\u0026gt;\u0026gt;());\rMergeModel-\u0026gt;stateTriangleSet()-\u0026gt;promoteOuput()-\u0026gt;connect(Copy-\u0026gt;inTriangleSetIn());\r//修改Copy属性\rCopy-\u0026gt;varTotalNumber()-\u0026gt;setValue(4);\rCopy-\u0026gt;varCopyTransform()-\u0026gt;setValue(Vec3f(1,0,0));\r"
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/pbf/",
	"title": "基于位置约束的方法",
	"tags": [],
	"description": "粒子系统-流体-PBF
",
	"content": "1. 简介 基于位置约束的方法，即PBF（Position Based Fluid）法，是一种快速、高效、非物理的不可压缩流体仿真方法。该方法通过直接对流体粒子施加恒定密度约束来更新粒子的位置与速度，进而实现不可压缩性流体运动的模拟。\n2. 方法 流体在运动过程中需要时刻保持密度恒定，即恒定密度约束。粒子$i$的恒定密度约束的具体形式为：$\\rho_i = \\rho_0$。其中$\\rho_0$为流体的静止密度，在PeriDyno中该静止密度的取值一般为$1000$；$\\rho_i$为粒子$i$的密度，可通过基于核函数的SPH法插值计算获得，即：\n$$ {\\rho_i = \\sum_{j,r_{ij}\u0026lt;h}m_j \\cdot W(r_{ij},h)} $$ (公式1)\n其中，$r_{ij}$为粒子$i$与其邻域粒子$j$的间距，即：$r_{ij} = |\\mathbf{x}_i- \\mathbf{x}_j|$。因此粒子$i$的密度可以被视为粒子$i$及其邻域粒子$j$空间坐标作为变量的函数。因此可获得以流体粒子空间位置作为变量的恒定密度约束条件，即： $$ C_i(\\mathbf{x}) = \\frac{\\rho_i(\\mathbf{x})}{\\rho_0}-1=0 $$ (公式2)\n其中，$\\mathbf{x}$为包含有粒子$i$及其邻域粒子$j$空间位置坐标的矢量。\n若流体中粒子$i$位置上的不可压缩性条件被破坏：$\\rho_i \u0026gt; \\rho_0$，也即是 $C_i(\\mathbf{x}) \u0026gt; 0$ 则需要修正粒子$i$及其邻域粒子$j$的空间位置坐标，以保持粒子$i$位置附近的不可压缩性。\n$$ C_i(\\mathbf{x}+\\triangle \\mathbf{x}) = \\frac{\\rho_i(\\mathbf{x +\\triangle \\mathbf{x}})}{\\rho_0}-1=0 $$ (公式3)\n其中$\\triangle \\mathbf{x}$为粒子$i$及其邻域粒子$j$的空间位置修正矢量。\n粒子$i$及其邻域粒子$j$的空间位置修正矢量$\\triangle\\mathbf{x}$可以通过泰勒近似和牛顿法获得。略去推导过程，$\\triangle\\mathbf{x}$的计算式为：\n$$ {\\triangle \\mathbf{x_{i}}}= {\\frac{1}{\\rho_0}}\\sum_{j,r_{ij}\u0026lt;h}(\\lambda_j+\\lambda_i)\\nabla W(r_{ij}, h)， $$ $$ \\nabla W(r, h) = \\frac{\\mathrm{d} r }{\\mathrm{d} \\mathbf{x}} \\frac{\\mathrm{d} W(r ,h)}{\\mathrm{d} r} $$ (公式4)\n其中，$W$为SPH核函数；$\\lambda$的计算式为：\n$$ \\lambda_i = - \\frac{Ci(\\mathbf{x})}{\\sum_k|\\nabla_k C_i|^2} $$ (公式5)\n计算获得粒子空间位置修正量$\\triangle \\mathbf{x}$后，即可获得满足不可压缩性条件的粒子位置，按照该位置来更修正粒子位置，然后根据粒子位置修正量来更新粒子的速度，即$\\mathbf{v}^{new}_i=\\mathbf{v}^{old}_i + \\triangle \\mathbf{x_i}/{\\delta t}$，来模拟流体质点的惯性作用，即可完成当前帧流体粒子运动的模拟计算。\n一帧中仅计算一次粒子的位置修正量$\\triangle \\mathbf{x}$并不能很好地消除密度误差，为了获得更为精确的计算结果，常需要在一帧中多次迭代计算$\\triangle \\mathbf{x}$。\n\r3. 实现 PeriDyno中，PBF求解器的源文件为：\n\u0026#34;Engine/Dynamics/Module/DensityPBD.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/DensityPBD.h\u0026#34;; PBF求解器的输入为不满足恒定密度约束的流体粒子的位置，输出为满足恒定密度约束的粒子位置，以及惯性作用下的粒子速度。 a. 包含的模块：   SummationDensity（密度计算模块）\nstd::shared_ptr\u0026lt;SummationDensity\u0026lt;TDataType\u0026gt;\u0026gt; m_summation; DensityPBD求解器使用该模块用于计算粒子的质量密度，并以此来计算恒定密度约束条件下粒子位置的修正值。\n  SpikyKernel (核函数)\nSpikyKernel\u0026lt;Real\u0026gt; m_kernel; 该模块即为SPH法的核函数$W(r_{ij},h)$。\n  b. 变量：   NeighborList (邻域粒子列表)\nDEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;\u0026#34;); 为了实现粒子各项物理量及其微分量的插值计算，计算过程需要使用到粒子的邻域列表。该邻域列表需要在每一帧计算开始时预先由邻域查找模块生成，邻域查找模块的位置为：\n\u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.h\u0026#34; \u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.cu\u0026#34;   Velocity, Position (粒子速度与位置)\nDEF_ARRAY_IN(Coord, Velocity, DeviceType::GPU, \u0026#34;Input particle velocity\u0026#34;); DEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Input particle position\u0026#34;); Velocity为粒子的速度（$\\mathbf{v}$）；Position为粒子空间位置 ($\\mathbf{x}$)。\n  内部变量\nDArray\u0026lt;Real\u0026gt; m_lamda; DArray\u0026lt;Coord\u0026gt; m_deltaPos; m_lamda 为上述公式5中的 $\\lambda$； m_deltaPos为公式4中的 $\\triangle\\mathbf{x}$；\n  c. 参数： int IterationNumber = 5; Real RestDensity = 1000.0f; Real SamplingDistance = 0.005f; Real SmoothingLength = 0.01f; 上述参数的含义分别为：\n  IterationNumber： 迭代次数（迭代次数越多，计算结果越精确，每一帧的密度误差越小）； RestDensity： 静止密度（即公式2中的$\\rho_0$）； SamplingDistance： 粒子的初始间距； SmoothingLength： SPH法中的平滑距离/支持域半径，同时也是粒子的邻域半径。   d. 函数：  K_ComputeLambdas： 该函数为公式5，用于计算 $\\lambda$。  template \u0026lt;typename Real, typename Coord\u0026gt; __global__ void K_ComputeLambdas(...)  K_ComputeDisplacement： 该函数为公式4，用于计算 $\\triangle \\mathbf{x}$。  template \u0026lt;typename Real, typename Coord\u0026gt; __global__ void K_ComputeDisplacement(...)  DP_UpdateVelocity： 该函数为用于计算惯性作用下粒子的速度，即：$\\mathbf{v}^{new}_i=\\mathbf{v}^{old}_i + \\triangle \\mathbf{x_i}/{\\delta t}$。  template \u0026lt;typename Real, typename Coord\u0026gt; __global__ void DP_UpdateVelocity(...) 参考文献 [1] Macklin M , M Müller. Position based fluids[J]. Acm Transactions on Graphics, 2013, 32(4):1-12.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/vssph/",
	"title": "投影法",
	"tags": [],
	"description": "粒子系统-流体-投影法
",
	"content": "1. 简介 投影法是通过求解流体压强泊松方程来获取压强，来消除速度散度误差或密度误差的方法。该方法相比于PBF法虽然计算效率较低，需要使用更大的邻域半径以及更多的迭代次数才能保证仿真的稳定性，但该方法具有更高精度和仿真质量。\n2. 方法 当流体被压缩时，流体个别位置会产生速度散度误差或密度误差，此时流体需要产生相应的压强来抵抗压缩，消除散度误差和密度误差以保证不可压缩性条件。而压强泊松方程则可以根据散度误差、密度误差来计算流体的压强。以下是压强泊松方程的推导过程：\n  Step 1. 忽略掉粘性作用、体积力作用的离散化后的流体Navior Stokes方程形式为： $$ \\mathbf{v}_i^{new} = \\mathbf{v}_i^{old} - \\frac{\\delta t}{\\rho_0} \\nabla_i p\n$$ （公式1）\n  Step 2. 由于$\\mathbf{v}_i^{old}$是不满足不可压缩性条件的速度场，即：$\\nabla\\mathbf{v}_i^{old}\\ne0$ ,而待求的满足不可压缩性条件的速度场其散度应为零，即：$\\nabla\\mathbf{v}_i^{new}=0$。则对公式1的等式两端同时取散度，即可得到如下的压强泊松方程。 $$ \\nabla_i \\cdot \\frac{\\delta t}{\\rho_0} \\nabla p =-\\nabla \\cdot \\mathbf{v}_i^{old} $$ (公式2)\n  Step 3. 使用粒子对压强泊松方程中的二阶微分算符（拉普拉斯算符$\\nabla\\cdot\\nabla_i$）与一阶微分算符（散度$\\nabla\\cdot$）进行离散化，将压强泊松方程转化为线性系统。\n  Step 4. 由于压强泊松方程只考虑了速度散度误差，而没有考虑密度误差，因此需要对泊松方程的等式右端项进行修正，一种推荐的方法即是： $$ \\nabla_i \\cdot \\frac{\\delta t}{\\rho_0} \\nabla p =-\\nabla \\cdot \\mathbf{v}_i^{old} + \\Lambda *\\max(\\frac{\\rho_i}{\\rho_0}-1,0) $$ (公式3)\n其中系数$\\Lambda$为常数。\n  Step 5. 带入流体的边界条件（包括气液边界条件和固液边界条件），对原压强泊松方程的系数矩阵进行修正，该泊松方程会转化为对称正定的线性系统。\n  Step 6. 使用共轭梯度法、雅克比法等迭代算法可快速求解这一离散化后的压强泊松方程，获得当前帧中各粒子的压强值。\n  Step 7. 将粒子压强带入到公式1中，修正流体粒子的速度值，获得满足不可压缩性条件的粒子速度$\\mathbf{v}_i^{new}$。\n  Step 8. 根据粒子速度$\\mathbf{v}_i^{new}$来更新粒子位置，即：$\\mathbf{x}_i^{new} = \\mathbf{x}_i^{old}+ \\mathbf{v}_i^{new}*\\delta t$\n  以上即为基于SPH投影法的实现流程。投影法中的压强二阶微分项和速度散度项离散化方法种类繁多，不同离散化方法也有不同的特性。目前PeriDyno中选用了变分框架下使用staggered粒子的微分离散化方案来构建投影法求解器，相比其它方法，该离散化方案具有更好的收敛性、稳定性，能够有效抑制SPH的零能问题和拉伸失稳问题的影响。具体的实现方法可参考文献。\n3. 实现 PeriDyno中，投影法求解器的源文件为：\n\u0026#34;Engine/Dynamics/Module/VariationalApproximateProjection.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/VariationalApproximateProjection.h\u0026#34;; 投影法求解器的输入为不满足不可压缩性条件的流体粒子位置和速度场，输出为满足不可压缩性条件、同时可消除密度偏移误差的的速度场。 a. 变量：   Attribute (粒子属性)\nDEF_ARRAY_IN(Attribute, Attribute, DeviceType::GPU, \u0026#34;\u0026#34;); 为了准确地对流体施加固壁边界条件，该投影法中的固体需要使用Ghost粒子进行采样。而为了区别固体粒子与流体粒子，则需要引入属性数组来对粒子进行标记。\n  Normal (固体Ghost粒子法向量)\nDEF_ARRAY_IN(Coord, Normal, DeviceType::GPU, \u0026#34;\u0026#34;); 为了准确地对流体施加滑移（Free-slip）或无滑移(No-slip)流固边界条件，固体Ghost粒子需要具有法向量参数。\n  NeighborList (邻域粒子列表)\nDEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;\u0026#34;); 为了实现粒子各项物理量及其微分量的插值计算，计算过程需要使用到粒子的邻域列表。该邻域列表需要在每一帧计算开始时预先由邻域查找模块生成，邻域查找模块的位置为：\n\u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.h\u0026#34; \u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.cu\u0026#34;   b. 函数：   泊松方程离散化相关函数\nVC_ComputeAlpha(...) VC_ComputeDiagonalElement(...) VC_ComputeAx(...) 以上三个函数为泊松方程（公式2）中压强二阶微分项离散化的相关函数。\nVC_ComputeDivergence(...) 该函数为泊松方程速度散度的离散化相关函数，用于计算粒子的速度散度误差。\nVC_CompensateSource(...) 该函数用于补偿压强泊松方程的源项（即：公式2泊松方程的右端项），对应于第2节“方法”中的step 3。SPH投影法如果仅仅修正速度散度误差并不能有效地保证不可压缩性条件，因为流体的密度会逐渐发生漂移，引入严重的错误。该函数能够有效地避免流体的体积丢失问题。\nVC_UpdateVelocity1rd(...) 该函数根据粒子压强来计算粒子的压强梯度，并更新流体粒子的速度（对应于第2节“方法”中的step 7 与 step 8 ），计算过程中考虑了固壁边界对于流体的作用。\n参考文献 [1] He X, Wang H, Wang G, et al. A Variational Staggered Particle Framework for Incompressible Free-Surface Flows[J]. arXiv preprint arXiv:2001.09421, 2020.\n  "
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/artificalviscosity/",
	"title": "人工粘性",
	"tags": [],
	"description": "粒子系统-流体-人工粘性
",
	"content": "1. 简介 粘性是流体的重要特性。当流体产生了形变的趋势时（速度的梯度：$\\nabla \\mathbf{v}$），流体的粘滞力就会产生并阻滞流体发生形变。在粒子系统中，粘性还有另外一项功能，即是削弱流体个别粒子过于剧烈、高频的运动，使流体粒子具有相一致的运动，进而提高仿真稳定性。\nPeriDyno中包含了一种改进与XSPH法的人工粘性求解器。虽然该粘性求解器并不是基于物理的求解器，但它能够非常稳定地够模拟大粘性流体，而且能够有效提高粘性流体的仿真稳定性，具有十分优异的计算效率。\n2. 方法 比较经典的人工粘性求解算法是XSPH法，该方法通过削弱相邻流体粒子之间的速度差值来保证粒子的运动速度保持接近，来使流体的速度场分布趋于平滑。其计算公式如下所示。\n$$ \\mathbf{v_i}^{new} = \\mathbf{v_i}^* + \\epsilon \\sum_{j, r_{ij}\u0026lt;h} \\frac{m_j}{\\rho_j} \\left (\\mathbf{v_j}^*-\\mathbf{v_i}^*\\right )W(r_{ij},h) $$\n（公式1） 然而该方法存在较为严重的问题，即控制粘性强度的稀疏$\\epsilon$的取值不能大于1，因此该方法只能用于提高低粘性流体的稳定性，而无法模拟大粘性流体。\n因此PeriDyno在原XSPH人工粘性算法基础上进行了改进，使其能够稳定模拟大粘性流体。改进后的人工粘性计算公式如下。\n$$ \\mathbf{v_i} ^{new}=\\frac{1}{b+1}\\left ( \\mathbf{v_i}^* + b\\sum_{j, r_{ij}\u0026lt;h}\\mathbf{v_i}^*W\\left ( r_{ij},h \\right ) \\right ) $$\n（公式2） 其中$b$的计算式为：\n$$ b = \\epsilon\\frac{\\delta t }{h} 。 $$\n（公式3） 为了保证仿真的稳定性，需要在一帧中多次迭代计算公式2。\n\r3. 实现 PeriDyno中，人工粘性求解器的源码文件为：\n\u0026#34;Engine/Dynamics/Module/ImplicitViscosity.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/ImplicitViscosity.h\u0026#34;; 人工粘性求解器的输入输出均为流体粒子速度。但相比于输入，输出的粒子速度在空间中的分布更为平滑。 a. 变量：   NeighborList (邻域粒子列表)\nDEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;\u0026#34;); 为了实现粒子各项物理量及其微分量的插值计算，计算过程需要使用到粒子的邻域列表。该邻域列表需要在每一帧计算开始时预先由邻域查找模块生成，邻域查找模块的位置为：\n\u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.h\u0026#34; \u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.cu\u0026#34;   Velocity, Position (粒子速度与位置)\nDEF_ARRAY_IN(Coord, Velocity, DeviceType::GPU, \u0026#34;Input particle velocity\u0026#34;); DEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Input particle position\u0026#34;); Velocity为粒子的速度（$\\mathbf{v}$）；Position为粒子空间位置 ($\\mathbf{x}$)。\n  b. 参数： DEF_VAR(Real, Viscosity, 0.05, \u0026#34;\u0026#34;); DEF_VAR(int, InterationNumber, 3, \u0026#34;\u0026#34;); DEF_VAR_IN(Real, SmoothingLength, \u0026#34;\u0026#34;);  Viscosity: 控制粘性强弱的系数； IterationNumber: 公式2的迭代次数； SmoothingLength: 平滑距离（支持域半径）。  c. 函数： template\u0026lt;typename Real, typename Coord\u0026gt; __global__ void IV_ApplyViscosity(...) 该函数的功能是计算公式2，获得粘性作用下的粒子速度。\n参考文献 Schechter H, Bridson R. Ghost SPH for animating water[J]. ACM Transactions on Graphics (TOG), 2012, 31(4): 1-8.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/postprocessing/renderingexample/",
	"title": "离线渲染样例",
	"tags": [],
	"description": "离线渲染与后处理-离线渲染与后处理样例
",
	"content": "简介 本节以“雨落新叶”的仿真场景作为样例，通过案例的方式对后处理中场景整合和离线渲染流程进行示范和阐述。\n一、导入 粒子导入： 1、启动Houdini，在节点工作区Object层级创建Geo节点并进入。\n2、创建Alembic节点，选择该节点，点击File Name通道后的icon以选择文件。\n3、在Choose File窗口勾选Showsequences as one entry，选择所需要的abc序列确认即可。\n4、创建convert节点连接至Alemibc节点，读取其中的属性。\n5、切换至Geometry Spreadsheet检查属性。\n模型导入： 1、在节点工作区Object层级创建Geo节点并进入。\n2、创建File节点，选择该节点，点击Geometry File通道后的icon以选择文件。\n3、如有需要，可以添加Transform节点进行模型变换属性的调节。\n  在选择Transform节点的状态下，可以在视口中按下Enter键，以启用控制手柄。\n  如需处理uv可以添加相关节点进行处理：如UVproject、UVunwrap、UVedit、UVlayout等。\n  4、如需uv传递可以添加AttritubeCopy节点和AttributeTransfer节点进行传递。\n  针对点序号相同的模型使用AttributeCopy进行点对点的属性拷贝，将输入输出类型选择为Points，Attribute Name处输入uv即可进行uv属性的拷贝。\n  针对点序号不同的物体，可以使用MatchSize、Transform等节点将模型对齐后使用AttributeTransfer节点进行属性的拷贝\n  二、粒子转网格 粒子转网格可以根据不同的情况选择使用ParticleFluidSurface节点、或自行使用VDB构建\n 您可以根据模拟数据的粒子间距调整Particle Separation属性，根据空间比例调整Voxel Scale 根据实际的粒子分布等综合情况调整Influence Scale Droplet Scale。（ParticleFluidSurface节点详解请见 https://www.sidefx.com/docs/houdini/nodes/sop/particlefluidsurface.html）    如需要对网格进行速度着色则应关闭Particle Fluid Surface的Adaptivity，保证网格布线均匀（@Cd是顶点色属性，需要足够数量且均匀的顶点分布以确保着色效果）。在Transfer Attributes通道下增加Cd属性。\n  最后可以添加File Cache节点并在Geometry File通道指定一个路径进行网格文件的缓存。\n  使用MeshlessSkinning工具进行粒子网格化\n txt格式的粒子数据可以使用MeshlessSkinning工具进行网格化。具体使用方法如图所示：   三、渲染设置 1、在Object层级下创建camera节点，并调整位置进行拍摄。可以在视窗选择所创建的Camera并使用视窗右侧的“锁”图标锁定摄像机，以通过视口操作摄像机。\n此外您还可以通过在视窗上按下Alt+[或Alt+]按键，创建多个视口协同操作。\n2、在Object层级下创建ROPNetwork节点，进入该节点，本节以Vray渲染流程为例，创建VrayRenderer节点。\n3、选择V-RayRenderer节点，指定渲染帧数范围，渲染使用的摄像机，在Export标签下设置是否启用降噪，是否使用渲染元素。\n4、选择Image标签，设置文件的保存路径及格式，注意避免中文路径。\n  如需使用RenderElements可以点击Image-Render Elements下的Templates通道后的Generate以快速生成RenderElement节点。\n  如需使用降噪，请进入该RenderElement节点创建Denoise节点并连接至输出端。\n  5、选择V-RayRenderer节点，在Renderer-Sampler-Image Sampler选项卡下将Type指定为“Bucket”，并酌情修改相关采样。\n四、灯光 1、在Object层级下创建vrayLightDome，并切换至V-Ray Light标签，在Texture通道选择一张HDRI贴图作为光照环境，点击Invisble使环境贴图在渲染中不可见。\n2、点击工具架V-Ray标签下的Render按钮进行渲染，点击IPR进行交互渲染，基于目前的光照效果调整vrayLightDome的Intensity值。\n3、根据需要创建vrayLightRectangle，并调整其变换和相关灯光参数进行布光设计。\n五、材质 1、在Object层级下创建MaterialNetwork，并进入。\n2、创建vrayMaterialBuilder节点，将该节点拖拽到视口内的模型上以指定材质。\n3、进入vrayMaterialBuilder调节vrayMtl节点的相关材质属性。使用V-RayImageFile指定贴图。\n  如需使用透明，可将Refraction标签下的Color设置为白色，并酌情开启或关闭Affect Shadows。\n  在透明情况下，建议将Diffuse颜色设置为黑色，防止因Refraction设置失误而出现颜色上的干扰。\n  需要较为通透的高光反光可将Reflection标签下的Glossiness参数提高。\n  V-Ray Material节点内容较多，您可以查阅官方网站根据图片了解和对比各参数的效果: https://docs.chaos.com/display/VRAYHOUDINI/V-Ray+Material\n  "
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/surfacetension/",
	"title": "表面张力",
	"tags": [],
	"description": "粒子系统-流体-表面张力
",
	"content": "1. 简介 表面张力的作用会使流体表面积和曲率趋向于最小，对于小尺度流体的运动形态有较大的影响。PeriDyno目前使用的表面张力求解器是基于自由表面能量函数方法实现的，该方法相比于其它方法稳定性更好，而且不会引入过多的计算量。\n2. 方法 表面张力的大小取决于流体气液表面的曲率，而流体表面的曲率（$\\nabla_i c$）可以通过以下公式计算，即： $$ \\nabla_i c = \\frac{\\sum_j Vj \\nabla_i W(r_{ij},h)}{\\sum_j Vj W(r_{ij},h)} $$ （公式1）\n由自由表面能最小化模型，流体的表面张力可通过如下公式计算获得： $$ F_i = 0.25 \\kappa \\sum_j V_i V_j \\left ( |\\nabla_i c |^2 + |\\nabla_j c |^2 \\right ) \\nabla_i W(r_{ij},h) $$ （公式2）\n上式中的 $V、\\kappa$ 分别为粒子的体积以及控制表现张力作用强度的系数。\n在获取到粒子的表面张力后，即可更新流体粒子的位置，实现表面张力作用下流体运动的模拟。\n3. 实现 PeriDyno中，表面张力求解器的源码文件为：\n\u0026#34;Engine/Dynamics/Module/SurfaceTension.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/SurfaceTension.h\u0026#34;; "
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/others/",
	"title": "其它模块",
	"tags": [],
	"description": "粒子系统-流体-其它模块
",
	"content": "除不可压缩性、粘性、表面张力核心求解器外，粒子系统中还包含有辅助模块。本节将对这些辅助模块进行简要的介绍。\n1. 粒子发射器 每一帧都会输出一定量的流体粒子。现阶段PeriDyno中包含有两种粒子发射器，分别为方形粒子发射器和圆形粒子发射器，在PeryDyno工程中的路径为：\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/SquareEmitter.cu\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/SquareEmitter.h\u0026#34;; 以及\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/CircularEmitter.cu\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/CircularEmitter.h\u0026#34;; 这两种粒子发射器有共同的基类，即：\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/ParticleEmitter.cu\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/ParticleEmitter.h\u0026#34;; 两种发射器都可以通过代码或在GUI界面中修改粒子间距（samplingDistance）、粒子初速度(initialVelocity)、方向(Rotation)，以及发射器的尺寸大小（weight/hight/Radius）。\n2. 边界约束（节点） 边界约束节点是粒子所在空间中的边界。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/BoundaryConstraint.h\u0026#34;; 当该模块检测到粒子穿入边界之外时，粒子会被修正边界附近，同时会修正相应粒子的速度，对粒子施加滑移边界条件、无滑移边界条件或结于两种条件之间的条件。粒子的速度修正方式由参数 TangentialFriction （切向摩擦系数） 与 NormalFriction（法向摩擦系数）来控制。\n为了快速地检测边界与粒子的距离，该模块中的边界为有向距离场形式（SDF）。边界约束节点模块中预制了解析式生成的球体边界（Sphere）和六面体边界（Cube），此外也可以通过函数load直接载入有向距离场模型文件。\n该节点中，也可以设置粒子可运动的空间是位于封闭边界的内部或外部（inverted）。\n3. 核函数 SPH法中的核函数。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/Kernel.h\u0026#34;; 该模块中包含有以下几类核函数：\n SpikyKernel，较为尖锐的核函数； ConstantKernel，常数； SmoothKernel，平滑核函数； CorrectedKernel，修正后的核函数（避免粒子距离过近而导致奇点问题） CubicKernel，三次样条函数形式的核函数； QuarticKernel，四次样条函数形式的核函数。  4. 粒子速度耗散模块 按一定比例耗散粒子速度的模块。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/LinearDamping.h\u0026#34;; 5. 粒子积分模块 即粒子速度、位置更新模块。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/ParticleIntegrator.h\u0026#34;; 根据粒子所受到的力更新其速度，并根据其速度更新其位置。\n6. 密度计算模块 用于计算粒子的质量密度的模块。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/SummationDensity.h\u0026#34;; 该模块也可根据粒子的初始间距、静态质量，计算出每个粒子的质量。\n7. 粒子属性 为了模拟流体以外的材料及其与流体之间的耦合，场景中的粒子需要标记为不同的材料属性和可运动属性。这一特性的标记见Attribute文件，即：\n\u0026#34;Engine/Dynamics/ParticleSystem/Attribute.h\u0026#34;; 粒子系统中，粒子可以有多种属性，比如：流体（fluid）、刚体(rigid)、弹性材料(elastic)、塑性材料(plastic)。此外也可将粒子标记为可运动(dynamic)、不可运动(fixed)、通过关键帧控制的运动(passive)等。\n8. 流体模型 流体完整的仿真流程被封装在了model文件中，比如ProjectionBasedFluidModel、PositionBasedFluidModel。这类model文件中包含有粒子邻域查找、不可压缩性计算、粘性计算、速度位置更新等诸多流程。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/PositionBasedFluidModel.h\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/ProjectionBasedFluidModel.h\u0026#34;; 9. 节点文件 节点文件中包含有仿真场景中所需要用到所有全局变量，例如场景所有粒子的空间位置数组（Position）、速度数组（Velocity）、力数组（Force）、粒子属性数组（Attribute）,法向量数组（Norm）等。同时也包含了管理、分配、释放这些变量所需的函数。\n\u0026#34;Engine/Dynamics/ParticleSystem/ParticleFluid.h\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/ParticleSystem.h\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/GhostFluid.h\u0026#34;; "
},
{
	"uri": "https://peridyno.github.io/zh/",
	"title": "泛动引擎",
	"tags": [],
	"description": "",
	"content": "泛动引擎（PeriDyno）帮助文档 "
},
{
	"uri": "https://peridyno.github.io/zh/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/zh/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]