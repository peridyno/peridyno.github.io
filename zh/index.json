[
{
	"uri": "https://peridyno.github.io/zh/examples/cloth/",
	"title": "布料仿真",
	"tags": [],
	"description": "",
	"content": "1、布料模拟 该场景由两个模型组成，一个是上方的布料模型，一个是下方的静态球体。布料从空中掉落，并与静态球体发生碰撞，最后掉落到地面。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真边界以及布料节点：  auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); root-\u0026gt;loadCube(Vec3f(0), Vec3f(1), 0.005f, true); root-\u0026gt;loadShpere(Vec3f(0.5, 0.7f, 0.5), 0.08f, 0.005f, false, true); auto cloth = scn-\u0026gt;addNode(std::make_shared\u0026lt;Cloth\u0026lt;DataType3f\u0026gt;\u0026gt;()); cloth-\u0026gt;loadParticles(\u0026#34;../../data/cloth/cloth.obj\u0026#34;); cloth-\u0026gt;loadSurface(\u0026#34;../../data/cloth/cloth.obj\u0026#34;); root-\u0026gt;addParticleSystem(cloth);  创建渲染节点：  auto pointRenderer = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRenderer-\u0026gt;setColor(Vec3f(1, 0.2, 1)); pointRenderer-\u0026gt;setColorMapMode(GLPointVisualModule::PER_OBJECT_SHADER); cloth-\u0026gt;currentTopology()-\u0026gt;connect(pointRenderer-\u0026gt;inPointSet()); cloth-\u0026gt;stateVelocity()-\u0026gt;connect(pointRenderer-\u0026gt;inColor()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRenderer); cloth-\u0026gt;setVisible(true); auto surfaceRenderer = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); cloth-\u0026gt;currentTopology()-\u0026gt;connect(surfaceRenderer-\u0026gt;inTriangleSet()); cloth-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(surfaceRenderer); 3、仿真效果 代码参考examples/GL_Cloth/main.h:\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/rigidbodydynamics/broadphase/",
	"title": "宽阶段碰撞检测",
	"tags": [],
	"description": "刚体碰撞
",
	"content": "刚体碰撞流程主要分为五部分。首先，对可能产生碰撞的n个刚体构建包围盒树（包括：AABB树（轴平行包围盒树，Aixe align bounding box tree）和OBB树（有向包围盒树），下述将以AABB树为例），将AABB树的根节点对应的区域，作为的碰撞区域；然后，使用Z空间填充曲线（Z-SFC）对碰撞区域进行划分，生成单元空间，并使用Morton码（莫顿码）对单元空间进行编码，生成Z空间填充曲线（Z-SFC）索引，以便后续构建内部节点的邻接关系；接着，根据生成的Z空间填充曲线（Z-SFC）索引自底向上、并行的构建压缩八叉树；其次，对构建出来的压缩八叉树进一步并行的恢复成完整的八叉树结构；最后，根据完整的八叉树自底向上的进行并行碰撞检测。接下来详细介绍每一个步骤：\n1、构建AABB树 AABB树中每个子节点也是AABB树的结构，它只需要log(n)的时间复杂度就能完成节点的搜索过程。假设我们要检测刚体1-9的碰撞。根据刚体1-9的轮廓生成AABB包围盒。接下来通过执行以下操作来构建AABB树：   把刚体1作为AABB树的根节点；\n  把刚体2和刚体1作比较，判断刚体2与刚体1所在的区域有没有交集。如果有交集则继续判断刚体2是否与刚体1的子集有交集，将其加入到与节点1有公共交集的子集的最小的公共子节点之后。如果刚体2与刚体1没有交集，则根据刚体1和刚体2的区域重新生成一个公共区域，作为节点1和节点2的公共节点；\n  重复步骤b)，直达把所有的节点都加入到AABB树中，并将AABB树的根节点对应的区域，作为的碰撞区域。\n  2、构建Z空间填充曲线（Z-SFC）和索引 Z空间填充曲线（Z-SFC）技术易于实现，并行化高，可用于将二维或三维空间中的区域进行有效的线性化。假设在D维空间中，将空间的每个维度均匀的分成k分，则会产生 个相等的非重叠的小空间单元。例如使用Z空间填充曲线（Z-SFC）对二维正方形区域进行划分，结果如下图所示；根据划分的结果按顺序进行标记： 例如刚体1-9进行空间划分之后可得到： 通常将划分的结果左下角的小单元空间设置为Z空间填充曲线（Z-SFC）的起点，并对区域进行Morton码编码。在二维空间中，假设存在刚体P的重心位置坐标为（x，y），则将该坐标作为叶子节点的坐标。经过Z空间填充曲线（Z-SFC）划分之后，该点所属的单元将为。对于刚体9横跨多个区域的需要进行去重操作$(\\left\\lfloor {{2^k}x/D} \\right\\rfloor ,\\left\\lfloor {{2^k}y/D} \\right\\rfloor )$，此时刚体9的Z空间填充曲线索引设置为数值最小的区域即11110000，并保存这几个区域的信息。二维空间创建Z空间填充曲线索引如下图所示： 根据Z空间填充曲线（Z-SFC）索引，我们可以创建不同层级的Z空间填充曲线（Z-SFC），如下图所示： 3、基于GPU的并行压缩八叉树的构建 不同于CPU的八叉树构建，基于GPU的并行八叉树的构建是自底向上构建的。根据叶子节点所在的位置，反向生成内部节点，进而确定内部节点的关系，从而确定树的结构。自底向上生成树的过程适用于GPU并行计算。具体的实施过程如下图所示：   构建叶子节点\n  将待检测的刚体1-9作为输入点，使用长度为2n-1（n表示刚体的数量）的数组A保存这9个输入点作为叶子节点。\n  根据叶子节点的坐标生成Z空间填充曲线（Z-SFC）索引。\n  根据叶子节点的Z空间填充曲线（Z-SFC）索引，并行对数组A中的9个元素进行排序。\n    生成内部节点和八叉树的后序遍历 对每个相邻的叶子，使用Z空间填充曲线（Z-SFC）索引中的公共位并行的找出最小公共父节点（LCA）。例如，相邻叶子节点1和节点2的Z空间填充曲线（Z-SFC）索引分别为11000001和11000010，由此可得到节点1和节点2的最小公共父节点为11000000。\n 分配n − 1个GPU线程。 对于数组A中的每两个相邻叶子（例如数组A[i]和A[i + 1]），并行生成最小公共父节点，其最小公共节点的Z空间填充曲线索引为叶子节点A[i]和A[i + 1]的Z空间填充曲线索引的最大公共部分，并将其值存储在A[n + i]中。 根据公共节点的Z空间填充曲线索引，对不同层的内部节点进行并行排序。如果元素L1包含在元素L2中，则将L2元素置于L1元素之前；否则，将L1元素置于L2元素之前。图7中的（c）显示了排序后的内部节点，其中可能会生成重复项（N2和N3）。 在数组A的后半部分中，删除重复项。 对于没有相同Z空间填充曲线（Z-SFC）索引的两个相邻内部节点，并行地从当前节点开始遍历数组A的后半部分，删除它们重复的项。根据Z空间填充曲线（Z-SFC）索引对数组A进行并行排序，进而可以得到压缩八叉树的后序遍历。    生成压缩八叉树 我们可以注意到数组A的末尾可能会有一些空元素。这是无法避免的，因为CUDA不支持动态内存分配和释放，因此必须在编译时就创建大小为2n−1的数组。然而仅仅得到八叉树的后续遍历还无法确定树的结构。（a）所示节点A和节点B属于同级的情况，因此它们的公共的父节点为C；（b）所示节点B是节点N的子节点，与节点A是相邻节点。（c）所示节点B是节点A的父节点。\n为了进一步确定八叉树的内部结构，执行以下步骤：\n 分配两倍大小的叶子和内部节点数的数组B（最多4n-2）。将数组A复制到数组B中。 分配（叶子节点数+ 内部节点数-1）个GPU线程。 对于数组B的前半部分中的每两个相邻节点，根据Z空间填充曲线（Z-SFC）索引并行的生成最小公共父节点。例如对于数组B中的每两个相邻叶子B[i]和B[i + 1]，并行生成内部节点，并将其存储在B[n + i]中。 根据Z空间填充曲线（Z-SFC）索引对生成的结果进行并行排序，将所有的内部节点和它们的副本将归并到一起。 对于具有相同Z空间填充曲线（Z-SFC）索引并且至少其中一个不是副本的节点，建立内部节点的父子关系。最终生成的压缩八叉树下图所示：     4、从压缩八叉树中恢复完整的八叉树 两个相邻的节点N4和节点3，其中节点3是节点N4的子节点。通过Z空间填充曲线（Z-SFC）索引来计算两个节点之间的深度差。例如节点N4和节点3的Z空间填充曲线（Z-SFC）索引分别为11000000和11001101，则深度差为2（节点N4处于深度1，节点3处于深度3，假设根深度为0）。这种差异表明压缩八叉树中缺少节点N4和节点3之间的中间节点。 为了生成完整的八叉树结构执行：\n 分配大小等于数组A长度的线程，即（叶子数+内部节点数）。 计算每个节点与其父节点的深度差并累加，以获取插入内部节点所需的内存总数（由于GPU上不能进行动态的分配内存）。 根据每个节点与其父节点之间的深度差添加新的节点。当深度差大于1时，并行的在其中间插入新的节点。如下图所示，在节点N4和节点3之间插入了一个内部节点CH1，以获得完整八叉树结构。  5、使用八叉树结构自底向上的对刚体进行并行的碰撞检测 从叶子节点开始自底向上进行检测，当发现碰撞点时进一步进行细粒度检测，直到找到发生碰撞的叶子节点对。  假设刚体2和刚体3发生了碰撞。针对待碰撞检测刚体，计算刚体所有八叉树层数及对应叶子节点，利用步骤4中八叉树自底向上查询所有重叠区域对应刚体的AABB包围盒。 如果找到碰撞包围盒，针对上述步骤中得到的AABB包围盒进一步对刚体2和刚体3的边界进行精确的碰撞检测，结果如下图所示：   "
},
{
	"uri": "https://peridyno.github.io/zh/reference/reflection/",
	"title": "C++反射",
	"tags": [],
	"description": "",
	"content": "1、反射是什么 假设我们已知某个类的名称，那么如何通过类名称字符串来动态生成类的对象？\n在Java编程中，这并不是个问题。但是C++的语言特性决定了其并不支持通过类名称字符串”ClassXX”来生成对象的，也就是说在C++中我们可以使用ClassXX* object =new ClassXX来生成对象，但是不能通过ClassXX* object=new “ClassXX”来生成对象。这导致我们对节点和模块功能扩展的时候无法做到自适应扩展，也就是如果我们额外引入一个新的功能模块，仿真引擎无法动态感知到它的存在。\n反射机制引入的就是为了解决仿真节点和功能模块的自适应扩充问题，从而避免代码之间的深度耦合。\n2、C++反射原理 参考代码src/Framework/Object.h。\n\r3、扩展模块如何支持反射 所有需要支持反射的类需要继承自Object。以src/Dynamics/ParticleSystem/SummationDensity.h中实现的类为例，其支持反射的流程包含两个步骤\n  派生Object或者Object的子类\ntemplate\u0026lt;typename TDataType\u0026gt; class SummationDensity : public virtual ParticleApproximation\u0026lt;TDataType\u0026gt;   接口申明\nDECLARE_CLASS(SummationDensity)\r//或者\rDECLARE_TCLASS(SummationDensity, TDataType)\r其中SummationDensity对应类的名称，TDataType对应模板参数\n  接口实现\nIMPLEMENT_TCLASS(SummationDensity)\r//或者\rIMPLEMENT_TCLASS(SummationDensity, TDataType)\r其中通过DECLARE_CLASS/DECLARE_TCLASS通过定义静态变量完成对SummationDensity的注册。\n  DECLARE_TCLASS和IMPLEMENT_TCLASS要求定义在同一头文件内，该方式对于实现文件为cpp后缀的类有效。然而当前NVCC的编译器依然存在一定问题，如果实现文件为.cu后缀，则定义的static变量无法完成初始化，需要通过额外的类来完成。\n\r一个可行的解决方案是针对每一个静态链接库引入一个额外的类来完成初始化，在initializeParticleSystem.h中引入\nclass ParticleSystemInitializer : public Object { public: ParticleSystemInitializer(); }; const static ParticleSystemInitializer particleSystemInitializer; 同时再initializeParticleSystem.cpp中定义实现如下构造函数来完成对.cu文件中定义的类进行显式调用。\nParticleSystemInitializer::ParticleSystemInitializer() { TypeInfo::New\u0026lt;LinearDamping\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;ParticleIntegrator\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;ImplicitViscosity\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;DensityPBD\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;SummationDensity\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;VariationalApproximateProjection\u0026lt;DataType3f\u0026gt;\u0026gt;(); } 最后在待运行的Qt项目的CMakeLists.txt中加入\u0026quot;WHOLEARCHIVE\u0026quot;（链接自动注册类的lib库）。例如，运行Qt_VtkVisualModule项目，并期望在项目中自动注册initializeParticleSystem.cpp中类。在{peridyno_Code_path}/examples/Qt_VtkVisualModule/CMakeLists.txt中添加 ：\n"
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/simulation/",
	"title": "仿真管线",
	"tags": [],
	"description": "",
	"content": "1、仿真管线运行时序图 2、支持模块类型 仿真管线支持的模块类型包括\n 计算模块ComputeModule，虚函数接口为：  virtual void compute();  拓扑模块TopologyModule，虚函数接口为：  virtual void updateTopology()；  输入模块InputModule，虚函数接口为：  输入接口取决于外设类型，详情参加交互章节。\n\r 输出模块OutputModule，虚函数接口为：  virtual void flush() {};  约束模块ConstraintModule，虚函数接口为：  virtual void constrain()\r 用户自定义模块CustomModule，虚函数接口为：  virtual void applyCustomBehavior(); "
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/scenegraph/",
	"title": "场景图",
	"tags": [],
	"description": "",
	"content": "场景图主要包含节点管理、场景遍历、场景更新等功能。\n1、节点管理 节点管理功能包括：\n 添加节点  template\u0026lt;class TNode, class ...Args\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(Args\u0026amp;\u0026amp; ... args) template\u0026lt;class TNode\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(std::shared_ptr\u0026lt;TNode\u0026gt; tNode) 其中TNode表示节点（Node）的派生类型，Args则对应节点构造过程所需要的参数\n 删除节点  void deleteNode(std::shared_ptr\u0026lt;Node\u0026gt; node); 2、场景遍历 场景图（SceneGraph）将其包含的节点抽象为有向无环图（Directed Acyclic Graph）中的顶点，数据的链接则抽象为顶点之间的有向边，因此一个点简单的包含四个节点的场景可以用如下的有向无环图来表示:\n对场景图包含节点的遍历可采用类似DAG的遍历算法来完成，目前主要提供两类接口：\n 先序遍历，调用方式为  void traverseForward(Action* act); ​ 或者\ntemplate\u0026lt;class Act, class ... Args\u0026gt; void traverseBackward(Args\u0026amp;\u0026amp; ... args) ​ 对应上图的场景，先序遍历得到的节点序列如下：\n 后续遍历  void traverseBackward(Action* act); ​\t或着\ntemplate\u0026lt;class Act, class ... Args\u0026gt; void traverseBackward(Args\u0026amp;\u0026amp; ... args) Action为遍历过程中对每个节点进行的操作，可用于完成更新节点、获取特定类型模块等操作。\n\r​\t针对整个场景的遍历采用如下所示的广度优先算法完成\nvoid BFS(Node* node, NodeList\u0026amp; nodeQueue, std::map\u0026lt;ObjectId, bool\u0026gt;\u0026amp; visited) {\rvisited[node-\u0026gt;objectId()] = true;\rnodeQueue.push_back(node);\rauto exports = node-\u0026gt;getExportNodes();\rfor (auto port : exports) {\rauto exNode = port-\u0026gt;getParent();\rif (exNode != nullptr \u0026amp;\u0026amp; !visited[node-\u0026gt;objectId()]) {\rBFS(exNode, nodeQueue, visited);\r}\r}\rauto outFields = node-\u0026gt;getOutputFields();\rfor each (auto f in outFields) {\rauto\u0026amp; sinks = f-\u0026gt;getSinks();\rfor each (auto sink in sinks) {\rif (sink != nullptr) {\rauto exNode = dynamic_cast\u0026lt;Node*\u0026gt;(sink-\u0026gt;parent());\rif (exNode != nullptr \u0026amp;\u0026amp; !visited[exNode-\u0026gt;objectId()]) {\rBFS(exNode, nodeQueue, visited);\r}\r}\r}\r}\r};\rvoid SceneGraph::updateExecutionQueue()\r{\rif (!mQueueUpdateRequired)\rreturn;\rmNodeQueue.clear();\rstd::map\u0026lt;ObjectId, bool\u0026gt; visited;\rfor (auto\u0026amp; nm : mNodeMap) {\rvisited[nm.first] = false;\r}\rfor (auto\u0026amp; n : mNodeMap) {\rif (!visited[n.first])\t{\rNode* node = n.second.get();\rDFS(node, mNodeQueue, visited);\r}\r}\rvisited.clear();\rmQueueUpdateRequired = false;\r}\r3、局部遍历 以上述有向无环图为例，当节点B的内容发生变化时，我们需要对依次更新B以后的节点C和D，同时注意掉A的数据并不依赖与B，因此B的内容更新不应该影响A的内容。为了场景图的局部更新，场景图提供了如下接口用于更新特定节点的后续节点：\nvoid traverseForward(std::shared_ptr\u0026lt;Node\u0026gt; node, Action* act); ​ 或者\ntemplate\u0026lt;class Act, class ... Args\u0026gt; void traverseForward(std::shared_ptr\u0026lt;Node\u0026gt; node, Args\u0026amp;\u0026amp; ... args); ​\t其实现主要采用广度优先算法完成\n//Used to traverse the scene graph from a specific node void BFS(Node* node, NodeList\u0026amp; nodeQueue, std::map\u0026lt;ObjectId, bool\u0026gt;\u0026amp; visited) { visited[node-\u0026gt;objectId()] = true; nodeQueue.push_back(node); auto exports = node-\u0026gt;getExportNodes(); for (auto port : exports) { auto exNode = port-\u0026gt;getParent(); if (exNode != nullptr \u0026amp;\u0026amp; !visited[node-\u0026gt;objectId()]) { BFS(exNode, nodeQueue, visited); } } auto outFields = node-\u0026gt;getOutputFields(); for each (auto f in outFields) { auto\u0026amp; sinks = f-\u0026gt;getSinks(); for each (auto sink in sinks) { if (sink != nullptr) { auto exNode = dynamic_cast\u0026lt;Node*\u0026gt;(sink-\u0026gt;parent()); if (exNode != nullptr \u0026amp;\u0026amp; !visited[exNode-\u0026gt;objectId()]) { BFS(exNode, nodeQueue, visited); } } } } }; void SceneGraph::traverseForward(std::shared_ptr\u0026lt;Node\u0026gt; node, Action* act) { std::map\u0026lt;ObjectId, bool\u0026gt; visited; for (auto\u0026amp; nm : mNodeMap) { visited[nm.first] = false; } NodeList list; BFS(node.get(), list, visited); for (auto it = list.begin(); it != list.end(); ++it) { Node* node = *it; act-\u0026gt;start(node); act-\u0026gt;process(node); act-\u0026gt;end(node); } list.clear(); visited.clear(); } 4、场景更新   更新运行队列   void updateExecutionQueue(); 更新的时机主要依赖于场景图中的节点以及连接关系是否发生变动，一旦任意一项发生改变，场景的节点执行队列会在下次执行节点功能的时候优先更新运行队列。\n 更新节点状态  void propagateNode(std::shared_ptr\u0026lt;Node\u0026gt; node); 当某个特定节点的运行状态发生改变时，如节点的配置参数发生改变，场景图可以通过调用propagateNode()函数对后续所有依赖该节点的节点的状态进行更新。\n5、其他功能 参见src/Framework/SceneGraph.h和src/Framework/SceneGraph.cpp相应实现。\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/overview/",
	"title": "概要",
	"tags": [],
	"description": "Peridyno概述。
",
	"content": "PERIDYNO概述 PERIDYNO是一个基于CPU/GPU混合架构实现的实时物理仿真引擎， 其通过基于数据（Field）-\u0026gt;模块（Module）-\u0026gt;节点（Node）-\u0026gt;场景图（SceneGraph）的通用物理仿真框架，将仿真计算与渲染、仿真计算与交互、仿真计算与底层分离有效实现了仿真算法模块的复用。PERIDYNO旨在解决通用物理仿真任务的增量开发、集成与模块复用难题，实现端云协同环境一套仿真计算代码零成本迁移、多平台复用的目标，其解决的核心问题包括：\n 物理仿真数据表示的完备性问题。 复杂场景作用机理的模块化难题。 仿真数据与作用机制模块的统一计算图。  目前，PERIDYNO支持模拟流体、弹性物体和断裂等典型物理仿真场景及多物理场景的耦合仿真，具备良好的扩展性，可方便得辅助研发人员开发与验证新的仿真算法。\nPERIDYNO特性 PERIDYNO具有以下特性，可以有效地模拟复杂的物理场景：\n  模板编程：PERIDYNO以模板的形式支持CPU/GPU兼容的典型数据结构，包括一维数组、二维数组、三维数组、动态数组以及稀疏八叉树等数据数据类型的高效并行实现；\n  高度模块化：整体从上到下模块化，因此可以通过扩展现有组件轻松获得自定义行为；\n  复杂耦合：支持通用物理仿真任务，包括刚体、流体、形变体以及多物理场耦合仿真；\n  高性能：核心仿真算法做到100%GPU并行化，实现了仿真、渲染、交互的高效协同。\n  如何进一步学习PERIDYNO 本文档主要包含如下几大块内容，即：\n 安装指引: 重点介绍PERIDYNO及配套工具在不同系统平台下的安装与编译过程； 引擎框架：对PERIDYNO引擎的框架介绍； 技术专题：介绍PERIDYNO现有的仿真算法； 仿真案例：通过典型仿真案例学习如何基于PERIDYNO进行研发。  "
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/",
	"title": "场景管理",
	"tags": [],
	"description": "",
	"content": "1、场景示意图 泛动引擎通过场景图（Scene Graph）对包括节点（Node）、模块（Module）以及数据（Field）在内的全要素进行统一管理。 如下图展示了一个包含四个仿真节点的场景图：\n场景中每个节点内置两条管线，分别为仿真管线和渲染管线，用于完成仿真计算、渲染及交互功能。在GUI视图中，双击节点可以得到如下图所示的管线示意图 如上图所示，当前支持的数据传递方向主要支持四类：节点输出—\u0026gt;节点输入、模块输出—\u0026gt;模块输入、节点输入—\u0026gt;模块状态变量、模块输出—\u0026gt;节点输出\n\r2、如何创建场景 接下来,以流体仿真案例为例展示如何基于泛动引擎创建一个完整的演示demo，完整流程包含如下四个步骤：\n  创建场景图\nstd::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();   添加仿真节点\n//添加流体仿真节点 auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(0.5, 0.2, 0.4), Vec3f(0.7, 1.5, 0.6), 0.005); //添加边界节点 auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;bowl/bowl.sdf\u0026#34;, false); //添加粒子可视化节点 auto visualizer = scn-\u0026gt;addNode(std::make_shared\u0026lt;GLPointVisualNode\u0026lt;DataType3f\u0026gt;\u0026gt;());   设置节点数据连接关系\n//流体节点--\u0026gt;边界约束节点 fluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems()); //流体节点--\u0026gt;可视化节点 fluid-\u0026gt;connect(visualizer-\u0026gt;importParticleSystem());   创建应用界面，PeriDyno目前同时支持GLFW和QT两套应用界面，以GLFW为例，其算法流程如下\nGlfwApp window; //设置仿真场景 window.setSceneGraph(scn); //创建应用界面 window.createWindow(1024, 768); window.mainLoop(); \r当前版本要求createWindow()函数边界必须在setSceneGraph()和setRenderEngine()两个函数调用之后进行，如不显式设置渲染引擎，则默认采用内置基于OpenGL实现的GLRenderEngine来完成。\n\r效果示意图如下：\n  如果使用Qt界面，可通过如下代码构建：\nQtApp window;\r//设置仿真场景\rwindow.setSceneGraph(scn);\r//创建应用界面\rwindow.createWindow(1024, 768);\rwindow.mainLoop();\r场景图的可视化展示如下： 样例参见 examples/GL_ParticleFluid和examples/Qt_GLVisualModule。\n\r  "
},
{
	"uri": "https://peridyno.github.io/zh/topics/rigidbodydynamics/narrowphase/",
	"title": "窄阶段碰撞检测",
	"tags": [],
	"description": "",
	"content": "1、功能简介 Peridyno提供了多种几何基本单元之间的碰撞检测算法函数。用户可以通过位置信息对几何基本单元进行初始化，进而调用相关函数进行位置关系的判断。\n2、几何基本单元介绍 Peridyno提供了13种几何基本单元的构造以及相关的碰撞检测算法，具体实现可以参考src/Framework/Topology/Primitive3D.inl。\nTPoint3D TPoint3D定义了三维空间中的一个点。既通过点坐标进行初始化，\nCoord3D position = Coord(0,1,0); Point3D point0(position); //使用坐标三元数进行初始化 Point3D point1(0,1,0);//使用三个坐标进行初始化 也可以用另一个TPoint3D进行初始化\nPoint3D point0(0,1,0); Point3D point1(point_0);\tTAlignedBox3D TAlignedBox3D定义了轴对齐包围盒，是几何单元计算轴对齐包围盒的方法aabb()的返回对象。它可以通过两个三维点坐标v0、v1（v0的三个坐标值均需要小于v1对应坐标值）进行初始化\nCoord v0(0,0,0); Coord v1(1,1,1); AABB aabb(v0, v1);\t//v0的三个坐标值均需要小于v1对应坐标值 也可以通过另一个TAlignedBox3D进行初始化\nAABB aabb1; ... AABB aabb2(aabb1);\tTAlignedBox3D中提供的方法如下：\n  intersect intersect计算了该AABB与另一个aabb之间是否相交以。返回值为布尔类型，代表两个AABB是否相交。如果发生相交，那么将交叠的AABB以传引用的方式返回。\n例如\n  AABB aabb1, aabb2; ... AABB interBox; if(aabb1.intersect(aabb2, interBox)) //如果aabb1和aabb2发生交叉，返回1并且将交叉的AABB存入interBox { ... }\t  isValid\nisValid返回值为布尔类型，判断v0的三个坐标值均需要小于v1对应坐标值，\n  return v1[0] \u0026gt; v0[0] \u0026amp;\u0026amp; v1[1] \u0026gt; v0[1] \u0026amp;\u0026amp; v1[2] \u0026gt; v0[2];\t使用方法如\nAABB aabb; ... if(aabb.isValid()) //判断aabb的v0的三个坐标值是否不大于v1的对应坐标值 { ... }\t length length(unsigned int i)计算了aabb在i轴边长v1[i] - v0[i]，例如  AABB aabb; ... Real l_x = aabb.length(0);//x轴的边长 Real l_y = aabb.length(1);//y轴的边长 Real l_z = aabb.length(2);//z轴的边长 TSphere3D TSphere3D定义了三维空间中的一个球体。既通过球心坐标和球半径进行初始化，\nCoord3D center = Coord(0,1,0); Real radius = 0.5f; Sphere3D sphere(center, radius); 也可以用另一个TSphere3D进行初始化\nSphere3D sphere0(center, radius); Sphere3D sphere1(sphere0);\tTSphere3D中提供的方法如下：\n  aabb\naabb计算了该球体的轴对齐包围盒，主要应用于宽阶段碰撞检测，例如\n  AABB box; switch (eleType) { case ET_SPHERE: { box = spheres[tId].aabb(); //计算该球体的轴对齐包围盒 \tbreak; } ... }   volume\nvolume计算了球体的体积，可以用于初始化例子质量等，例如\n  mass = sphere.volume() * density; //计算该球体的体积 TTet3D TTet3D定义了三维空间中的四面体，初始化方法包括使用四个顶点坐标进行初始化\nCoord3D p1,p2,p3,p4; ... Tet3D tet(p1,p2,p3,p4); 以及使用另一个TTet3D进行初始化\nTet3D tet0; ... Tet3D tet1(tet0); TTet3D中提供的方法如下：\n  aabb\naabb计算了该四面体的轴对齐包围盒，主要应用于宽阶段碰撞检测，例如\n  AABB box; TTet3D tet; ... box = tet.aabb(); //计算该球体的轴对齐包围盒  volume volume计算该四面体的体积，返回值为一个Real类型的实数。  TTet3D tet; ... Real volume_tet = tet.volume(); //计算该球体的轴对齐包围盒   circumcenter\ncircumcenter计算该四面体的外接圆圆心，返回值为一个TPoint3D类型的变量。\n计算方法可参考http://rodolphe-vaillant.fr/entry/127/find-a-tetrahedron-circumcenter。\n  TTet3D tet; ... TPoint3D circumcenter_tet = tet.circumcenter();   barycenter\nbarycenter计算该四面体的重心，返回值为一个TPoint3D类型的变量。\n  TTet3D tet; ... TPoint3D barycenter_tet = tet.barycenter(); TOrientedBox3D TOrientedBox3D定义了三维空间中的长方体，有三种初始化方法。\n第一种初始化方法使用长方体的中心、三个轴的方向以及三个轴方向边长的一半初始化。\nCoord3D center;//长方体中心坐标 Coord3D dir0, dir1, dir2;//均为三维向量，应两两相互垂直，分别代表长方体边的三个方向 Coord3D ext;//三维向量，第1、2、3维的数值均应非负，分别代表dir0、dir1、dir2方向边长的一半 ... Box3D obb(center, dir0, dir1, dir2, ext); 第二种初始化方法使用长方体的中心、用四元数表达的旋转角度以及三个轴方向边长的一半初始化。\nCoord3D center;//长方体中心坐标 Quat rot;//四元数代表的三个轴方向的旋转角 Coord3D ext;//三维向量，第1、2、3维的数值均应非负，分别代表dir0、dir1、dir2方向边长的一半 ... Box3D obb(center, rot, ext); 这里，长方体的三条边以(1,0,0),(0,1,0),(0,0,1)为初始方向，使用四元数进行旋转后即为长方体边的方向，具体可参考实现\nauto mat = rot.toMatrix3x3(); u = mat.col(0); v = mat.col(1); w = mat.col(2); 第三种初始化方法为使用另一个TOrientedBox3D进行初始化\nBox3D Box0; ... Box3D Box1(Box0); TOrientedBox3D中提供的方法如下：\n  aabb\naabb计算了该长方体的轴对齐包围盒，主要应用于宽阶段碰撞检测，例如\n  AABB box; Box3D obb; ... box = obb.aabb(); //计算该球体的轴对齐包围盒  volume volume计算该长方体的体积，返回值为一个Real类型的实数。  AABB box; Box3D obb; ... box = obb.volume(); //计算该球体的轴对齐包围盒 3、碰撞检测算法介绍 Peridyno可以检测几何基本单元之间的接触点、接触点法向和穿透距离，具体实现可以参考src/Framework/Collision/CollisionDetectionAlgorithm.inl。\n进行一次碰撞检测包含如下步骤：\n 定义一个TManifold用来存储碰撞信息  TManifold\u0026lt;Real\u0026gt; manifold; 其中TManifold在src/Framework/Collision/CollisionData.h中的定义如下，\ntemplate\u0026lt;typename Real\u0026gt; struct TManifold { public: Vector\u0026lt;Real, 3\u0026gt; normal;\t//接触点法向\t\tTContact\u0026lt;Real\u0026gt; contacts[8];\t//接触点位置以及穿透距离 \tint contactCount = 0; //两个几何基本单元的接触点数量 }; 其中contacts的定义如下，存储接触点的坐标以及穿透距离\ntemplate\u0026lt;typename Real\u0026gt; class TContact { public: Vector\u0026lt;Real, 3\u0026gt; position;\t// 接触点坐标 \tReal penetration;\t// 穿透距离 \t};   调用CollisionDetection::request进行碰撞检测\n定义好TManifold后，可以调用CollisionDetection::request系列函数进行碰撞检测。CollisionDetection::request为定义在src/Framework/Collision/CollisionDetectionAlgorithm.h中的一系列函数，其功能为计算并返回两个几何单元几何单元1和几何单元2之间的碰撞信息，存储在manifold中。它可以在CPU和GPU上调用，调用方法为\n  CollisionDetection\u0026lt;Real\u0026gt;::request(manifold, 几何单元1, 几何单元2); 例如，如果希望进行长方体（OBB）和四面体的碰撞检测，可以进行如下操作\nTet3D tetA; //创建一个四面体 tetA.v[0] = tetPos0; //初始化四面体顶点位置 tetA.v[1] = tetPos1; tetA.v[2] = tetPos2; tetA.v[3] = tetPos3; Box3D boxB;//创建一个长方体 boxB.center = center; //长方体中心点位置 boxB.extent = halfLength;//长方体三个方向的边长  Mat3f rot = rotation.toMatrix3x3(); //用长方体的旋转角初始化长方体的边方向 boxB.u = rot * Vec3f(1, 0, 0); boxB.v = rot * Vec3f(0, 1, 0); boxB.w = rot * Vec3f(0, 0, 1); TManifold\u0026lt;Real\u0026gt; manifold; //定义manifold用于存储穿透信息 CollisionDetection\u0026lt;Real\u0026gt;::request(manifold, tetA, boxB); //调用request，将穿透信息存储在manifold中 目前CollisionDetection::request支持的几何单元类型如下\nDYN_FUNC static void request(Manifold\u0026amp; m, const OBox3D box0, const OBox3D box1); //长方体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Sphere3D\u0026amp; sphere, const OBox3D\u0026amp; box); //长方体和球体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const OBox3D\u0026amp; box, const Sphere3D\u0026amp; sphere);//长方体和球体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Sphere3D\u0026amp; sphere0, const Sphere3D\u0026amp; sphere1);//球体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Tet3D\u0026amp; tet0, const Tet3D\u0026amp; tet1);//四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Tet3D\u0026amp; tet, const OBox3D\u0026amp; box);//长方体和四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const OBox3D\u0026amp; box, const Tet3D\u0026amp; tet);//长方体和四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Sphere3D\u0026amp; sphere, const Tet3D\u0026amp; tet);//球体和四面体之间的碰撞检测  DYN_FUNC static void request(Manifold\u0026amp; m, const Tet3D\u0026amp; tet, const Sphere3D\u0026amp; sphere);//球体和四面体之间的碰撞检测 对于长方体与四面体之间的碰撞检测，peridyno中采用分离轴定理（http://www.randygaul.net/2014/05/22/deriving-obb-to-obb-intersection-sat/）进行碰撞检测。\n 查询TManifold中的碰撞信息  在调用后，几何单元之间的碰撞信息被存储在TManifold中，可以通过访问TManifold中的信息获得碰撞接触点数量、接触点位置、接触点法向量和穿透距离。其中，接触点法向量由几何单元1指向几何单元2；穿透距离为一个负数，其绝对值代表两个该接触点沿接触点法向量的穿透的深度；如果两个集合体没有发生碰撞，那么接触点数量为0。\n例如，可以遍历TManifold中的contacts获得每个接触点的穿透深度。\nfor (int n = 0; n \u0026lt; manifold.contactCount; n++)//遍历每个穿透点 { ... cp.pos1 = manifold.contacts[n].position; //获取穿透点位置 \tcp.normal1 = -manifold.normal;//获取穿透法向量，对于相同的一对几何单元，每个接触点的穿透的法向量都相同 \tcp.interpenetration = -manifold.contacts[n].penetration;//获取穿透深度 \t... } "
},
{
	"uri": "https://peridyno.github.io/zh/examples/elasticity/",
	"title": "弹性体仿真",
	"tags": [],
	"description": "",
	"content": "1、弹性体仿真 在计算机图形学领域，基于物理方法的三维弹性体变形仿真有着广泛的应用需求。弹性体仿真采用粒子法，示例中模拟兔子模型的弹性运动。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真边界以及弹性体节点：  auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); root-\u0026gt;loadCube(Vec3f(0), Vec3f(1), 0.005f, true); auto bunny = scn-\u0026gt;addNode(std::make_shared\u0026lt;ElasticBody\u0026lt;DataType3f\u0026gt;\u0026gt;()); bunny-\u0026gt;connect(root-\u0026gt;importParticleSystems()); bunny-\u0026gt;loadParticles(\u0026#34;../../data/bunny/bunny_points.obj\u0026#34;); bunny-\u0026gt;loadSurface(\u0026#34;../../data/bunny/bunny_mesh.obj\u0026#34;); bunny-\u0026gt;scale(1.0f); bunny-\u0026gt;translate(Vec3f(0.5f, 0.1f, 0.5f)); bunny-\u0026gt;setVisible(true);  创建渲染节点：  auto pointRenderer = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRenderer-\u0026gt;setColor(Vec3f(1, 0.2, 1)); pointRenderer-\u0026gt;setColorMapMode(GLPointVisualModule::PER_OBJECT_SHADER); bunny-\u0026gt;currentTopology()-\u0026gt;connect(pointRenderer-\u0026gt;inPointSet()); bunny-\u0026gt;stateVelocity()-\u0026gt;connect(pointRenderer-\u0026gt;inColor()); bunny-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRenderer); 3、仿真效果 代码参考example/GL_Elasticity/main.h: "
},
{
	"uri": "https://peridyno.github.io/zh/installation/",
	"title": "安装指引",
	"tags": [],
	"description": "Peridyno安装教程.
",
	"content": "1、安装平台 Windows 平台: 支持Window 10、 Window 11平台\nLinux 平台：支持Ubuntu 18.04及以上平台\n2、协议 Peridyno 的默认许可是 Apache 2.0（参见 许可）。\n外部库是根据自己的条款协议分发。\n"
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/rendering/",
	"title": "渲染管线",
	"tags": [],
	"description": "",
	"content": "1、渲染管线运行时序图 2、支持模块类型 渲染管线兼容所有仿真管线支持的模块，渲染管线特有的功能模块包括：\n 可视化模块VisualModule，虚函数接口为：  virtual void updateGraphicsContext(); 子类主要包括ImWidget、GLVisualModule、VtkVisualModule，详情参加渲染章节内容\n"
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/nodes/",
	"title": "节点",
	"tags": [],
	"description": "",
	"content": "1、功能简介 节点为功能相对独立的、封装了特定功能模块的算法集合，主要包含如下几个部分：\n 控制变量：采用DEF_VAR宏定义数据； 输入节点：利用宏定义DEF_NODE_PORT或者DEF_NODE_PORTS定义； 输出节点：当前实现只支持节点自身作为默认输出，不需显式定义； 输入数据：采用DEF_*_IN形式宏定义定义的数据 输出数据：采用DEF_*_OUT形式宏定义定义的数据； 状态变量：采用DEF_*_STATE形式宏定义定义的数据； 模块管线：主要包含仿真管线和渲染管线各一条，分别采用animationPipeline()和graphicsPipeline()函数进行调用。  2、如何实现一个自定义节点 创建一个完整的节点包含如下步骤：\n  定义输入节点（可选）\nDEF_NODE_PORT(T, name, desc) 该宏定义定义单一节点输入，其中T代表节点类型，name表示名称，desc表示输入节点描述信息，访问方式为import+数据名称。\nDEF_NODE_PORTS(T, name, desc)\r该宏定义可定义输入节点数组，其可接入0到任意数量类型为T的节点作为输入，访问方式为import+数据名称+s。\n  定义输入数据（可选）\nDEF_VAR_IN(T, name, desc)\r定义输入类型为T、名称为name的单一数据类型作为输入。\nDEF_ARRAY_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维数组作为输入。\nDEF_ARRAY2D_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的二维数组作为输入。\nDEF_ARRAY3D_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的三维数组作为输入。\nDEF_INSTANCE_IN(T, name, desc)\r定义输入类型为T、名称为name的实例作为输入。\nDEF_ARRAYLIST_IN(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维动态列表数组作为输入。\n  定义输出数据（可选）\nDEF_VAR_OUT(T, name, desc)\r定义输入类型为T、名称为name的单一数据类型作为输出。\nDEF_ARRAY_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维数组作为输出。\nDEF_ARRAY2D_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的二维数组作为输出。\nDEF_ARRAY3D_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的三维数组作为输出。\nDEF_INSTANCE_OUT(T, name, desc)\r定义输入类型为T、名称为name的实例作为输出。\nDEF_ARRAYLIST_OUT(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维动态列表数组作为输出。\n  定义状态变量\nDEF_VAR(T, name, value, desc)\r定义类型为T、名称为name、初值类型为value的单一数据类型作为状态变量。\nDEF_ARRAY_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维数组作为状态变量。\nDEF_ARRAY2D_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的二维数组作为状态变量。\nDEF_ARRAY3D_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的三维数组作为状态变量。\nDEF_INSTANCE_STATE(T, name, desc)\r定义输入类型为T、名称为name的实例作为状态变量。\nDEF_ARRAYLIST_STATE(T, name, device, desc)\r在device（CPU/GPU）设备上定义类型为T、名称为name的一维动态列表数组作为状态变量。\n  创建功能模块\n以RigidBodySystem为例，其构造函数中创建的功能模块如下：\n//创建自碰撞检测模块 auto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;currentTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); this-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(elementQuery); //创建边界包围盒碰撞检测功能模块 auto cdBV = std::make_shared\u0026lt;CollistionDetectionBoundingBox\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;currentTopology()-\u0026gt;connect(cdBV-\u0026gt;inDiscreteElements()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(cdBV); //创建合并触点功能模块 auto merge = std::make_shared\u0026lt;ContactsUnion\u0026lt;TDataType\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(merge-\u0026gt;inContactsA()); cdBV-\u0026gt;outContacts()-\u0026gt;connect(merge-\u0026gt;inContactsB()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(merge); //创建刚体动力学求解模块 auto iterSolver = std::make_shared\u0026lt;IterativeConstraintSolver\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;varTimeStep()-\u0026gt;connect(iterSolver-\u0026gt;inTimeStep()); this-\u0026gt;varFrictionEnabled()-\u0026gt;connect(iterSolver-\u0026gt;varFrictionEnabled()); this-\u0026gt;stateMass()-\u0026gt;connect(iterSolver-\u0026gt;inMass()); this-\u0026gt;stateCenter()-\u0026gt;connect(iterSolver-\u0026gt;inCenter()); this-\u0026gt;stateVelocity()-\u0026gt;connect(iterSolver-\u0026gt;inVelocity()); this-\u0026gt;stateAngularVelocity()-\u0026gt;connect(iterSolver-\u0026gt;inAngularVelocity()); this-\u0026gt;stateRotationMatrix()-\u0026gt;connect(iterSolver-\u0026gt;inRotationMatrix()); this-\u0026gt;stateInertia()-\u0026gt;connect(iterSolver-\u0026gt;inInertia()); this-\u0026gt;stateQuaternion()-\u0026gt;connect(iterSolver-\u0026gt;inQuaternion()); this-\u0026gt;stateInitialInertia()-\u0026gt;connect(iterSolver-\u0026gt;inInitialInertia()); merge-\u0026gt;outContacts()-\u0026gt;connect(iterSolver-\u0026gt;inContacts()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(iterSolver);   节点构造函数仅包含默认管线，管线功能模块可在外部进行动态添加和删除，详情参加examples/GL_ParticleFluid样例阐述如何为节点渲染管线添加自动渲染模块。\n\r  重载虚函数\nvirtual void preUpdateStates(); 状态更新前处理函数\nvirtual void updateStates(); 状态更新函数，如子类不重载该函数，默认调用pipeline执行内置算法流程。\nvirtual void postUpdateStates(); 状态更新后处理函数\n  3、QT GUI视图 一个节点对应的GUI视图由两部分组成，即Node Editor视图和Property Editor视图。\nNode Editor主要展示节点对应的输入和输出，支持利用鼠标进行数据之间的连接和断开连接操作，典型视图如下：\nProperty Editor窗口则显示每个节点的状态变量以及控制参数信息。例如，当鼠标单击StaticBoundary节点时，Property Editor窗口显示的属性信息如下图所示： （1）控制变量 控制变量用于展示通过Fvar定义的变量，根据变量数据类型的差异，Property Editor窗口可以显示不同的空间实现对控制变量进行更改。\n  bool\n例如当FVar中Visible勾选时，仿真过程中，将会把该节点渲染出来；如果取消勾选，则仿真过程中，不会渲染该节点。\n  float或者double\n  Vec3f或者Vec3d\n  FilePath\n其中FilePath对应系统路径，用于支持文件读取等功能。\n  （2）状态变量 FState属性允许将Node Editor窗口中，节点FState类型的属性信息显示和隐藏。例如，ParticleFluid节点把Velocity属性勾选时，Node Editor窗口中对应输出会增加Velocity属性，从而使Velocity可以作为其他节点输入使用。 "
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/",
	"title": "管线",
	"tags": [],
	"description": "",
	"content": "1、什么是管线 PeriDyno中的管线代表模块的集合,其通过模块间的数据连接实现模块的依次调用，并最终实现节点的状态变量更新或者为渲染及后处理提供输出数据。\n相比如其他管线（如OpenGL管线），PeriDyno管线具备如下特点：\n 管线入口：统一以节点的状态变量作为管线入口，支持直接对模块状态变量的更新； 模块类型：管线支持的功能模块既可以是仿真计算模块，也可以是渲染模块或者交互模块，不同功能模块可以自由排列和组合，从而支持复杂实时可交互场景的建模与仿真； 管线类型：当前实现支持仿真管线和渲染管线两种 更新机制：利用Field的tick()、tack()机制实现数据时间戳同步，保证每个模块只在输入数据或者控制变量更新之后才执行，从而降低冗余计算，具体参见数据更新。  以刚体动力学为例，其仿真管线的可视化效果图如下：\n2、管线功能 管线继承自模块（Module），其继承Module的功能之外（如数据管理），具备如下管线特有功能：\n  添加模块\nvoid pushModule(std::shared_ptr\u0026lt;Module\u0026gt; m);   删除模块\nvoid popModule(std::shared_ptr\u0026lt;Module\u0026gt; m);   更新模块序列\nvoid updateExecutionQueue(); 该部分算法通过调用有向无环图的拓扑排序（Topological Sorting）实现。\n  启用/禁用管线\nvoid enable(); void disable();   导出模块输出到节点输出\nvoid promoteOutputToNode(FBase* base);   撤销模块输出\nvoid demoteOutputFromNode(FBase* base); \r更多管线实现细节，参加 src/Framework/Module/Pipeline.h(cpp)实现。\n\r  "
},
{
	"uri": "https://peridyno.github.io/zh/examples/rigidbody/",
	"title": "刚体动力学",
	"tags": [],
	"description": "",
	"content": "1、刚体动力学 刚体动系统已经包含球体、圆柱体、圆锥体、长方体等常用的几何体仿真模型。用户只需要通过设置几何形体的中心位置、边长以及旋转矩阵等简单的参数就可以构成出常见的几何模型。同时刚体动力学支持三维几何模型碰撞掩码功能，能屏蔽指定形状的几何体碰撞，支持几何基本单元之间的接触点、接触点法向和穿透距离等计算。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建刚体模型，包括正方体、四面体和球体：  auto rigid = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.5, 0, 0); BoxInfo box; for (int i = 8; i \u0026gt; 1; i--) for (int j = 0; j \u0026lt; i + 1; j++) { box.center = 0.5f * Vec3f(0.5f, 1.1 - 0.13 * i, 0.12f + 0.21 * j + 0.1 * (8 - i)); box.halfLength = 0.5f * Vec3f(0.065, 0.065, 0.1); rigid-\u0026gt;addBox(box, rigidBody); } SphereInfo sphere; sphere.center = Vec3f(0.5f, 0.75f, 0.5f); sphere.radius = 0.025f; RigidBodyInfo rigidSphere; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.95f, 0.5f); sphere.radius = 0.025f; rigid-\u0026gt;addSphere(sphere, rigidSphere); sphere.center = Vec3f(0.5f, 0.65f, 0.5f); sphere.radius = 0.05f; rigid-\u0026gt;addSphere(sphere, rigidSphere); TetInfo tet; tet.v[0] = Vec3f(0.5f, 1.1f, 0.5f); tet.v[1] = Vec3f(0.5f, 1.2f, 0.5f); tet.v[2] = Vec3f(0.6f, 1.1f, 0.5f); tet.v[3] = Vec3f(0.5f, 1.1f, 0.6f); rigid-\u0026gt;addTet(tet, rigidSphere);  创建渲染节点：  auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender);  创建触点接触计算节点：  //TODO: to enable using internal modules inside a node \t//Visualize contact normals \tauto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); rigid-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(elementQuery); auto contactMapper = std::make_shared\u0026lt;ContactsToEdgeSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactMapper-\u0026gt;inContacts()); contactMapper-\u0026gt;varScale()-\u0026gt;setValue(0.02); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactMapper); auto wireRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); wireRender-\u0026gt;setColor(Vec3f(0, 1, 0)); contactMapper-\u0026gt;outEdgeSet()-\u0026gt;connect(wireRender-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(wireRender); //Visualize contact points \tauto contactPointMapper = std::make_shared\u0026lt;ContactsToPointSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactPointMapper-\u0026gt;inContacts()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactPointMapper); auto pointRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); pointRender-\u0026gt;setColor(Vec3f(1, 0, 0)); contactPointMapper-\u0026gt;outPointSet()-\u0026gt;connect(pointRender-\u0026gt;inPointSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(pointRender); 3、仿真效果如下： 代码参考example/GL_Rigidbody/main.h: 刚体间的碰撞效果如下图所示： 几何模型碰撞掩码功能，屏蔽指定形状的几何体碰撞。如下图所示，屏蔽正方体模型发生碰撞： "
},
{
	"uri": "https://peridyno.github.io/zh/framework/pipeline/fieldsync/",
	"title": "数据同步",
	"tags": [],
	"description": "",
	"content": "1、Field数据同步 为了有效实现数据的同步，避免冗余的计算开销，PeriDyno引入时间戳的概念，其通过维护一个全局变量的计数器来记录数据修改的时间，具体实现如下：\nclass TimeStamp { public: TimeStamp() {}; ~TimeStamp(); void mark(); bool operator \u0026gt; (TimeStamp\u0026amp; ts) { return (mTickTime \u0026gt; ts.mTickTime); } bool operator \u0026lt; (TimeStamp\u0026amp; ts) { return (mTickTime \u0026lt; ts.mTickTime); } private: uint64 mTickTime = 0; }; 此外，每个Field维护两个时间戳并分别用tick()和tack()接口函数进行标记\nvoid tick();\rvoid tack();\r其中tick()函数表示数据更新的时间，tack()则表示为数据使用的时间。\n以下图为例，当Module 1更新完之后，依次调用所有输出数据的tick()接口记录Field 8的更新时间。Module 2执行过程首先进行Field 9的tack时间与Field 8的tick时间进行比较，只有当Field 9的tack时间早于Field 8的tick才执行Module 2内部算法，完成Module 2状态标量的更新。当Module 2完成更新之后首先调用所有输入Field的tack()函数标记使用时间，然后再调用所有输出Field的tick()函数标记数据修改时间，从而完成模块更新。 当检测到Field 9的tack时间不早于Field 8的tick时间时，Module 2不需要更新因此会跳过执行。\n\r2、管线数据同步 多线程运行环境下，位置仿真管线和渲染管线可能存在读写冲突，PeriDyno通过互斥锁来实现管线之间的数据同步。\n如上图所示，渲染管线与仿真管线分别运行独立线程。当渲染需要更新数据时，其需要尝试锁住仿真管线。只有当仿真管线被锁之后，渲染管线才能调用SceneGraph的updateGraphicsContext()函数更新渲染数据。更新完了之后释放互斥锁，仿真管线恢复运行。\n上述同步机制的设计主要为了充分保证渲染和交互的流畅性，防止进程因为仿真计算任务过大而出现卡死的情况。\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/modules/",
	"title": "模块",
	"tags": [],
	"description": "",
	"content": "1、功能简介 模块定义为供节点内部调用的功能独立的算法单元，其由输入数据、输出数据和控制变量构成。其与节点最大的差别在于输入输出类型只接受Field类型。\n2、如何实现一个功能模块 其包含如下步骤：\n  定义输入数据（通常至少要求一个）\n与节点中定义类似，采用DEF_{*}_IN的宏定义完成。\n  定义输出数据（可选）\n与节点中定义类似，采用DEF_{*}_OUT的宏定义完成。\n  定义控制变量\n与节点中定义类似，采用DEF_VAR的宏定义完成。\n控制变量必须在模块执行之前完成初始化。\n\r  重载模块函数\n重载接口有特定模块类型决定，详情参加src/Framework/Module相应模块。\n\r  3、模块样例 /** * @brief The standard summation density * * @tparam TDataType */ template\u0026lt;typename TDataType\u0026gt; class SummationDensity : public virtual ParticleApproximation\u0026lt;TDataType\u0026gt; { DECLARE_TCLASS(SummationDensity, TDataType) public: typedef typename TDataType::Real Real; typedef typename TDataType::Coord Coord; SummationDensity(); ~SummationDensity() override {}; void compute() override; public: void compute( DArray\u0026lt;Real\u0026gt;\u0026amp; rho, DArray\u0026lt;Coord\u0026gt;\u0026amp; pos, DArrayList\u0026lt;int\u0026gt;\u0026amp; neighbors, Real smoothingLength, Real mass); void compute( DArray\u0026lt;Real\u0026gt;\u0026amp; rho, DArray\u0026lt;Coord\u0026gt;\u0026amp; pos, DArray\u0026lt;Coord\u0026gt;\u0026amp; posQueried, DArrayList\u0026lt;int\u0026gt;\u0026amp; neighbors, Real smoothingLength, Real mass); public: DEF_VAR(Real, RestDensity, 1000, \u0026#34;Rest Density\u0026#34;); ///Define inputs \t/** * @brief Particle positions */ DEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Particle position\u0026#34;); /** * @brief Particle positions */ DEF_ARRAY_IN(Coord, Other, DeviceType::GPU, \u0026#34;Particle position\u0026#34;); /** * @brief Neighboring particles * */ DEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;Neighboring particles\u0026#39; ids\u0026#34;); ///Define outputs \t/** * @brief Particle densities */ DEF_ARRAY_OUT(Real, Density, DeviceType::GPU, \u0026#34;Return the particle density\u0026#34;); private: void calculateParticleMass(); Real m_particle_mass; Real m_factor; }; IMPLEMENT_TCLASS(SummationDensity, TDataType) 4、QT GUI视图 鼠标双击Node Editor窗口中的节点，会出现该节点更为详细的属性信息。例如，双击ParticleFluid节点后，其详细的属性信息如下图所示： "
},
{
	"uri": "https://peridyno.github.io/zh/framework/",
	"title": "引擎架构",
	"tags": [],
	"description": "PeriDyno 框架细节介绍。
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/zh/framework/interaction/",
	"title": "交互",
	"tags": [],
	"description": "",
	"content": "1、PeriDyno中仿真、渲染与交互的关系 为保证架构上的统一，PeriDyno将任意交互行为抽象为功能模块，并嵌入每个节点的仿真管线和渲染管线来完成一些较为复杂场景的建模。针对PC环境，典型的交互模块包括如下三类：\n 鼠标交互 键盘交互 算法交互  下图展示了一个典型的带仿真、渲染以及交互功能节点。\n其中的交互模块可以是鼠标交互、键盘交互或者是算法交互，同时注意到渲染交互模块既然可以嵌入管线也可以嵌入渲染关系分别用于辅助仿真计算和渲染。\n2、仿真、渲染与交互运行时序图 以GLFW为例，PeriDyno中仿真、渲染和交互的模块调用时序图如下：\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/collision/",
	"title": "碰撞检测",
	"tags": [],
	"description": "",
	"content": "1、碰撞检测 碰撞检测算法主要采用检测接触点的方式，给模型的边界添加不同的触点。通过触点的接触位置来检测物体是否发生碰撞。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  两个刚体节点：  auto rigid = scn-\u0026gt;addNode(std::make_shared\u0026lt;RigidBodySystem\u0026lt;DataType3f\u0026gt;\u0026gt;()); RigidBodyInfo rigidBody; rigidBody.linearVelocity = Vec3f(0.0, 0, 0); BoxInfo box; box.center = Vec3f(0.5, 0.1, 0.5); box.halfLength = Vec3f(0.1, 0.1, 0.1); rigid-\u0026gt;addBox(box, rigidBody); box.center = Vec3f(0.5, 0.3, 0.59); box.halfLength = Vec3f(0.1, 0.1, 0.1); rigid-\u0026gt;addBox(box, rigidBody);  创建渲染节点：  auto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;currentTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); //TODO: to enable using internal modules inside a node \tauto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;currentTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); rigid-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(elementQuery);  创建触点的接触计算节点：  auto contactMapper = std::make_shared\u0026lt;ContactsToEdgeSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(contactMapper-\u0026gt;inContacts()); contactMapper-\u0026gt;varScale()-\u0026gt;setValue(0.02); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(contactMapper); auto wireRender = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); wireRender-\u0026gt;setColor(Vec3f(0, 1, 0)); contactMapper-\u0026gt;outEdgeSet()-\u0026gt;connect(wireRender-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(wireRender); 3、仿真效果 代码参考example/RigidBody/GL_TwoTets/main.h:\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/",
	"title": "技术专题",
	"tags": [],
	"description": "",
	"content": "技术专题主要分为如下几类：\n  粒子系统: 主要介绍基于PBD、SPH的流体仿真；\n  刚体动力学: 介绍刚体动力学相关算法；\n  弹性模拟：主要介绍基于FEM、peridynamics的弹性材料仿真算法；\n  高度场: 基于高度场实现的海洋模拟、浅水波方程等；\n  离线渲染与后处理：介绍peridyno的后处理。\n  "
},
{
	"uri": "https://peridyno.github.io/zh/framework/scenegraph/fields/",
	"title": "数据",
	"tags": [],
	"description": "",
	"content": "1、Field功能简介 Field是对基本数据类型的封装，从而实现节点以及模块之间的数据传递。典型的数据类型包含如下几类：\n 基本类型：指数据量比较小，可以在CPU和GPU进行直接传递的数据，典型的包括bool、int、float、double等标量数据以及Vec3f、Vec3d、Mat3f、Mat3d等张量数据，Field可通过FVar来完成数据的定义和传递； 静态数组：指数据尺寸固定的连续存储空间，包括一维数组、二维数组、三维数组等，Field宏定义采用DEF_ARRAY{2D, 3D}_{*}等宏定义。 动态数组：指数据尺寸动态变化的连续存储空间，包括List、Map、Set、MultiSet、Pair、Stack等类型的数组表示，Field宏定义采用DEF_ARRAYLIST_{*}完成定义。 引用类型：针对复杂类型，采用类似C++指针的方式进行定义的数据，Field宏定义采用DEF_INSTANCE_{*}完成定义。  Field之间的连接和断开主要依赖以下两个函数实现，链接过程中会进行数据有效性验证，如有效则返回true，否则返回false。\nvirtual bool connect(FBase* dst) = 0; virtual bool disconnect(FBase* dst); FBase作为所有Field的基类，其功能主要是对Field的连接状态进行统一管理\nconnect(FBase* dst)在FBase中被定义了纯虚函数，因而其具体实现依赖于特定Field，该设计主要为了保证对数据连接进行有效性验证，仿真将数据连接到错误的类型。\n\r假设存在A、B、C三个Field类型数据，他们的连接关系设置为A-\u0026gt;B-\u0026gt;C。此时为了降低数据转换和存储开销，当我们对C的数据进行操作时，其会根据连接关系返回最顶端（这里对应的是A）的数据指针进行操作。\n2、Field数据类型   FVar：继承自FBase，是对单一数据类型的封装，包括标量数据，如int、float、double；矢量数据，如Vec3f；以及二阶张量，如Mat3f；文件路径类型FilePath。节点和模块中可以通过使用DEF_VAR/DEF_VAR_IN等宏定义来进行定义\nDEF_VAR(Real, TangentialFriction, 0.0, \u0026#34;Tangential friction\u0026#34;); 其中Real代表数据类型，TangentialFriction代表数据名称，0.0代表初值，\u0026ldquo;Tangential friction\u0026quot;则表示数据的说明。通过DEF_VAR定义的数据实际使用过程中可以通var+数据名称的方式对数据进行操作，假设我们需要将上述Field连接到另一个功能模块，则可以调用如下接口进行：\nthis-\u0026gt;varRestDensity()-\u0026gt;connect(...);\r常见数据类型的C++定义及GUI视图如下\n（1）FVar，int类型：\nC++视图\nDEF_VAR(int, Types, 4, \u0026#34;winds Types\u0026#34;); Qt视图\n（2）FVar，float类型：\nC++视图\nDEF_VAR_IN(Real, Radius, \u0026#34;Search radius\u0026#34;); 在Qt界面中，float类型显示如下： Qt视图\n（3）FVar，bool类型：\nC++视图\nDEF_VAR(bool, Active, true, \u0026#34;Indicating whether the simulation is on for this node!\u0026#34;); Qt视图 （4）FVar，FilePath类型：\nC++视图\nDEF_VAR(FilePath, FileName, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); Qt视图 （5）FVar，Vec3f类型：\nC++视图\nDEF_VAR(Vec3f, Location, 0, \u0026#34;Node location\u0026#34;); Qt视图 （6）FVar，PEnum数据：主要为了枚举数据类型。通过DEF_ENUM定义的数据，实际使用过程中可以通var+数据名称的方式对数据进行操作。ENUM类型定义如下：\nC++视图\nDECLARE_ENUM(EKernelType, KT_Smooth = 0, KT_Spiky = 1); DEF_ENUM(EKernelType, KernelType, EKernelType::KT_Spiky, \u0026#34;Rendering mode\u0026#34;); Qt视图： 参数类型为int、uint、Vec3f、Vec3d的FVar数据需要调用setRange设置数据的有效范围，否则Qt界面可能会显示异常。\n\r  FArray：对Core/Array.h中定义的一维数组的封装，类似于STL中的vector。根据其在节点/模块中的不同功能，我们采用如下三种定义：\nDEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//输入 输入数据的访问方式为in+数据名称，即inPosition()\nDEF_ARRAY_OUT(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//输出 输入数据的访问方式为out+数据名称，即outPosition()\nDEF_ARRAY_STATE(Coord, Position, DeviceType::GPU, \u0026#34;Internal state\u0026#34;);\t//内部状态变量 状态变量的访问方式为state+数据名称，statePosition()\n  FArrayList：对Core/ArrayList.h数据的封装，用于支持CPU/GPU兼容的动态数据类型。其定义方式与FArray类似，即\nDEF_ARRAYLIST_IN(Coord, Position, DeviceType::GPU, \u0026#34;Input\u0026#34;);\t//输入 输入数据的访问方式为in+数据名称，即inPosition()\nDEF_ARRAYLIST_OUT(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//输出 输入数据的访问方式为out+数据名称，即outPosition()\nDEF_ARRAYLIST_STATE(Coord, Position, DeviceType::GPU, \u0026#34;Internal state\u0026#34;);\t//内部状态变量 状态变量的访问方式为state+数据名称，statePosition()\n  FInstance：主要为了支持存在继承关系的数据之间的连接，典型应用为利用FInstance定义不同拓扑结构数据\nDEF_INSTANCE_IN(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;PointSet is derived from TopologyModule\u0026#34;);\t//输入 输入数据的访问方式为in+数据名称，任意继承自PointSet的对应都可以连接到该数据。\nDEF_INSTANCE_OUT(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;Output\u0026#34;);\t//输出 输入数据的访问方式为out+数据名称\nDEF_INSTANCE_STATE(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;Internal state\u0026#34;);\t//内部状态变量 状态变量的访问方式为state+数据名称，在Qt界面中，显示如下：   "
},
{
	"uri": "https://peridyno.github.io/zh/examples/particlefluid/",
	"title": "基于粒子的流体模拟",
	"tags": [],
	"description": "",
	"content": "1、基于粒子的流体模拟 该方法将连续的流体用相互作用的粒子来描述，各个粒子上承载各种物理量，包括质量、速度和压强等。通过求解粒子的动力学方程，并跟踪每个粒子的运动轨迹，求得整个系统的力学行为。理论上，只要粒子的数量足够多的，就能精确地描述力学过程。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真边界以及粒子流体节点，这里的边界是一个静态的碗模型：  auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); ; boundary-\u0026gt;loadCube(Vec3f(-0.5, 0, -0.5), Vec3f(1.5, 2, 1.5), 0.02, true); boundary-\u0026gt;loadSDF(\u0026#34;../../data/bowl/bowl.sdf\u0026#34;, false); auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(0.5, 0.2, 0.4), Vec3f(0.7, 1.5, 0.6), 0.005); fluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems());  计算法线：  auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm);  创建渲染节点：  auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); ptRender-\u0026gt;setColorMapRange(0, 5); fluid-\u0026gt;currentTopology()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender);  创建一个colorBar，在显示的时候，会将不同速度的粒子渲染成不同的颜色：  // A simple color bar widget for node \tauto colorBar = std::make_shared\u0026lt;ImColorbar\u0026gt;(); colorBar-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorBar-\u0026gt;inScalar()); // add the widget to app \tfluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorBar); 3、仿真效果 代码参考example/GL_ParticleFluid/main.h: "
},
{
	"uri": "https://peridyno.github.io/zh/examples/",
	"title": "仿真案例",
	"tags": [],
	"description": "A set of examples guiding users on how to set up different case
",
	"content": "仿真案例主要介绍普通场景的搭建，包括布料、弹性体、流体、刚体、高度场以及鼠标交互等。让用户能快速熟悉peridyno引擎：\n  布料仿真: 模拟布料材料\n  弹性体仿真：模拟弹性体材料\n  刚体动力学: 模拟刚体运动\n  碰撞检测：刚体运动碰撞处理\n  基于粒子的流体模拟: 基于粒子的流体模拟\n  粒子发射器：模拟基于粒子的流体发射器\n  塑性材料: 模拟塑性材料\n  实例化模型：介绍如何在peridyno创建实例\n  鼠标交互: 鼠标交互示例\n  基于高度场的海洋模拟：使用高度场技术模拟海洋\n  "
},
{
	"uri": "https://peridyno.github.io/zh/framework/rendering/",
	"title": "渲染",
	"tags": [],
	"description": "",
	"content": "1、功能简介 PERIDYNO通过渲染模块提供对场景图中各类节点的基础可视化功能。\nclass VisualModule : public Module 目前PERIDYNO实现了一套基础OpenGL的渲染引擎及对应的各类节点（Nodes）的渲染模块，以提供对于所支持的用户图像界面（Qt/GLFW）的可视化与交互支持。\n2、使用渲染模块 在PERIDYNO用户图形界面框架（Qt/GLFW）下，通过对渲染模块的配置并将其加入到目标节点的图形管线（graphicsPipeline）中实现节点的可视化。\n表面三角网格可视化（GLSurfaceVisualModule） 参考代码examples/GL_Bricks/main.cpp。\n\rPERIDYNO提供GLSurfaceVisualModule来实现物体表面的渲染。以刚体系统为例，为了渲染物体，首先需要通过拓扑映射（TopologyMapping）将数据映射成为可渲染的三角片网格。\nauto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); 如上所示，首先构造DiscreteElementsToTriangleSet对象，并将刚体系统（rigid）的对应数据连接至mapper的输入；再将mapper对象加入到rigid对象的图形管线中，以便在调用图形管线时对内容进行更新。在构造好映射对象mapper后，我们就可以使用GLSurfaceVisualModule，通过将mapper输出到渲染模块来实现当前节点的可视化：\nauto renderModule = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); renderModule-\u0026gt;setColor(Vec3f(1, 1, 0)); // 配置可视化数据来源 mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(renderModule-\u0026gt;inTriangleSet()); // 将渲染模块加入到对应节点的图形管线中 rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(renderModule); 粒子（点）可视化（GLPointVisualModule） 参考代码examples/GL_ParticleFluid/main.cpp。\n\r与GLSurfaceVisualModule相同，我们首先需要构造对应的映射（mapper）。例如我们首先从流体粒子的速度计算出法向量，再通过法向量来得到所需要展示的粒子的颜色：\nauto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); auto colorMapper = std::make_shared\u0026lt;ColorMapping\u0026lt;DataType3f\u0026gt;\u0026gt;(); colorMapper-\u0026gt;varMax()-\u0026gt;setValue(5.0f); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); 接着，我们构造GLPointVisualModule，并将流体系统的点与刚才构造的颜色映射进行连接：\nauto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); fluid-\u0026gt;stateTopology()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); 线框可视化（GLWireframeVisualModule） 参考代码examples/GL_Wireframe/main.cpp。\n\r使用GLWireframeVisualModule可对三角形网格的线框进行可视化，使用方法与GLSurfaceVisualModule类似，先进行数据映射，将三角形网格数据连接到可视化模块上即可：\nauto mapper = std::make_shared\u0026lt;DiscreteElementsToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); rigid-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inDiscreteElements()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto wireframe = std::make_shared\u0026lt;GLWireframeVisualModule\u0026gt;(); wireframe-\u0026gt;setColor(Vec3f(1, 1, 0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(wireframe-\u0026gt;inEdgeSet()); rigid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(wireframe); 实例可视化（GLInstanceVisualModule） 参考代码examples/GL_InstanceVisualizer/main.cpp。\n\r在PERIDYNO中，可以通过额外的变换矩阵数组来表示实例化的节点。与其他可视化模块类似，只需要将对应的变换矩阵传给GLInstanceVisualModule：\nauto instanceRender = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); instanceRender-\u0026gt;setColor(Vec3f(0, 1, 0)); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(instanceRender-\u0026gt;inTriangleSet()); instanceNode-\u0026gt;stateTransforms()-\u0026gt;connect(instanceRender-\u0026gt;inTransform()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(instanceRender); 3、扩展渲染模块 PERIDYNO对节点的可视化提供统一父类（GLVisualModule），实现新的可视化效果需继承该类并重载相应的方法。\n参考代码src/Rendering/Engine/OpenGL/GLVisualModule.h\n\rvirtual bool initializeGL() = 0; virtual void updateGL() = 0; virtual void paintGL(RenderPass pass) = 0; 其中，initializeGL()方法在对象初始化时仅被调用一次，通常用于加载对应的Shader，创建所需的Buffer等对象。而每当仿真更新时，updateGL()方法都将被调用，用于同步仿真数据与渲染数据（例如将当前帧修改后的三角形网格更新到OpenGL的VertexBuffer中、更新当前粒子颜色等）。而paintGL在具体执行渲染时被调用。目前PERIDYNO提供的基础OpenGL渲染引擎包含两个简单的RenderPass：ShadowPass和ColorPass，其中ShadowPass用于更新ShadowMap来得到阴影效果，ColorPass用于得到最终窗口中所展示的彩色图像。\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/particleemitter/",
	"title": "粒子发射器",
	"tags": [],
	"description": "",
	"content": "1、粒子发射器 粒子发射器通过限定粒子活动范围的，并给定随机产生的粒子一个初始位移和速度，来模拟流体。发射器是根据每个单独的发射器项的设置在模拟中生成粒子的元素。对于最简单的模拟，需要一个放射状发射器和一个粒子模拟项。粒子发射后与流体相互作用。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建粒子发射器以及粒子流体节点：  //Create a particle emitter \tauto emitter = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleEmitterSquare\u0026lt;DataType3f\u0026gt;\u0026gt;()); emitter-\u0026gt;varLocation()-\u0026gt;setValue(Vec3f(0.5f)); //Create a particle-based fluid solver \tauto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(0.0f), Vec3f(0.2f), 0.005f); emitter-\u0026gt;connect(fluid-\u0026gt;importParticleEmitters());  计算法线：  auto calculateNorm = std::make_shared\u0026lt;CalculateNorm\u0026lt;DataType3f\u0026gt;\u0026gt;(); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm);  创建渲染节点：  auto ptRender = std::make_shared\u0026lt;GLPointVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(1, 0, 0)); ptRender-\u0026gt;setColorMapMode(GLPointVisualModule::PER_VERTEX_SHADER); ptRender-\u0026gt;setColorMapRange(0, 5); fluid-\u0026gt;stateVelocity()-\u0026gt;connect(calculateNorm-\u0026gt;inVec()); fluid-\u0026gt;currentTopology()-\u0026gt;connect(ptRender-\u0026gt;inPointSet()); calculateNorm-\u0026gt;outNorm()-\u0026gt;connect(colorMapper-\u0026gt;inScalar()); colorMapper-\u0026gt;outColor()-\u0026gt;connect(ptRender-\u0026gt;inColor()); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(calculateNorm); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(colorMapper); fluid-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender);  创建矩形边界：  auto container = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); container-\u0026gt;loadCube(Vec3f(0.0f), Vec3f(1.0), 0.02, true); fluid-\u0026gt;connect(container-\u0026gt;importParticleSystems()); 3、仿真效果 在仿真中间创建了一个粒子发射器，粒子发射器和地面的流体发生作用。代码参考example/GL_ParticleFluid/main.h:\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/plasticity/",
	"title": "塑性材料",
	"tags": [],
	"description": "",
	"content": "1、塑性材料 塑性材料在发生小应变时，材料性质基本为线弹性，弹性模量为常数；当应力超过屈服应力后，刚度会显著下降。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建边界以及两个塑性节点：  //Create a particle emitter \tauto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadCube(Vec3f(0), Vec3f(1), 0.005, true); auto elastoplasticBody = scn-\u0026gt;addNode(std::make_shared\u0026lt;ElastoplasticBody\u0026lt;DataType3f\u0026gt;\u0026gt;()); elastoplasticBody-\u0026gt;connect(boundary-\u0026gt;importParticleSystems()); elastoplasticBody-\u0026gt;setVisible(false); elastoplasticBody-\u0026gt;loadParticles(Vec3f(-1.1), Vec3f(1.15), 0.1); elastoplasticBody-\u0026gt;loadSurface(\u0026#34;../../data/standard/standard_cube20.obj\u0026#34;); elastoplasticBody-\u0026gt;scale(0.05); elastoplasticBody-\u0026gt;translate(Vec3f(0.3, 0.2, 0.5)); elastoplasticBody-\u0026gt;getSurfaceNode()-\u0026gt;setVisible(true); auto elasticBody = scn-\u0026gt;addNode(std::make_shared\u0026lt;ElasticBody\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;addParticleSystem(elasticBody); elasticBody-\u0026gt;setVisible(false); elasticBody-\u0026gt;loadParticles(Vec3f(-1.1), Vec3f(1.15), 0.1); elasticBody-\u0026gt;loadSurface(\u0026#34;../../data/standard/standard_cube20.obj\u0026#34;); elasticBody-\u0026gt;scale(0.05); elasticBody-\u0026gt;translate(Vec3f(0.5, 0.2, 0.5));  对两个塑性节点分别创建渲染节点：  auto ptRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); ptRender-\u0026gt;setColor(Vec3f(0, 1, 1)); elastoplasticBody-\u0026gt;getSurfaceNode()-\u0026gt;currentTopology()-\u0026gt;connect(ptRender-\u0026gt;inTriangleSet()); elastoplasticBody-\u0026gt;getSurfaceNode()-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(ptRender); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(1, 1, 1)); elasticBody-\u0026gt;getSurfaceNode()-\u0026gt;currentTopology()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); elasticBody-\u0026gt;getSurfaceNode()-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); 3、仿真效果 如下图所示，当塑性材料从空中坠落到地面之后，发生塑性形变。代码参考example/GL_Plasticity/main.h: "
},
{
	"uri": "https://peridyno.github.io/zh/reference/",
	"title": "相关资料",
	"tags": [],
	"description": "External resources related to physical-based simulations.
",
	"content": "扩展阅读： 如何实现C++反射\n参考文献（待补充）\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/instancevisualizer/",
	"title": "实例化模型",
	"tags": [],
	"description": "",
	"content": "1、实例化模型 peridyno允许用户自定义实例节点，该节点只需继承Node节点。用户可以在节点中加载obj模型，并可以使用代码对模型进行位置，尺寸及旋转进行定义。\n2、创建过程  自定义Instance类，该类继承于Node节点  class Instances : public Node  通过this-\u0026gt;stateTransforms()-\u0026gt;allocate()-\u0026gt;assign()函数设置模型的位置，尺寸，旋转等变换。  Transform3f tm; CArray\u0026lt;Transform3f\u0026gt; hTransform; for (uint i = 0; i \u0026lt; 5; i++) { tm.translation() = Vec3f(0.4 * i, 0, 0); tm.scale() = Vec3f(1.0 + 0.1*i, 1.0 - 0.1*i, 1.0); tm.rotation() = Quat\u0026lt;float\u0026gt;(i * (-0.2), Vec3f(1, 0, 0)).toMatrix3x3(); hTransform.pushBack(tm); } this-\u0026gt;stateTransforms()-\u0026gt;allocate()-\u0026gt;assign(hTransform);  加载obj模型，并绑定拓扑结构：  std::shared_ptr\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt; triSet = std::make_shared\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); triSet-\u0026gt;loadObjFile(\u0026#34;../../data/armadillo/armadillo.obj\u0026#34;); this-\u0026gt;stateTopology()-\u0026gt;setDataPtr(triSet); hTransform.clear(); DEF_ARRAY_STATE(Transform3f, Transforms, DeviceType::GPU, \u0026#34;Instance transform\u0026#34;); DEF_INSTANCE_STATE(TopologyModule, Topology, \u0026#34;Topology\u0026#34;); 3、仿真效果 代码参考example/GL_InstanceVisualizer/main.h: "
},
{
	"uri": "https://peridyno.github.io/zh/contributing/",
	"title": "贡献",
	"tags": [],
	"description": "See the list of contributors.
",
	"content": "接下来介绍如何向我们的开源项目做出贡献\n1、安装Hugo 你需要下一个较新的extended版本 (推荐0.53以上) 的 Hugo。 确保下载的是extended版的hugo,千万不要下载relese版的Hugo,因为它不支持 SCSS.\n有关全面的 Hugo开发文档，请参阅 gohugo.io。\n查看是否已经安装hugo ,或查看hugo安装的版本，请运行以下命令：\nhugo version\r2、不同平台的安装   windows平台\n（1）下载 hugo extended 版\n点击 hugo下载 下载。记得下载extended 版。例如，64位的windows系统可以下载hugo_extended_0.75.1_Windows-64bit.zip.\n（2）配置环境变量\n将hugo.exe加入windows系统环境变量，记得路径中不要有空格，否则出现一些奇奇怪怪的错误。例如，路径D:\\Hugo\\bin是正确的。D:\\Program Files (x86)\\Hugo\\bin就不正确。\n  Linux平台 不要使用 sudo apt-get install hugo来安装hugo, 因为这样不会安装hugo extended 版。\n如果您已经安装了hugo，可以通过以下指令查看您安装的版本:\nhugo version\r如果您安装的是 v0.52 或更早的版本。那您需要更新hugo：\n  下载Hugo\n  找到Hugo extended版\n  下载(例如：hugo_extended_0.5X_Linux-64bit.tar.gz).\n  创建一个文件夹:\nmkdir hugo\r   加压下载的hugo压缩包。\n  进入该文件夹:\ncd hugo\r   安装hugo:\nsudo install hugo /usr/bin      macOS平台\n使用 Brew安装hugo。\n  3、安装 Node.js 和 npm 如果您已经安装了Node.js和npm, 通过以下指令可以查看当前的版本：\nnode -v\rnpm -v\r点击 下载 Node.js并安装。\n4、安装 PostCSS 安装了最新Node.js后，通过命令行可以安装 PostCSS:\nnpm install postcss --save-dev\rnpm install -D --save autoprefixer\rnpm install -D --save postcss-cli\r5、克隆 Peridyno-docs 网站代码   使用git 克隆网站源码:\ngit clone https://github.com/peridyno/peri-docs.git\r   进入文件夹:\ncd peri-docs\r   运行完整:\nhugo server\r   在浏览器中输入 http://localhost:1313/ 就能访问peridyno本地网站。通过 Ctrl + c 来关闭。\n在windows的cmd中，进入当前文件夹，输入hugo server启动本地服务器。\n6、Pull requests指令 最后，您可以在我们的 github 存储库中发出“Pull requests”指令。 感谢您对 Peridyno 开源项目的贡献！\n7、发布Peridyno网站   生成public文件夹\n cd peridyno-doc\rhugo\r   推送项目文件（如果有权限的话）\n cd public git init\rgit add -A\rgit commit -am \u0026quot;init\u0026quot;\rgit remote add origin https://github.com/peridyno/peri-docs.github.io\rgit push -f origin master\r   修改域名（如果有权限的话）\n 在 peridynoTeam.github.io 项目设置（https://github.com/peridyno/peri-docs.github.io/settings）中自定义域中添加“www.peridyno.com”。\r等待几分钟，您可以在 `www.peridyno.com` 上看到 Peridyno 网站。\r   如果您觉得我们这个项目有意义，那就加入我们吧!!!\n\r"
},
{
	"uri": "https://peridyno.github.io/zh/examples/mouseinteraction/",
	"title": "鼠标交互",
	"tags": [],
	"description": "",
	"content": "1、鼠标交互 该功能主要用于相应鼠标事件，包括鼠标移动、点击和释放。当鼠标发出不同指令时，程序会调用不同的接口，便于用户和仿真程序的交互。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建仿真实例模型：  auto instanceNode = scn-\u0026gt;addNode(std::make_shared\u0026lt;Instances\u0026gt;()); class Instances : public Node { public: Instances() { Transform3f tm; CArray\u0026lt;Transform3f\u0026gt; hTransform; for (uint i = 0; i \u0026lt; 5; i++) { tm.translation() = Vec3f(0.4 * i, 0, 0); tm.scale() = Vec3f(1.0 + 0.1*i, 1.0 - 0.1*i, 1.0); tm.rotation() = Quat\u0026lt;float\u0026gt;(i * (-0.2), Vec3f(1, 0, 0)).toMatrix3x3(); hTransform.pushBack(tm); } this-\u0026gt;stateTransforms()-\u0026gt;allocate()-\u0026gt;assign(hTransform); std::shared_ptr\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt; triSet = std::make_shared\u0026lt;TriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); triSet-\u0026gt;loadObjFile(getAssetPath() + \u0026#34;armadillo/armadillo.obj\u0026#34;); this-\u0026gt;stateTopology()-\u0026gt;setDataPtr(triSet); hTransform.clear(); }; DEF_ARRAY_STATE(Transform3f, Transforms, DeviceType::GPU, \u0026#34;Instance transform\u0026#34;); DEF_INSTANCE_STATE(TopologyModule, Topology, \u0026#34;Topology\u0026#34;); };  创建鼠标交互相应节点：  //Create a CustomMouseInteraction object to handle the mouse event, \t//Press/release the mouse button to show the information \tauto mouseInterator = std::make_shared\u0026lt;CustomMouseInteraction\u0026gt;(); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(mouseInterator-\u0026gt;inTopology()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mouseInterator);  创建渲染节点及边界：  auto instanceRender = std::make_shared\u0026lt;GLInstanceVisualModule\u0026gt;(); instanceRender-\u0026gt;setColor(Vec3f(0, 1, 0)); instanceNode-\u0026gt;stateTopology()-\u0026gt;connect(instanceRender-\u0026gt;inTriangleSet()); instanceNode-\u0026gt;stateTransforms()-\u0026gt;connect(instanceRender-\u0026gt;inTransform()); instanceNode-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(instanceRender); scn-\u0026gt;setUpperBound({ 4, 4, 4 }); 3、仿真效果 如图所示，当鼠标在仿真界面移动、点击时，程序会打印出相应的状态、位置坐标等信息。代码参考example/GL_MouseInteractionInGraphicsPipeline/main.h:\n"
},
{
	"uri": "https://peridyno.github.io/zh/examples/heightfield/",
	"title": "基于高度场的海洋模拟",
	"tags": [],
	"description": "",
	"content": "1、布料模拟 基于二维高度场的网格流体模拟方法，该方法把水面表示成为一个连续的平面网格，生成一系列对应于这张网络的连续的高度纹理－称为高度图，每个网格顶点对应于一个高度图的像素，作为水面高度，从而表示出整个水面。\n2、程序实现  创建场景图:  std::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();  创建海洋节点，其中通过多个oceanPatch组合成一个大的Ocean。capillaryWave是用于模拟水上的波纹。  auto root = scn-\u0026gt;addNode(std::make_shared\u0026lt;Ocean\u0026lt;DataType3f\u0026gt;\u0026gt;()); auto oceanPatch = scn-\u0026gt;addNode(std::make_shared\u0026lt;OceanPatch\u0026lt;DataType3f\u0026gt;\u0026gt;(512, 512, 4)); oceanPatch-\u0026gt;connect(root-\u0026gt;importOceanPatch()); auto capillaryWave = scn-\u0026gt;addNode(std::make_shared\u0026lt;CapillaryWave\u0026lt;DataType3f\u0026gt;\u0026gt;(512, 512.0f)); capillaryWave-\u0026gt;connect(root-\u0026gt;importCapillaryWaves());  创建渲染节点：  auto mapper = std::make_shared\u0026lt;HeightFieldToTriangleSet\u0026lt;DataType3f\u0026gt;\u0026gt;(); mapper-\u0026gt;varScale()-\u0026gt;setValue(0.01); mapper-\u0026gt;varTranslation()-\u0026gt;setValue(Vec3f(0, 0.2, 0)); root-\u0026gt;stateTopology()-\u0026gt;connect(mapper-\u0026gt;inHeightField()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(mapper); auto sRender = std::make_shared\u0026lt;GLSurfaceVisualModule\u0026gt;(); sRender-\u0026gt;setColor(Vec3f(0, 0.2, 1.0)); mapper-\u0026gt;outTriangleSet()-\u0026gt;connect(sRender-\u0026gt;inTriangleSet()); root-\u0026gt;graphicsPipeline()-\u0026gt;pushModule(sRender); 3、仿真效果 代码参考examples/HeightField/GL_Ocean/main.h:\n"
},
{
	"uri": "https://peridyno.github.io/zh/installation/window/",
	"title": "Window平台安装",
	"tags": [],
	"description": "",
	"content": "1、安装平台  Windows 平台: 支持window10、 window11平台  2、依赖  IDE: Visual studio 2017+（推荐Visual studio 2019） CUDA: CUDA Toolkit 11.0+（推荐CUDA Toolkit 11.4）  可选择的库:\n Qt: https://download.qt.io/ VTK: https://github.com/Kitware/VTK Alembic: https://github.com/alembic/alembic Imath: https://github.com/AcademySoftwareFoundation/Imath  3、安装 除了上述可选的库，其他库都可以在项目中简化安装。使用 git 命令克隆项目及子模块。\ngit clone --recursive https://github.com/peridyno/peridyno.git\r运行cmake选择项目\n4、编译项目 使用cmake软件对项目进行编译：\n5、运行 在Visual studio打开编译好的项目，选择Examples的中项目作为启动项，运行。下图是GL_ParticleFluid项目的运行效果图：\n"
},
{
	"uri": "https://peridyno.github.io/zh/installation/linux/",
	"title": "Linux平台安装",
	"tags": [],
	"description": "",
	"content": "1、安装平台  Linux 平台：ubuntu 18.04及以上平台  2、依赖  CUDA: CUDA Toolkit 11.0+（推荐11.2） g++: 11.1.0+ (推荐 11.1.0)  可选择的库:\n Qt: https://download.qt.io/ VTK: https://github.com/Kitware/VTK Alembic: https://github.com/alembic/alembic Imath: https://github.com/AcademySoftwareFoundation/Imath  3、安装 除了上述可选的库，其他库都可以在项目中简化安装。使用 git 命令克隆项目及子模块。\ngit clone --recursive https://github.com/peridyno/peridyno.git\r4、编译项目 打开Linux终端：\ncd peridyo/build cmake ..\rmake -j8\r"
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/",
	"title": "粒子系统",
	"tags": [],
	"description": "",
	"content": "PeriDyno中的粒子系统主要用于模拟流体材料。该系统中，流体材料会被离散为粒子。通过计算每个粒子在Navior Stokes 方程作用下的运动，即可实现流体的模拟。现阶段PeriDyno的粒子系统中包含有以下几部分模块：基于SPH的投影法求解器、人工粘性求解器和表面张力求解器，以及PBF（Position Based Fluid）求解器等。以下是粒子系统相关基础理论以及求解器的介绍。\n1. 基础理论 流体的Navior Stokes方程的具体形式如下：\n$$ \\begin{aligned} \u0026amp;\\rho\\frac{\\mathrm{D} \\mathbf{v} }{\\mathrm{D} t} = - \\nabla p + \\nabla\\cdot \\mu (\\nabla\\mathbf{V}+\\nabla\\mathbf{V}^T)+\\mathbf{F} \\end{aligned} $$ （公式1）\n其中,$\\rho$、$\\mathbf{v}$、$p$、$\\mu$、$\\mathbf{f}$ 分别为流体的密度场、速度场、压强场、粘性系数以及流体所受到的体积力。该方程的本质为的动量守恒定律，其等式右端各项的物理含义分别为流体不可压缩性引起的压强作用、流体的粘性引起的剪切力作用，以及流体所受到的重力、离心力等体积力的作用。\n除NS方程外，大多数流体在运动过程中还需要满足不可压缩性性条件，即：\n$$ \\nabla \\cdot \\mathbf{V} = \\frac{1}{\\rho}\\frac{\\mathrm{d} \\rho}{\\mathrm{d} t} = 0 $$\n（公式2）\n当流体某位置的不可压缩性条件存在被破坏的趋势时，相应位置上会产生一定的压强以抵抗不可压缩性的破坏。\n2. 流体模拟的基本方法 虽然理论上联立Navior Stokes 方程（公式一）和不可压缩性条件（公式二）求解出流体的速度场，即可实现流体运动的模拟。然而直接求解这两个方程是很困难的。为了简化上述量微分方程求解的难度，我们需要采用以下两种技术手段：\n   粒子离散化。使用携带有质量、压强等物理信息的粒子离散流体连续的物理场和微分算子，进而将上述连续形式的微分方程转化为线性方程组。   算子分裂法。将Navior Stokes方程拆分成三个较小的微分方程，以简化原微分方程求解的难度。\n   在使用粒子离散化与算子分裂法后，原Navior Stokes方程就被转化为如下三组方程组：\n   只有体积力项的速度微分方程。 流体粒子在体积力作用下速度的变化。 $$ \\frac{\\mathbf{v}_i^{n+\\frac{1}{3}} - \\mathbf{v}_i^{old} }{\\delta t} = \\mathbf{F}\n$$\n  只有粘性项的微分方程（流体的粘性）。 不可压缩性作用下的流体速度场变化。 $$ \\frac{\\mathbf{v}_i^{n+\\frac{2}{3}} - \\mathbf{v}_i^{n+\\frac{1}{3} }}{\\delta t} = \\nabla_i\\cdot \\mu (\\nabla\\mathbf{V}+\\nabla\\mathbf{V}^T) $$\n  只有压强项的微分方程（不可压缩性）。 不可压缩性作用下的流体速度场变化。 $$ \\frac{\\mathbf{v}_i^{new} - \\mathbf{v}_i^{n+\\frac{2}{3}} }{\\delta t} = - \\frac{1}{\\rho_i} \\nabla_i p $$\n   上式中的$\\delta t$为仿真时间步长，$i$为某粒子的编号。其中压强场可以通过流体速度散度误差$\\nabla_i\\cdot\\mathbf{v}$或密度误差$\\rho_i-\\rho_0$来获得（$\\rho_0$为流体的静止密度）。\n该系统中包含有以下几种基础方法，即：SPH(Smoothed Particle Hydrodynamics)、PBF（Position Based Fluid）法、投影法（Projection Method）等。\n3. SPH（Smoothed Particle Hydrodynamics）离散化方法简介 SPH法是最常被使用的一类粒子法。该方法中任意位置 $\\mathbf{x}$ 的物理量都可以通过其邻域粒子（邻近粒子）$j$ 插值计算得到，即： $$ A(\\mathbf{x})={\\sum_{j,\\left |\\mathbf{x} -\\mathbf{x}_j \\right | \u0026lt;h}A_j *W(\\left |\\mathbf{x} -\\mathbf{x}_j \\right |,h)} $$ （公式3） 其中$h$为平滑半径（SPH支持域半径），$j$为与点$\\mathbf{x}$距离小于$h$的粒子编号，$W(r,h)$为高斯函数或具有类似特性样条函数。如果相对于$h$的粒子间距足够小，则由上述方程重建的物理场$A(\\mathbf{x})$是较为平滑的。\n基于公式3可以实现密度等物理场以及微分算子的离散化。略去推导过程几种常用的微分算子离散化形式为：\n4. 粒子系统的核心求解器 基于算子分裂策略，原Navior Stokes方程的求解过程被划分为了三个独立的求解步骤，其中最重要的求解步骤是不可压缩性求解。不可压缩性是指流体运动中始终保持密度不变的特性，该特性直接地影响了流体的运动。目前PeriDyno中不可压缩性的实现方法有两种，分别为“基于位置约束的方法”和“投影法”。这两部分的算法介绍见4.2.2节和4.2.3节。\n除不可压缩性计算之外，粘性求解也是流体模拟的重要步骤。PeriDyno中包含有基于非物理的人工粘性求解器，该求解器可以显著提高低流体的稳定性，也能够模拟大粘性流体运动。这部分的介绍见4.2.3节。\n此外，为了更准确地模拟小尺度的不可压缩流体运动，也要考虑流体的表面张力作用。这一部分的介绍请参考4.2.4节。\n参引文献 [1] Bridson R. Fluid simulation for computer graphics[M]. AK Peters/CRC Press, 2015. [2] Koschier D, Bender J, Solenthaler B, et al. Smoothed particle hydrodynamics techniques for the physics based simulation of fluids and solids[J]. arXiv preprint arXiv:2009.06944, 2020. [3] Monaghan J J. Smoothed particle hydrodynamics[J]. Annual review of astronomy and astrophysics, 1992, 30: 543-574.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/rigidbodydynamics/",
	"title": "刚体动力学",
	"tags": [],
	"description": "To be continued...
",
	"content": "刚体是在运动过程中，形状和大小不变，而且内部各点的相对位置不发生改变的物体。绝对刚体实际上是不存在的，只是一种理想模型，因为任何物体在受力作用后，都或多或少会产生变形。如果变形的程度相对于物体本身几何尺寸来说极为微小，在研究物体运动时变形就可以忽略不计。\n1、刚体的三种类型 系统中刚体一共有三种类别，分别是：\n（1）动态刚体（dynamic）\n 正质量 每帧都更新自己的位置  （2）Kinematic刚体\n 零个质量 -由用户设置  （3）静态的刚体（static）\n 零质量 不能移动，但能发生碰撞  2、刚体仿真计算过程 刚体仿真计算过程主要可分为以下几个步骤：\n（1）加载模型和场景\n（2）根据用户的需求添加约束和碰撞\n（3）计算刚体的加速度\n（4）更新刚体的速度和位置信息\n（5）重复迭代（3）和（4），直到程序结束\n接下来对刚体程序的计算过程进行解释（具体代码参考RigidBody/RigidBodySystem.cu和RigidBody/IterativeConstraintSolver.cu）： 在刚体动力学计算过程中，首先处理刚体的碰撞和约束： enforceConstraints()//约束 handleCollision()//碰撞\n在处理完刚体约束和碰撞之后，我们先将刚体与地面碰撞的点对信息和刚体与刚体间碰撞的点对信息累加起来。所有的碰撞点对信息记录在allContacts变量中，将碰撞点的总数信息保存到Contacts变量中。\n接下来判断刚体是否设置了摩擦力约束。如果没有设置摩擦力约束，刚体是非穿透类型，则只有法线1个约束。如果设置了摩擦力，那么刚体的切平面还有两个约束。因此碰撞点对需要额外开辟2倍法线的空间，即约束的数量是碰撞点对的3倍。\ntemplate \u0026lt;typename ContactPair\u0026gt; __global__ void SetupFrictionConstraints( DArray\u0026lt;ContactPair\u0026gt; nbq, int contact_size) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= contact_size) return; Coord3D n = nbq[pId].normal1; n /= n.norm(); Coord3D n1, n2; if (abs(n[1]) \u0026gt; EPSILON || abs(n[2]) \u0026gt; EPSILON) { n1 = Coord3D(0, n[2], -n[1]); n1 /= n1.norm(); n2 = n1.cross(n); n2 /= n2.norm(); } else if (abs(n[0]) \u0026gt; EPSILON) { n1 = Coord3D(n[2], 0, -n[0]); n1 /= n1.norm(); n2 = n1.cross(n); n2 /= n2.norm(); } nbq[pId * 2 + contact_size].bodyId1 = nbq[pId].bodyId1; nbq[pId * 2 + contact_size].bodyId2 = nbq[pId].bodyId2; nbq[pId * 2 + contact_size] = nbq[pId]; nbq[pId * 2 + contact_size].contactType = ContactType::CT_FRICTION; nbq[pId * 2 + contact_size].normal1 = n1; nbq[pId * 2 + 1 + contact_size].bodyId1 = nbq[pId].bodyId1; nbq[pId * 2 + 1 + contact_size].bodyId2 = nbq[pId].bodyId2; nbq[pId * 2 + 1 + contact_size] = nbq[pId]; nbq[pId * 2 + 1 + contact_size].contactType = ContactType::CT_FRICTION; nbq[pId * 2 + 1 + contact_size].normal1 = n2; } 将所有碰撞点对的信息保存到Contacts变量中。\n接下来开始进行刚体动力学计算。在解释代码之前，先补充说明整个动力学计算的过程。假设速度从${{\\rm{V}}^1}$变化到${{\\rm{V}}^2}$的时间步长为$\\Delta t $，则此时的加速度可表示为 ： $$ \\dot{V}\\approx \\frac{V^2-V^1}{\\bigtriangleup t} $$\n根据牛顿第二定律可得到： $$ m\\dot V = {F_c} + {F_{ext}} $$\n其中${F_c}$表示约束力、${F_{ext}}$表示额外力。约束力可表示为${F_c} = {J^T}\\lambda$。根据上述两式有： $$ M({V^2} - {V^1}) = \\Delta t({J^T}\\lambda + {F_{ext}}) $$\n因此需要求解$[\\lambda ]$进而求出$[{V^2}]$。将问题转换为求解$[\\lambda ]$的线性方程$J{\\rm{B}}\\lambda {\\rm{ = }}\\eta $。同时根据$B{\\rm{ = }}{{\\rm{M}}^{ - 1}}{J^T}$，则有：\n$$ \\eta = \\frac{1}{{\\Delta t}}\\xi - J(\\frac{1}{{\\Delta t}}{V^1} + {M^{ - 1}}{F_{ext}}) $$\n如果约束是一致的，我们可以求解出$\\lambda $，进而计算出${V^2}$，从而可以推导出刚体的速度和位移：\n\\begin{array}{l} {x^{\\rm{2}}}{\\rm{ = }}{x^1} + \\Delta t{v^2}\\\\\n{q^2} = {q^1} = \\frac{{\\Delta t}}{2}{q^1}{w^2} \\end{array}\n接下来开始对程序进行解释，首先计算雅可比矩阵（Jacobian）J，以及B矩阵。\ntemplate \u0026lt;typename Coord, typename Matrix, typename ContactPair\u0026gt; __global__ void CalculateJacobians( DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Coord\u0026gt; B, DArray\u0026lt;Coord\u0026gt; pos, DArray\u0026lt;Matrix\u0026gt; inertia, DArray\u0026lt;Real\u0026gt; mass, DArray\u0026lt;ContactPair\u0026gt; nbc) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= J.size() / 4) return; int idx1 = nbc[pId].bodyId1; int idx2 = nbc[pId].bodyId2; //printf(\u0026#34;%d %d\\n\u0026#34;, idx1, idx2);  if (nbc[pId].contactType == ContactType::CT_NONPENETRATION) // contact, collision \t{ Coord p1 = nbc[pId].pos1; Coord p2 = nbc[pId].pos2; Coord n = nbc[pId].normal1; Coord r1 = p1 - pos[idx1]; Coord r2 = p2 - pos[idx2]; J[4 * pId] = n; J[4 * pId + 1] = (r1.cross(n)); J[4 * pId + 2] = -n; J[4 * pId + 3] = -(r2.cross(n)); B[4 * pId] = n / mass[idx1]; B[4 * pId + 1] = inertia[idx1].inverse() * (r1.cross(n)); B[4 * pId + 2] = -n / mass[idx2]; B[4 * pId + 3] = inertia[idx2].inverse() * (-r2.cross(n)); } else if (nbc[pId].contactType == ContactType::CT_BOUDNARY) // boundary \t{ Coord p1 = nbc[pId].pos1; //\tprintf(\u0026#34;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ %d %.3lf %.3lf %.3lf\\n\u0026#34;, idx1, p1[0], p1[1], p1[2]);  Coord n = nbc[pId].normal1; Coord r1 = p1 - pos[idx1]; J[4 * pId] = n; J[4 * pId + 1] = (r1.cross(n)); J[4 * pId + 2] = Coord(0); J[4 * pId + 3] = Coord(0); B[4 * pId] = n / mass[idx1]; B[4 * pId + 1] = inertia[idx1].inverse() * (r1.cross(n)); B[4 * pId + 2] = Coord(0); B[4 * pId + 3] = Coord(0); } else if (nbc[pId].contactType == ContactType::CT_FRICTION) // friction \t{ Coord p1 = nbc[pId].pos1; //printf(\u0026#34;~~~~~~~ %.3lf %.3lf %.3lf\\n\u0026#34;, p1[0], p1[1], p1[2]);  Coord p2 = Coord(0); if (idx2 != -1) p2 = nbc[pId].pos2; Coord n = nbc[pId].normal1; Coord r1 = p1 - pos[idx1]; Coord r2 = Coord(0); if (idx2 != -1) r2 = p2 - pos[idx2]; J[4 * pId] = n; J[4 * pId + 1] = (r1.cross(n)); if (idx2 != -1) { J[4 * pId + 2] = -n; J[4 * pId + 3] = -(r2.cross(n)); } else { J[4 * pId + 2] = Coord(0); J[4 * pId + 3] = Coord(0); } B[4 * pId] = n / mass[idx1]; B[4 * pId + 1] = inertia[idx1].inverse() * (r1.cross(n)); if (idx2 != -1) { B[4 * pId + 2] = -n / mass[idx2]; B[4 * pId + 3] = inertia[idx2].inverse() * (-r2.cross(n)); } else { B[4 * pId + 2] = Coord(0); B[4 * pId + 3] = Coord(0); } } } 其中B矩阵为$B=M^{-1}J^T$。 接下来计算D矩阵，D=JB。\ntemplate \u0026lt;typename Coord\u0026gt; __global__ void CalculateDiagonals( DArray\u0026lt;Real\u0026gt; D, DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Coord\u0026gt; B) { int tId = threadIdx.x + (blockIdx.x * blockDim.x); if (tId \u0026gt;= J.size() / 4) return; Real d = Real(0); d += J[4 * tId].dot(B[4 * tId]); d += J[4 * tId + 1].dot(B[4 * tId + 1]); d += J[4 * tId + 2].dot(B[4 * tId + 2]); d += J[4 * tId + 3].dot(B[4 * tId + 3]); D[tId] = d; } 接下来计算$\\eta $矩阵$\\eta = \\frac{1}{{\\Delta t}}\\xi - J(\\frac{1}{{\\Delta t}}{V^1} + {M^{ - 1}}{F_{ext}})$：\ntemplate \u0026lt;typename Coord, typename ContactPair\u0026gt; __global__ void CalculateEta( DArray\u0026lt;Real\u0026gt; eta, DArray\u0026lt;Coord\u0026gt; velocity, DArray\u0026lt;Coord\u0026gt; angular_velocity, DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Real\u0026gt; mass, DArray\u0026lt;ContactPair\u0026gt; nbq, Real dt) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= J.size() / 4) return; int idx1 = nbq[pId].bodyId1; int idx2 = nbq[pId].bodyId2; //printf(\u0026#34;from ita %d\\n\u0026#34;, pId); \tReal ita_i = Real(0); if (true) // test dist constraint \t{ ita_i -= J[4 * pId].dot(velocity[idx1]); ita_i -= J[4 * pId + 1].dot(angular_velocity[idx1]); if (idx2 != -1) { ita_i -= J[4 * pId + 2].dot(velocity[idx2]); ita_i -= J[4 * pId + 3].dot(angular_velocity[idx2]); } } eta[pId] = ita_i / dt; if (nbq[pId].contactType == ContactType::CT_NONPENETRATION || nbq[pId].contactType == ContactType::CT_BOUDNARY) { eta[pId] += min(nbq[pId].interpenetration, nbq[pId].interpenetration) / dt / dt / 15.0f; } } 接下来开始进行迭代求解 。迭代算法采用Jacobi迭代:\ntemplate \u0026lt;typename Coord, typename ContactPair\u0026gt; __global__ void TakeOneJacobiIteration( DArray\u0026lt;Real\u0026gt; lambda, DArray\u0026lt;Coord\u0026gt; accel, DArray\u0026lt;Real\u0026gt; d, DArray\u0026lt;Coord\u0026gt; J, DArray\u0026lt;Coord\u0026gt; B, DArray\u0026lt;Real\u0026gt; eta, DArray\u0026lt;Real\u0026gt; mass, DArray\u0026lt;ContactPair\u0026gt; nbq, DArray\u0026lt;Real\u0026gt; stepInv) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= J.size() / 4) return; int idx1 = nbq[pId].bodyId1; int idx2 = nbq[pId].bodyId2; Real eta_i = eta[pId]; { eta_i -= J[4 * pId].dot(accel[idx1 * 2]); eta_i -= J[4 * pId + 1].dot(accel[idx1 * 2 + 1]); if (idx2 != -1) { eta_i -= J[4 * pId + 2].dot(accel[idx2 * 2]); eta_i -= J[4 * pId + 3].dot(accel[idx2 * 2 + 1]); } } if (d[pId] \u0026gt; EPSILON) { Real delta_lambda = eta_i / d[pId]; Real stepInverse = stepInv[idx1]; if (idx2 != -1) stepInverse += stepInv[idx2]; delta_lambda *= (1.0f / stepInverse); //printf(\u0026#34;delta_lambda = %.3lf\\n\u0026#34;, delta_lambda);  if (nbq[pId].contactType == ContactType::CT_NONPENETRATION || nbq[pId].contactType == ContactType::CT_BOUDNARY) //\tPROJECTION!!!! \t{ Real lambda_new = lambda[pId] + delta_lambda; if (lambda_new \u0026lt; 0) lambda_new = 0; Real mass_i = mass[idx1]; if (idx2 != -1) mass_i += mass[idx2]; if (lambda_new \u0026gt; 25 * (mass_i / 0.1)) lambda_new = 25 * (mass_i / 0.1); delta_lambda = lambda_new - lambda[pId]; } if (nbq[pId].contactType == ContactType::CT_FRICTION) //\tPROJECTION!!!! \t{ Real lambda_new = lambda[pId] + delta_lambda; Real mass_i = mass[idx1]; if (idx2 != -1) mass_i += mass[idx2]; //if ((lambda_new) \u0026gt; 5 * (mass_i)) lambda_new = 5 * (mass_i); \t//if ((lambda_new) \u0026lt; -5 * (mass_i)) lambda_new = -5 * (mass_i); \tdelta_lambda = lambda_new - lambda[pId]; } lambda[pId] += delta_lambda; //printf(\u0026#34;inside iteration: %d %d %.5lf %.5lf\\n\u0026#34;, idx1, idx2, nbq[pId].s4, delta_lambda);  atomicAdd(\u0026amp;accel[idx1 * 2][0], B[4 * pId][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2][1], B[4 * pId][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2][2], B[4 * pId][2] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2 + 1][0], B[4 * pId + 1][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2 + 1][1], B[4 * pId + 1][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx1 * 2 + 1][2], B[4 * pId + 1][2] * delta_lambda); if (idx2 != -1) { atomicAdd(\u0026amp;accel[idx2 * 2][0], B[4 * pId + 2][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2][1], B[4 * pId + 2][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2][2], B[4 * pId + 2][2] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2 + 1][0], B[4 * pId + 3][0] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2 + 1][1], B[4 * pId + 3][1] * delta_lambda); atomicAdd(\u0026amp;accel[idx2 * 2 + 1][2], B[4 * pId + 3][2] * delta_lambda); } } } 更新刚体的速度和位置信息。\ntemplate \u0026lt;typename Coord\u0026gt; __global__ void RB_UpdateVelocity( DArray\u0026lt;Coord\u0026gt; velocity, DArray\u0026lt;Coord\u0026gt; angular_velocity, DArray\u0026lt;Coord\u0026gt; accel, Real dt) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= accel.size() / 2) return; velocity[pId] += accel[2 * pId] * dt; velocity[pId] += Coord(0, -9.8f, 0) * dt; angular_velocity[pId] += accel[2 * pId + 1] * dt; } template \u0026lt;typename Coord, typename Matrix, typename Quat\u0026gt; __global__ void RB_UpdateGesture( DArray\u0026lt;Coord\u0026gt; pos, DArray\u0026lt;Quat\u0026gt; rotQuat, DArray\u0026lt;Matrix\u0026gt; rotMat, DArray\u0026lt;Matrix\u0026gt; inertia, DArray\u0026lt;Coord\u0026gt; velocity, DArray\u0026lt;Coord\u0026gt; angular_velocity, DArray\u0026lt;Matrix\u0026gt; inertia_init, Real dt) { int pId = threadIdx.x + (blockIdx.x * blockDim.x); if (pId \u0026gt;= pos.size()) return; pos[pId] += velocity[pId] * dt; rotQuat[pId] = rotQuat[pId].normalize(); rotMat[pId] = rotQuat[pId].toMatrix3x3(); rotQuat[pId] += dt * 0.5f * Quat(angular_velocity[pId][0], angular_velocity[pId][1], angular_velocity[pId][2], 0.0) *(rotQuat[pId]); inertia[pId] = rotMat[pId] * inertia_init[pId] * rotMat[pId].inverse(); //inertia[pId] = rotMat[pId] * rotMat[pId].inverse(); \t} "
},
{
	"uri": "https://peridyno.github.io/zh/topics/fem/",
	"title": "有限元法",
	"tags": [],
	"description": "To be continued...
",
	"content": "未完待续。。。\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/heightfield/",
	"title": "高度场",
	"tags": [],
	"description": "把水面表示成为一个连续的平面网格
",
	"content": "1、总体介绍 高度场流体仿真分为两个部分，基于浅水方程（SWE）的浅水波模拟和基于快速傅里叶变换（FFT）的海浪模拟。浅水方程（SWE）是描述浅水流动的数学模型，同时也是水力学中的一个重要的数学模型。浅水方程建立在具有物理意义的物理量守恒基础上，也可以称为双曲守恒型方程组。基于快速傅里叶变换（FFT）的海浪模拟的主要思想就是按照Phillips波普得到海面的高度场（也就是傅里叶变换的频域），然后将其逆傅里叶变换（IFFT）得到海面（也就是时域）。\n2、浅水波仿真 目前实时系统大规模水体仿真广泛使用Gerstner模型，其核心思想是通过对计算格点的位置进行周期性的偏移来达到水波翻滚的效果。尽管Gerstner Wave适用于建模大范围的水体，然而其在展现精细尺度水波上能力有限，且无法反应水体与刚体的交互。鉴于此，本项目使用浅水方程来实现精细尺度的水波模拟：\n\\begin{array}{l} \\frac{{\\partial h}}{{\\partial t}} + \\frac{\\partial }{{\\partial x}}\\left( {hu} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {hv} \\right) = 0 \\\\\n\\frac{\\partial }{{\\partial t}}\\left( {hu} \\right) + \\frac{\\partial }{{\\partial x}}\\left( {\\frac{{h{u^2}}}{2}} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {huv} \\right) = - gh\\frac{{\\partial s}}{{\\partial x}} \\\\\n\\frac{\\partial }{{\\partial t}}\\left( {hv} \\right) + \\frac{\\partial }{{\\partial x}}\\left( {huv} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {\\frac{{h{v^2}}}{2}} \\right) = - gh\\frac{{\\partial s}}{{\\partial y}} \\end{array}\n其中u、v分别表示洋流水平速度的两个分量，h表示洋流的深度，s表示海面垂直坐标，g表示重力加速度。求解过程，首先基于高度场对仿真区域进行如图所示的离散。\n然后，通过求解波动方程计算每个时刻的高度场的位置。最终，将基于浅水方程（SWE）得到的高度场叠加到大区域水体上从而实现更加逼得水体仿真。\n首先初始化水面的初始高度。对于水面边界的高度进行处理，每次计算后：\na) x=0点的粒子高度值等于x=1点的粒子高度值； b) x= width - 1点的粒子高度值等于x= width - 2点的粒子高度值；\rc) y=0点的粒子高度值等于y=1点的粒子高度值；\rd) y= height- 1点的粒子高度值等于y= height - 2点的粒子高度值。\rsrc/Dynamics/HeightField/CapillaryWave.cu 中实现如下：\n__global__ void C_ImposeBC(Vec4f* grid_next, Vec4f* grid, int width, int height, int pitch) { int x = threadIdx.x + blockIdx.x * blockDim.x; int y = threadIdx.y + blockIdx.y * blockDim.y; if (x \u0026lt; width \u0026amp;\u0026amp; y \u0026lt; height) { if (x == 0) { Vec4f a = grid[(y)*pitch + 1]; grid_next[(y)*pitch + x] = a; } else if (x == width - 1) { Vec4f a = grid[(y)*pitch + width - 2]; grid_next[(y)*pitch + x] = a; } else if (y == 0) { Vec4f a = grid[(1) * pitch + x]; grid_next[(y)*pitch + x] = a; } else if (y == height - 1) { Vec4f a = grid[(height - 2) * pitch + x]; grid_next[(y)*pitch + x] = a; } else { Vec4f a = grid[(y)*pitch + x]; grid_next[(y)*pitch + x] = a; } } } 对每个时间内的高度场进行迭代：\n__global__ void C_OneWaveStep(Vec4f* grid_next, Vec4f* grid, int width, int height, float timestep, int pitch) 最后计算u、v洋流水平速度的两个分量，h洋流的深度，s海面垂直坐标。\n__global__ void C_InitHeightField( Vec4f* height, Vec4f* grid, int patchSize, float horizon, float realSize) { int i = threadIdx.x + blockIdx.x * blockDim.x; int j = threadIdx.y + blockIdx.y * blockDim.y; if (i \u0026lt; patchSize \u0026amp;\u0026amp; j \u0026lt; patchSize) { int gridx = i + 1; int gridy = j + 1; Vec4f gp = grid[gridx + patchSize * gridy]; height[i + j * patchSize].x = gp.x - horizon; float d = sqrtf((i - patchSize / 2) * (i - patchSize / 2) + (j - patchSize / 2) * (j - patchSize / 2)); float q = d / (0.49f * patchSize); float weight = q \u0026lt; 1.0f ? 1.0f - q * q : 0.0f; height[i + j * patchSize].y = 1.3f * realSize * sinf(3.0f * weight * height[i + j * patchSize].x * 0.5f * M_PI); } } 3、基于快速傅里叶变换（FFT）的海浪模拟 FFT模型是一种统计模型。不同于Gerstner模型采用多个正弦余弦函数去拟合，FFT模型采用傅里叶变换的方式。傅里叶变换的核心就是用sin(nx)和cos(nx)去模拟任意的周期函数。在FFT模型中，用时间和水平高度的随机函数h(x,t)来表示浪的高度。该方法仿真度高，易于建模，其计算公式如下[1]：\n$$h(X,t) = \\sum\\limits_K^{} {\\tilde h(K,t){{\\mathop{\\rm e}\\nolimits} ^{(iK{\\rm{X}})}}} $$\n式中，$X{\\rm{ = }}(x,z)$水平位置；$t$代表时间；$K$是一个二维向量；$\\tilde h(k,t)$表示海浪表面结构。\n构建FFT模型的高度场之后，接下来创建随机的高度场。引入高斯随机函数，有：\n$${\\tilde h_0}(K) = \\frac{1}{{\\sqrt 2 }}({\\xi _r} + i{\\xi _i})\\sqrt {{P_h}(K)} $$\n其中，${\\xi _r}$和${\\xi _i}$是相互独立的高斯随机数（均值为 0，方差为 1）。此时在$t$时刻波的振幅为：\n$$\\tilde h(K,t) = \\tilde h(K){e^{i\\omega (K)t}} + \\tilde h_0^*( - K){e^{ - i\\omega ({\\rm{K}})t}}$$ 其中，$\\omega (k)$是波$K$的角频率，可以根据${\\omega ^2}(k) = g|K|$计算得到；*号表示复数的共轭运算。根据FFT模型，海浪的高度最终一定为实数，所以一定满足$\\tilde h(-K)= \\tilde h_0^*(K)$。\ntemplate\u0026lt;typename TDataType\u0026gt; void OceanPatch\u0026lt;TDataType\u0026gt;::generateH0(Vec2f* h0) { for (unsigned int y = 0; y \u0026lt;= mResolution; y++) { for (unsigned int x = 0; x \u0026lt;= mResolution; x++) { float kx = (-( int )mResolution / 2.0f + x) * (2.0f * CUDART_PI_F / m_realPatchSize); float ky = (-( int )mResolution / 2.0f + y) * (2.0f * CUDART_PI_F / m_realPatchSize); float P = sqrtf(phillips(kx, ky, windDir, m_windSpeed, A, dirDepend)); if (kx == 0.0f \u0026amp;\u0026amp; ky == 0.0f) { P = 0.0f; } float Er = gauss(); float Ei = gauss(); float h0_re = Er * P * CUDART_SQRT_HALF_F; float h0_im = Ei * P * CUDART_SQRT_HALF_F; int i = y * mSpectrumWidth + x; h0[i].x = h0_re; h0[i].y = h0_im; } } } 初始化相位和振幅。频谱可以采用Phillips频谱。Phillips频谱适用于海面网格并行化计算。它是一种真实度较高的频谱，多用于在有风的影响下。Phillips频谱的定义如下：\n$${P_h}(K) = A\\frac{{\\exp ( - 1/{{(kL)}^2})}}{{{k^4}}}|\\hat K\\hat \\omega {|^2}$$\n其中，$g$表示重力加速度；$k = |K| = 2\\pi / \\lambda $；$\\lambda $表示波长；$A$表示一个常系数；$L = {V^2}/g$表示风速在$V$的情况下产生的最大波浪；$\\hat \\omega $表示风向；$|\\hat K\\hat \\omega {|^2}$表示消除了垂直于风向运动的波。\n// generate wave heightfield at time t based on initial heightfield and dispersion relationship __global__ void generateSpectrumKernel(Vec2f* h0, Vec2f* ht, unsigned int in_width, unsigned int out_width, unsigned int out_height, float t, float patchSize) { unsigned int x = blockIdx.x * blockDim.x + threadIdx.x; unsigned int y = blockIdx.y * blockDim.y + threadIdx.y; unsigned int in_index = y * in_width + x; unsigned int in_mindex = (out_height - y) * in_width + (out_width - x); // mirrored  unsigned int out_index = y * out_width + x; // calculate wave vector  Vec2f k; k.x = (-( int )out_width / 2.0f + x) * (2.0f * CUDART_PI_F / patchSize); k.y = (-( int )out_width / 2.0f + y) * (2.0f * CUDART_PI_F / patchSize); // calculate dispersion w(k)  float k_len = sqrtf(k.x * k.x + k.y * k.y); float w = sqrtf(9.81f * k_len); if ((x \u0026lt; out_width) \u0026amp;\u0026amp; (y \u0026lt; out_height)) { Vec2f h0_k = h0[in_index]; Vec2f h0_mk = h0[in_mindex]; // output frequency-space complex values  ht[out_index] = complex_add(complex_mult(h0_k, complex_exp(w * t)), complex_mult(conjugate(h0_mk), complex_exp(-w * t))); //ht[out_index] = h0_k;  } } 在使用FFT模型在流体仿真的过程中，需要根据每个点的斜率之计算表面的法向量。在实际的计算过程中，一般采用邻近网格点有限差分来计算斜率值。但为了减少小波波长的斜率误差，可使用反向FFT变换的方式进行求解：\n$$\\nabla h(X,t) = \\sum\\limits_K^{} {iK\\tilde h(K,t)\\exp (iKX)} $$\ncufftExecC2C(fftPlan, (float2*)m_ht, (float2*)m_ht, CUFFT_INVERSE); cufftExecC2C(fftPlan, (float2*)m_Dxt, (float2*)m_Dxt, CUFFT_INVERSE); cufftExecC2C(fftPlan, (float2*)m_Dzt, (float2*)m_Dzt, CUFFT_INVERSE); 此外，还需要一个偏置向量D(x,t)来模拟海水的浪尖，可以如下设置：\n$$D(x,t) = \\sum\\limits_k { - i\\frac{k}{{|k|}}h(k,t){e^{ikx}}} $$\n其中雅克比矩阵为： \\begin{equation} J\\left( x \\right) =\\left| \\begin{matrix} J_{xx}\u0026amp;\tJ_{xy}\\\\\nJ_{zx}\u0026amp;\tJ_{yy}\\\\\n\\end{matrix} \\right| \\end{equation}\n$$ \\begin{array}{l} J_{xx}=\\frac{\\partial x^{'}}{\\partial x}=1+\\lambda \\frac{\\partial D_x\\left( x,t \\right)}{\\partial x}\\\\\nJ_{yy}=\\frac{\\partial y^{'}}{\\partial y}=1+\\lambda \\frac{\\partial D_y\\left( x,t \\right)}{\\partial y}\\\\\nJ_{yx}=\\frac{\\partial y^{'}}{\\partial x}=\\lambda \\frac{\\partial D_y\\left( x,t \\right)}{\\partial x}\\\\\nJ_{xy}=\\frac{\\partial x^{'}}{\\partial y}=\\lambda \\frac{\\partial D_x\\left( x,t \\right)}{\\partial y}\\\\\n\\end{array} $$\n参考文献 [1] Tessendorf J. Simulating ocean water[J]. Simulating nature: realistic and interactive techniques. SIGGRAPH, 2001, 1(2): 5.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/postprocessing/",
	"title": "离线渲染与后处理",
	"tags": [],
	"description": "PeriDyno仿真案例的后处理专题介绍
",
	"content": "后处理文档概述  本部分文档将具体从：流程概述、数据导入、数据的查看与调整、数据可视化、渲染、合成6个方面对PeriDyno的后处理进行讲解。  一、流程概述   PeriDyno在数据的种类上主要分为网格、粒子、曲线三种，涉及abc、obj、txt等格式。在后处理过程中，主要选用Houdini作为数据整合、可视化及渲染的主要平台。\n  基于Houdini的特性，能够很好的进行数据整合、数据查看、数据调整、数据可视化、数据渲染等工作，并能够基于非破坏性的流程进行快速的迭代，使前处理与后处理工作在一定程度上得以并行推进，提高效率。 此外，Maya、Blender等全流程三维软件也是PeriDyno数据后处理工作可选择的平台，其也能够完成材质、灯光及渲染工作，但在兼容性及数据查看方面稍显逊色，本文档不做过多推荐与介绍。\n  最终上述三维软件所渲染出的序列帧可以使用Adobe After Effects、The Foundry Nuke、Adobe Premiere Pro等后期合成及剪辑软件完成合成与输出。\n  二、数据导入 PeriDyno输出的数据主要分为网格、粒子、曲线三种类型，涉及abc、obj、fbx、txt等格式。\n  网格数据以obj、obj序列的格式导入。\n  粒子数据abc、abc序列的格式导入。\n  曲线数据abc、abc序列的格式导入。\n  骨骼网格体数据以fbx格式 进行导入。\n  txt格式的粒子数据能够通过MeshlessSkinning工具转换为网格数据并输出为obj序列从而进行导入。\n  导入方法： 1.使用Houdini菜单栏File-Import进行文件的导入。\n 通过Houdini菜单栏File-import进行文件的导入，并根据需求选择相应的格式即可。在通常情况下可以使用Geometry选项进行导入。其会为我们在Object层级下创建一个Geo节点，并根据所选的格式适配合适的节点进行文件的导入（*注意：此方法不适用于骨骼网格体，骨骼网格体请详见本节的fbx character import部分）。  2.创建Geo节点，进入节点内，创建File、Alembic或fbx character import等节点进行进行导入。\n（1）通过File节点导入\n 在节点工作区Object层级按下Tab键，并搜索Geo，创建Geometry节点，并使用Enter键进入。    在Geometry层级下创建File节点。   File节点的Geometry File通道可以指定文件路径，其支持以下格式（不建议用此节点导入abc格式文件，其对abc没有单独的优化，运行效率较低，建议使用Alembic节点进行abc文件的导入）。 *.geo, *.bgeo, *.hclassic, *.bhclassic, *.geo.gz, *.geogz, *.bgeo.gz, *.bgeogz, *.hclassic.gz, *.hclassicgz, *.bhclassic.gz, *.bhclassicgz, *.geo.sc, *.geosc, *.bgeo.sc, *.bgeosc, *.hclassic.sc, *.hclassicsc, *.bhclassic.sc, *.bhclassicsc, *.json, *.bjson, *.json.gz, *.jsongz, *.bjson.gz, *.bjsongz, *.json.sc, *.jsonsc, *.bjson.sc, *.bjsonsc, *.poly, *.bpoly, *.d, *.rib, *.vrmesh, *.vrscene, *.flt, *.hgt, *.r16, *.r32, *.img, *.tif, *.tiff, *.png, *.jpg, *.exr, *.pic, *.GoZ, *.vdb, *.usd, *.usda, *.usdc, *.bhclassic.lzma, *.bgeo.lzma, *.hclassic.bz2, *.bgeo.bz2, *.pc, *.pmap, *.geo.lzma, *.off, *.iges, *.igs, *.ply, *.obj, *.pdb, *.hclassic.lzma, *.lw, *.lwo, *.geo.bz2, *.bstl, *.eps, *.ai, *.stl, *.dxf, *.bhclassic.bz2, *.abc, *.fbx\n  针对“name+序号.文件类型”的序列文件，如以name_001.obj为第一帧的文件序列可以通过将命名修改为name_$F.obj进行动画序列的导入。\n  （2）通过Alembic节点导入\n  在节点工作区Geometry层级下创建Alembic节点。在Alembic节点的File name通道指定文件路径。\n  针对“name+序号.文件类型”的序列文件，如以name_001.abc为第一帧的文件序列可以通过将命名修改为name_$F.abc进行动画序列的导入。\n  （3）通过fbx character import节点导入\n  本文档推荐使用Houdini 18.5及其后续版本进行骨骼网格体的导入，其Kine FX模块的角色功能能够大幅简化工作流程。\n  在节点工作区Geometry层级下创建FBX Character Import节点，并通过FBX File通道进行骨骼网格体文件导入。\n  三、数据的读取与查看 1.通过Transform节点调整模型变换\n 检查数据的变换及空间比例，并通过Transform节点进行空间比例与位置的调整。  2.通过Convert/Unpack节点进行数据读取\n  对于导入的打包数据应使用Convert或Unpack转化或解包，从而读取到文件中的数据。此处推荐使用Convert进行转化，其能够指定文件类型，选择合适的模式或优化模式进行转化，如NURBS Curve、Polygon、Polygon Soup等。\n  粒子及网格数据推荐将类型选择为Polygon。曲线转换为NURBS Curve。\n  （1）Convert节点的使用\n 在Geometry层级下创建Convert节点，并在Convert to通道选择合适的类型即可。粒子及网格数据需要将类型选择为Polygon或Polygon Soup。曲线转换为NURBS Curve。  （2）Unpack节点的使用\n  在Geometry层级下创建Unpack并与数据节点连接即可。\n  转化或解包后可以在节点上按下鼠标中间查看文件数据概况。\n  3.Geometry Spreadsheet数据查看\n 通过Geometry Spreadsheet可以查看模型、点、顶点、基元层级上的具体属性。如果Geometry Spreadsheet只显示一组数据，请检查是否进行了Convert或Unpack处理。  四、数据可视化  本节分为“粒子可视化”、“曲线可视化”、“网格可视化”三个部分。  （一）粒子可视化\n1.粒子着色\n①使用AttributeVop节点进行粒子着色：\n  在Geometry层级下创建Attribute Vop节点，并双击进入VEX Builder层级。\n  创建Length节点并连接到v，将速度转换为浮点值。\n  创建Fit节点，将val与length的输出相连，并在节点上右键-Vex/Vop Option-Create input parameters将参数暴露至当前的Attribute Vop节点中方便调整。\n  创建Ramp Parameter节点，并将input连接至fit的输出端，将ramp连接至Geometry Vop Output的Cd端实现顶点色的输出。\n  回到Attribute Vop并选择，此时能够看到Fit节点和Ramp Parameter节点所暴露出来的参数。根据粒子的实际运动速度调整Fit输入速度的最大值。将Fit的输出值调整为0-1，用以Ramp的输入（Ramp默认拾取0-1的float值）。最后调整Ramp进行调色，完成粒子着色。\n  ②使用AttributeWrangle节点进行粒子着色：\n  在Geometry层级下创建Attribute Wrangle节点。\n  将Run Over 为Points，确保其运行在点层级下。\n  在VEXpression中输入：f@speed=fit(length(@v),0,ch(\u0026ldquo;in_max\u0026rdquo;),0,1);@Cd=chramp(\u0026ldquo;ramp\u0026rdquo;,@speed);（1.创建一个浮点属性@speed。使用length函数转换为浮点值，并使用fit函数将其输出值设定为0-1，为输入值的最大值设定为“in_max”。2.使用chramp函数基于上述创建的@speed属性进行颜色映射，并将其指定到顶点色。）\n  \tf@speed=fit(length(@v),0,ch(\u0026quot;in_max\u0026quot;),0,1);\r@Cd=chramp(\u0026quot;ramp\u0026quot;,@speed)\r  选择VEXpression右侧（如图中黄色框1中的按钮）Creates spare parameters for each unique call of ch()按钮，根据ch函数创建参数。\n  根据粒子的实际运动速度的最大值调整in_max参数，通过Ramp调色，完成粒子着色。\n  2.粒子缩放\n使用AttributeWrangle节点设置粒子大小\n  Houdni中粒子大小属性为浮点属性@pscale。\n  创建一个AttributeWrangle节点，确保其Run Over为Points层级，并在VEXpression输入@pscale=0.2;将粒子大小设置为0.2或一个合适的值，该属性可以直接被渲染器读取，并默认渲染为一个相应大小的sphere。\n  \t@pscale=0.2;\r3.粒子网格化\n使用ParticleFluidSurface进行粒子网格化\n  粒子转网格主要通过Geometry层级下的Particle Fluid Surface节点完成。调整Paticle Separation以控制生成网格的距离阈值。\n  如需要对网格进行速度着色则应关闭Particle Fluid Surface的Adaptivity，保证网格布线均匀（@Cd是顶点色属性，需要足够数量且均匀的顶点分布以确保着色效果）。\n  在Transfer Attributes通道下增加Cd属性。\n  最后可以添加File Cache节点并在Geometry File通道指定一个路径进行网格文件的缓存。\n  使用MeshlessSkinning工具进行粒子网格化\n txt格式的粒子数据可以使用MeshlessSkinning工具进行网格化。具体使用方法如图所示：  （二）曲线可视化\n1.曲线网格化\n  曲线转网格主要通过Geometry层级下的Sweep节点完成。该节点需要一条目标曲线和一个扫描曲线进行工作。\n  首先将abc格式的曲线文件通过Alembic进行导入，而后使用convert节点将其转换为NURBS Curve类型（详情请见本文档“二、数据文件的导入”、“三、数据读取与查阅”）。\n  创建一个Circle节点作为扫描曲线，并通过Uniform Scale通道调节其缩放。\n  创建一个Sweep节点。将导入的目标曲线数据连接到输入端1，将Circle节点连接到输入端2。如需要进行贴图，可以在UVs and Attributes标签下勾选Compute UVs。\n  创建UVquickshade节点可视化检查UV。\n  （三）网格可视化\n1.UV处理流程\n 对于需要进行贴图绘制但没有UV的动画序列，可以先通过时间冻结或导出模型的方式选取其中一帧进行UV拆分，而后基于顶点序号使用AttributeCopy节点进行UV属性的拷贝。  2.UV展开\n（1）houdini UV展开\n  通过UV unwrap节点进行UV展开。\n  添加UV layout节点进行UV排布。\n  (2)其他方式的UV展开\n  您可以通过Maya、RizomUV、Zbrush、Substance Painter等软件进行手动或自动的UV展开。\n  UV展开请查阅相关软件具体说明。\n  3.使用AttributeCopy进行UV属性的拷贝\n  在Geometry层级下创建AttributeCopy节点，将原模型序列连接至输入端1，将完成UV展开的模型连接至输入端2。\n  设定Attribute Name通道为uv，完成uv属性的传递。\n  五、渲染 1.渲染概述：\n  Houdini中渲染方案较多，如Mantra、Arnold、V-Ray、Redshift以及最新的Karma等。本文档以Vray为例，对最为重点和核心的内容进行渲染指南和说明。\n  在渲染工作中主要需要完成“渲染设置”、“摄像机”、“灯光”、“材质”四部分工作。\n  本文档目前将主要以V-Ray渲染器为例进行讲解，其具有效率高、易学习的特点，能够快速上手，并适合3dsMax、Maya等平台用户进行快速迁移与查阅。此外其能够兼容到其他支持V-Ray Sence的三维平台，为后续的工作创造更大的空间。\n  2.渲染设置\n（1）渲染器指定\n  在Objects层级下创建Ropnet节点，并双击进入。详情可参见: https://docs.chaos.com/display/VRAYHOUDINI/out+Network\n  创建V-ray Renderer节点以指定渲染器，创建完成后将自动创建V-ray Ipr节点。\n  （2）V-Ray渲染器基本设置\n①Export标签\n  Export-Render Device选项卡：此部分可以选择渲染模式，如CPU/CUDA/RTX等，注意GPU渲染可能会不支持某些渲染特性。详情请参见: https://docs.chaos.com/display/VRAYHOUDINI/Set+Up+GPU+Rendering\n  Export-IPR选项卡：1.Use Denoiser开启降噪，其能够在较低的渲染采样下得到较高的渲染质量，提升渲染效率。2.Use Render Elements开启渲染元素，可根据是否需要多通道渲染酌情勾选。\n  ②Images标签\n  Images-File Path：指定渲染路径与渲染文件的格式，注意渲染器会自动识别文件名后缀的格式。如：G:/../ImageName.${AOV}.0001.png将会被渲染为.png的图像格式。\n  Render Elements：指定所需要使用的Render Elements，如：/obj/ropnet1/renderElements\n  ③Render-Sampler标签\n 将Render-Sampler标签下的Type由Progressive改为Bucket将在最终渲染时在一定程度上减少噪点。  ④Render-Global Illumination标签\n 将On选项勾选，开启全局光，产生光子反弹的效果，得到更接近真实的照明效果。注意其在得到更好的光照效果的同时大幅增加了渲染时间。可以根据项目需求决定是否开启全局光照明，开启该选项后需要注意调节Sampler标签下的采样值，以减少噪点。  （3）多通道渲染\n  如有进行后期合成的需求，则需要在Ropnet下创建Render Elements渲染元素节点，并在V-Ray Renderer节点的Image标签下的Render Elements通道指定此节点进行激活，以启用渲染通道。\n  关于分层渲染，其内容较为繁杂，详情请移步Vray帮助文档进行了解: https://docs.chaos.com/display/VRAYHOUDINI/List+of+Supported+Render+Elements\n  3.摄像机\n  在Objects层级下创建一个Camera节点，并选取一个合适的角度对对象进行拍摄，注意合理的构图能够对数据的展示和画面的美观程度进行较大的提升。\n  在View标签下调节Resolution，此分辨率为最终渲染图的分辨率。此外此标签下还有摄像机的投影模式、焦距、裁切等重要参数。您可以根据项目的需求酌情设置。\n  4.灯光\n  灯光在渲染中较为重要，合理的布光可以有效提升画面表现效果，并可能减少噪点。\n  本文档建议首先使用VrayLightDome节点创建穹顶灯，并勾选Use Texture 设置基于HDRI贴图的环境照明。\n  如需进行自定义打光，您可以在HDRI的基础照明之上创建VrayLight Rectangle节点，用面光源完成主光、补光等灯光环境的创建。详情请参见: https://docs.chaos.com/display/VRAYHOUDINI/Lights\n  4.材质\n  在Objects层级下创建一个Matnet节点并双击进入。详情请参见: https://docs.chaos.com/display/VRAYHOUDINI/mat+Network\n  创建V-ray Material Builder节点并进入。\n  创建V-Ray Material节点，该节点内容较多，您可以查阅官方网站根据图片了解和对比各参数的效果: https://docs.chaos.com/display/VRAYHOUDINI/V-Ray+Material\n  ①Diffuse标签：Diffuse控制漫反射颜色，可以在材质节点中调节颜色，或创建V-Ray User Color及V-Ray Image File节点完成颜色设置。Opacity不透明度，可以使用V-Ray Image File连入一张图像作为遮罩控制物体的透明度属性。\n  ②Bump标签：Bump Map通道可以指定一张凹凸贴图或法线贴图以模拟物体表面的凹凸细节。\n  ③Reflection标签：可以在Color通道调节反射颜色，并在Glossiness调节材质光泽度以表现不同的质感。\n  V-Ray image File节点可以读取图像文件作为贴图。\n  User Color用户颜色：该节点可以将顶点色（或您创建的其他属性），即Houdini中的Cd属性进行渲染。主要针对需要顶点色着色的粒子、网格等对象。您可以创建V-Ray UserColor节点，将Attribute设置为Cd以读取顶点色，并连接至V-ray Material的Diffuse通道。\n  六、合成  在PeriDyno中，主要使用Adobe AfterEffects进行序列帧的合成、调色，并最终输出成视频。  "
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/pbf/",
	"title": "基于位置约束的方法",
	"tags": [],
	"description": "粒子系统-流体-PBF
",
	"content": "1. 简介 基于位置约束的方法，即PBF（Position Based Fluid）法，是一种快速、高效、非物理的不可压缩流体仿真方法。该方法通过直接对流体粒子施加恒定密度约束来更新粒子的位置与速度，进而实现不可压缩性流体运动的模拟。\n2. 方法 流体在运动过程中需要时刻保持密度恒定，即恒定密度约束。粒子$i$的恒定密度约束的具体形式为：$\\rho_i = \\rho_0$。其中$\\rho_0$为流体的静止密度，在PeriDyno中该静止密度的取值一般为$1000$；$\\rho_i$为粒子$i$的密度，可通过基于核函数的SPH法插值计算获得，即：\n$$ {\\rho_i = \\sum_{j,r_{ij}\u0026lt;h}m_j \\cdot W(r_{ij},h)} $$ (公式1)\n其中，$r_{ij}$为粒子$i$与其邻域粒子$j$的间距，即：$r_{ij} = |\\mathbf{x}_i- \\mathbf{x}_j|$。因此粒子$i$的密度可以被视为粒子$i$及其邻域粒子$j$空间坐标作为变量的函数。因此可获得以流体粒子空间位置作为变量的恒定密度约束条件，即： $$ C_i(\\mathbf{x}) = \\frac{\\rho_i(\\mathbf{x})}{\\rho_0}-1=0 $$ (公式2)\n其中，$\\mathbf{x}$为包含有粒子$i$及其邻域粒子$j$空间位置坐标的矢量。\n若流体中粒子$i$位置上的不可压缩性条件被破坏：$\\rho_i \u0026gt; \\rho_0$，也即是 $C_i(\\mathbf{x}) \u0026gt; 0$ 则需要修正粒子$i$及其邻域粒子$j$的空间位置坐标，以保持粒子$i$位置附近的不可压缩性。\n$$ C_i(\\mathbf{x}+\\triangle \\mathbf{x}) = \\frac{\\rho_i(\\mathbf{x +\\triangle \\mathbf{x}})}{\\rho_0}-1=0 $$ (公式3)\n其中$\\triangle \\mathbf{x}$为粒子$i$及其邻域粒子$j$的空间位置修正矢量。\n粒子$i$及其邻域粒子$j$的空间位置修正矢量$\\triangle\\mathbf{x}$可以通过泰勒近似和牛顿法获得。略去推导过程，$\\triangle\\mathbf{x}$的计算式为：\n$$ {\\triangle \\mathbf{x_{i}}}= {\\frac{1}{\\rho_0}}\\sum_{j,r_{ij}\u0026lt;h}(\\lambda_j+\\lambda_i)\\nabla W(r_{ij}, h)， $$ $$ \\nabla W(r, h) = \\frac{\\mathrm{d} r }{\\mathrm{d} \\mathbf{x}} \\frac{\\mathrm{d} W(r ,h)}{\\mathrm{d} r} $$ (公式4)\n其中，$W$为SPH核函数；$\\lambda$的计算式为：\n$$ \\lambda_i = - \\frac{Ci(\\mathbf{x})}{\\sum_k|\\nabla_k C_i|^2} $$ (公式5)\n计算获得粒子空间位置修正量$\\triangle \\mathbf{x}$后，即可获得满足不可压缩性条件的粒子位置，按照该位置来更修正粒子位置，然后根据粒子位置修正量来更新粒子的速度，即$\\mathbf{v}^{new}_i=\\mathbf{v}^{old}_i + \\triangle \\mathbf{x_i}/{\\delta t}$，来模拟流体质点的惯性作用，即可完成当前帧流体粒子运动的模拟计算。\n一帧中仅计算一次粒子的位置修正量$\\triangle \\mathbf{x}$并不能很好地消除密度误差，为了获得更为精确的计算结果，常需要在一帧中多次迭代计算$\\triangle \\mathbf{x}$。\n\r3. 实现 PeriDyno中，PBF求解器的源文件为：\n\u0026#34;Engine/Dynamics/Module/DensityPBD.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/DensityPBD.h\u0026#34;; PBF求解器的输入为不满足恒定密度约束的流体粒子的位置，输出为满足恒定密度约束的粒子位置，以及惯性作用下的粒子速度。 a. 包含的模块：   SummationDensity（密度计算模块）\nstd::shared_ptr\u0026lt;SummationDensity\u0026lt;TDataType\u0026gt;\u0026gt; m_summation; DensityPBD求解器使用该模块用于计算粒子的质量密度，并以此来计算恒定密度约束条件下粒子位置的修正值。\n  SpikyKernel (核函数)\nSpikyKernel\u0026lt;Real\u0026gt; m_kernel; 该模块即为SPH法的核函数$W(r_{ij},h)$。\n  b. 变量：   NeighborList (邻域粒子列表)\nDEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;\u0026#34;); 为了实现粒子各项物理量及其微分量的插值计算，计算过程需要使用到粒子的邻域列表。该邻域列表需要在每一帧计算开始时预先由邻域查找模块生成，邻域查找模块的位置为：\n\u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.h\u0026#34; \u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.cu\u0026#34;   Velocity, Position (粒子速度与位置)\nDEF_ARRAY_IN(Coord, Velocity, DeviceType::GPU, \u0026#34;Input particle velocity\u0026#34;); DEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Input particle position\u0026#34;); Velocity为粒子的速度（$\\mathbf{v}$）；Position为粒子空间位置 ($\\mathbf{x}$)。\n  内部变量\nDArray\u0026lt;Real\u0026gt; m_lamda; DArray\u0026lt;Coord\u0026gt; m_deltaPos; m_lamda 为上述公式5中的 $\\lambda$； m_deltaPos为公式4中的 $\\triangle\\mathbf{x}$；\n  c. 参数： int IterationNumber = 5; Real RestDensity = 1000.0f; Real SamplingDistance = 0.005f; Real SmoothingLength = 0.01f; 上述参数的含义分别为：\n  IterationNumber： 迭代次数（迭代次数越多，计算结果越精确，每一帧的密度误差越小）； RestDensity： 静止密度（即公式2中的$\\rho_0$）； SamplingDistance： 粒子的初始间距； SmoothingLength： SPH法中的平滑距离/支持域半径，同时也是粒子的邻域半径。   d. 函数：  K_ComputeLambdas： 该函数为公式5，用于计算 $\\lambda$。  template \u0026lt;typename Real, typename Coord\u0026gt; __global__ void K_ComputeLambdas(...)  K_ComputeDisplacement： 该函数为公式4，用于计算 $\\triangle \\mathbf{x}$。  template \u0026lt;typename Real, typename Coord\u0026gt; __global__ void K_ComputeDisplacement(...)  DP_UpdateVelocity： 该函数为用于计算惯性作用下粒子的速度，即：$\\mathbf{v}^{new}_i=\\mathbf{v}^{old}_i + \\triangle \\mathbf{x_i}/{\\delta t}$。  template \u0026lt;typename Real, typename Coord\u0026gt; __global__ void DP_UpdateVelocity(...) 参考文献 [1] Macklin M , M Müller. Position based fluids[J]. Acm Transactions on Graphics, 2013, 32(4):1-12.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/vssph/",
	"title": "投影法",
	"tags": [],
	"description": "粒子系统-流体-投影法
",
	"content": "1. 简介 投影法是通过求解流体压强泊松方程来获取压强，来消除速度散度误差或密度误差的方法。该方法相比于PBF法虽然计算效率较低，需要使用更大的邻域半径以及更多的迭代次数才能保证仿真的稳定性，但该方法具有更高精度和仿真质量。\n2. 方法 当流体被压缩时，流体个别位置会产生速度散度误差或密度误差，此时流体需要产生相应的压强来抵抗压缩，消除散度误差和密度误差以保证不可压缩性条件。而压强泊松方程则可以根据散度误差、密度误差来计算流体的压强。以下是压强泊松方程的推导过程：\n  Step 1. 忽略掉粘性作用、体积力作用的离散化后的流体Navior Stokes方程形式为： $$ \\mathbf{v}_i^{new} = \\mathbf{v}_i^{old} - \\frac{\\delta t}{\\rho_0} \\nabla_i p\n$$ （公式1）\n  Step 2. 由于$\\mathbf{v}_i^{old}$是不满足不可压缩性条件的速度场，即：$\\nabla\\mathbf{v}_i^{old}\\ne0$ ,而待求的满足不可压缩性条件的速度场其散度应为零，即：$\\nabla\\mathbf{v}_i^{new}=0$。则对公式1的等式两端同时取散度，即可得到如下的压强泊松方程。 $$ \\nabla_i \\cdot \\frac{\\delta t}{\\rho_0} \\nabla p =-\\nabla \\cdot \\mathbf{v}_i^{old} $$ (公式2)\n  Step 3. 使用粒子对压强泊松方程中的二阶微分算符（拉普拉斯算符$\\nabla\\cdot\\nabla_i$）与一阶微分算符（散度$\\nabla\\cdot$）进行离散化，将压强泊松方程转化为线性系统。\n  Step 4. 由于压强泊松方程只考虑了速度散度误差，而没有考虑密度误差，因此需要对泊松方程的等式右端项进行修正，一种推荐的方法即是： $$ \\nabla_i \\cdot \\frac{\\delta t}{\\rho_0} \\nabla p =-\\nabla \\cdot \\mathbf{v}_i^{old} + \\Lambda *\\max(\\frac{\\rho_i}{\\rho_0}-1,0) $$ (公式3)\n其中系数$\\Lambda$为常数。\n  Step 5. 带入流体的边界条件（包括气液边界条件和固液边界条件），对原压强泊松方程的系数矩阵进行修正，该泊松方程会转化为对称正定的线性系统。\n  Step 6. 使用共轭梯度法、雅克比法等迭代算法可快速求解这一离散化后的压强泊松方程，获得当前帧中各粒子的压强值。\n  Step 7. 将粒子压强带入到公式1中，修正流体粒子的速度值，获得满足不可压缩性条件的粒子速度$\\mathbf{v}_i^{new}$。\n  Step 8. 根据粒子速度$\\mathbf{v}_i^{new}$来更新粒子位置，即：$\\mathbf{x}_i^{new} = \\mathbf{x}_i^{old}+ \\mathbf{v}_i^{new}*\\delta t$\n  以上即为基于SPH投影法的实现流程。投影法中的压强二阶微分项和速度散度项离散化方法种类繁多，不同离散化方法也有不同的特性。目前PeriDyno中选用了变分框架下使用staggered粒子的微分离散化方案来构建投影法求解器，相比其它方法，该离散化方案具有更好的收敛性、稳定性，能够有效抑制SPH的零能问题和拉伸失稳问题的影响。具体的实现方法可参考文献。\n3. 实现 PeriDyno中，投影法求解器的源文件为：\n\u0026#34;Engine/Dynamics/Module/VariationalApproximateProjection.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/VariationalApproximateProjection.h\u0026#34;; 投影法求解器的输入为不满足不可压缩性条件的流体粒子位置和速度场，输出为满足不可压缩性条件、同时可消除密度偏移误差的的速度场。 a. 变量：   Attribute (粒子属性)\nDEF_ARRAY_IN(Attribute, Attribute, DeviceType::GPU, \u0026#34;\u0026#34;); 为了准确地对流体施加固壁边界条件，该投影法中的固体需要使用Ghost粒子进行采样。而为了区别固体粒子与流体粒子，则需要引入属性数组来对粒子进行标记。\n  Normal (固体Ghost粒子法向量)\nDEF_ARRAY_IN(Coord, Normal, DeviceType::GPU, \u0026#34;\u0026#34;); 为了准确地对流体施加滑移（Free-slip）或无滑移(No-slip)流固边界条件，固体Ghost粒子需要具有法向量参数。\n  NeighborList (邻域粒子列表)\nDEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;\u0026#34;); 为了实现粒子各项物理量及其微分量的插值计算，计算过程需要使用到粒子的邻域列表。该邻域列表需要在每一帧计算开始时预先由邻域查找模块生成，邻域查找模块的位置为：\n\u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.h\u0026#34; \u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.cu\u0026#34;   b. 函数：   泊松方程离散化相关函数\nVC_ComputeAlpha(...) VC_ComputeDiagonalElement(...) VC_ComputeAx(...) 以上三个函数为泊松方程（公式2）中压强二阶微分项离散化的相关函数。\nVC_ComputeDivergence(...) 该函数为泊松方程速度散度的离散化相关函数，用于计算粒子的速度散度误差。\nVC_CompensateSource(...) 该函数用于补偿压强泊松方程的源项（即：公式2泊松方程的右端项），对应于第2节“方法”中的step 3。SPH投影法如果仅仅修正速度散度误差并不能有效地保证不可压缩性条件，因为流体的密度会逐渐发生漂移，引入严重的错误。该函数能够有效地避免流体的体积丢失问题。\nVC_UpdateVelocity1rd(...) 该函数根据粒子压强来计算粒子的压强梯度，并更新流体粒子的速度（对应于第2节“方法”中的step 7 与 step 8 ），计算过程中考虑了固壁边界对于流体的作用。\n参考文献 [1] He X, Wang H, Wang G, et al. A Variational Staggered Particle Framework for Incompressible Free-Surface Flows[J]. arXiv preprint arXiv:2001.09421, 2020.\n  "
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/artificalviscosity/",
	"title": "人工粘性",
	"tags": [],
	"description": "粒子系统-流体-人工粘性
",
	"content": "1. 简介 粘性是流体的重要特性。当流体产生了形变的趋势时（速度的梯度：$\\nabla \\mathbf{v}$），流体的粘滞力就会产生并阻滞流体发生形变。在粒子系统中，粘性还有另外一项功能，即是削弱流体个别粒子过于剧烈、高频的运动，使流体粒子具有相一致的运动，进而提高仿真稳定性。\nPeriDyno中包含了一种改进与XSPH法的人工粘性求解器。虽然该粘性求解器并不是基于物理的求解器，但它能够非常稳定地够模拟大粘性流体，而且能够有效提高粘性流体的仿真稳定性，具有十分优异的计算效率。\n2. 方法 比较经典的人工粘性求解算法是XSPH法，该方法通过削弱相邻流体粒子之间的速度差值来保证粒子的运动速度保持接近，来使流体的速度场分布趋于平滑。其计算公式如下所示。\n$$ \\mathbf{v_i}^{new} = \\mathbf{v_i}^* + \\epsilon \\sum_{j, r_{ij}\u0026lt;h} \\frac{m_j}{\\rho_j} \\left (\\mathbf{v_j}^*-\\mathbf{v_i}^*\\right )W(r_{ij},h) $$\n（公式1） 然而该方法存在较为严重的问题，即控制粘性强度的稀疏$\\epsilon$的取值不能大于1，因此该方法只能用于提高低粘性流体的稳定性，而无法模拟大粘性流体。\n因此PeriDyno在原XSPH人工粘性算法基础上进行了改进，使其能够稳定模拟大粘性流体。改进后的人工粘性计算公式如下。\n$$ \\mathbf{v_i} ^{new}=\\frac{1}{b+1}\\left ( \\mathbf{v_i}^* + b\\sum_{j, r_{ij}\u0026lt;h}\\mathbf{v_i}^*W\\left ( r_{ij},h \\right ) \\right ) $$\n（公式2） 其中$b$的计算式为：\n$$ b = \\epsilon\\frac{\\delta t }{h} 。 $$\n（公式3） 为了保证仿真的稳定性，需要在一帧中多次迭代计算公式2。\n\r3. 实现 PeriDyno中，人工粘性求解器的源码文件为：\n\u0026#34;Engine/Dynamics/Module/ImplicitViscosity.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/ImplicitViscosity.h\u0026#34;; 人工粘性求解器的输入输出均为流体粒子速度。但相比于输入，输出的粒子速度在空间中的分布更为平滑。 a. 变量：   NeighborList (邻域粒子列表)\nDEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;\u0026#34;); 为了实现粒子各项物理量及其微分量的插值计算，计算过程需要使用到粒子的邻域列表。该邻域列表需要在每一帧计算开始时预先由邻域查找模块生成，邻域查找模块的位置为：\n\u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.h\u0026#34; \u0026#34;Engine\\Framework\\Topology\\NeighborPointQuery.cu\u0026#34;   Velocity, Position (粒子速度与位置)\nDEF_ARRAY_IN(Coord, Velocity, DeviceType::GPU, \u0026#34;Input particle velocity\u0026#34;); DEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Input particle position\u0026#34;); Velocity为粒子的速度（$\\mathbf{v}$）；Position为粒子空间位置 ($\\mathbf{x}$)。\n  b. 参数： DEF_VAR(Real, Viscosity, 0.05, \u0026#34;\u0026#34;); DEF_VAR(int, InterationNumber, 3, \u0026#34;\u0026#34;); DEF_VAR_IN(Real, SmoothingLength, \u0026#34;\u0026#34;);  Viscosity: 控制粘性强弱的系数； IterationNumber: 公式2的迭代次数； SmoothingLength: 平滑距离（支持域半径）。  c. 函数： template\u0026lt;typename Real, typename Coord\u0026gt; __global__ void IV_ApplyViscosity(...) 该函数的功能是计算公式2，获得粘性作用下的粒子速度。\n参考文献 Schechter H, Bridson R. Ghost SPH for animating water[J]. ACM Transactions on Graphics (TOG), 2012, 31(4): 1-8.\n"
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/surfacetension/",
	"title": "表面张力",
	"tags": [],
	"description": "粒子系统-流体-表面张力
",
	"content": "1. 简介 表面张力的作用会使流体表面积和曲率趋向于最小，对于小尺度流体的运动形态有较大的影响。PeriDyno目前使用的表面张力求解器是基于自由表面能量函数方法实现的，该方法相比于其它方法稳定性更好，而且不会引入过多的计算量。\n2. 方法 表面张力的大小取决于流体气液表面的曲率，而流体表面的曲率（$\\nabla_i c$）可以通过以下公式计算，即： $$ \\nabla_i c = \\frac{\\sum_j Vj \\nabla_i W(r_{ij},h)}{\\sum_j Vj W(r_{ij},h)} $$ （公式1）\n由自由表面能最小化模型，流体的表面张力可通过如下公式计算获得： $$ F_i = 0.25 \\kappa \\sum_j V_i V_j \\left ( |\\nabla_i c |^2 + |\\nabla_j c |^2 \\right ) \\nabla_i W(r_{ij},h) $$ （公式2）\n上式中的 $V、\\kappa$ 分别为粒子的体积以及控制表现张力作用强度的系数。\n在获取到粒子的表面张力后，即可更新流体粒子的位置，实现表面张力作用下流体运动的模拟。\n3. 实现 PeriDyno中，表面张力求解器的源码文件为：\n\u0026#34;Engine/Dynamics/Module/SurfaceTension.cu\u0026#34;; \u0026#34;Engine/Dynamics/Module/SurfaceTension.h\u0026#34;; "
},
{
	"uri": "https://peridyno.github.io/zh/topics/particlesystem/others/",
	"title": "其它模块",
	"tags": [],
	"description": "粒子系统-流体-其它模块
",
	"content": "除不可压缩性、粘性、表面张力核心求解器外，粒子系统中还包含有辅助模块。本节将对这些辅助模块进行简要的介绍。\n1. 粒子发射器 每一帧都会输出一定量的流体粒子。现阶段PeriDyno中包含有两种粒子发射器，分别为方形粒子发射器和圆形粒子发射器，在PeryDyno工程中的路径为：\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/SquareEmitter.cu\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/SquareEmitter.h\u0026#34;; 以及\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/CircularEmitter.cu\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/CircularEmitter.h\u0026#34;; 这两种粒子发射器有共同的基类，即：\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/ParticleEmitter.cu\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/ParticleEmitter.h\u0026#34;; 两种发射器都可以通过代码或在GUI界面中修改粒子间距（samplingDistance）、粒子初速度(initialVelocity)、方向(Rotation)，以及发射器的尺寸大小（weight/hight/Radius）。\n2. 边界约束（节点） 边界约束节点是粒子所在空间中的边界。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/BoundaryConstraint.h\u0026#34;; 当该模块检测到粒子穿入边界之外时，粒子会被修正边界附近，同时会修正相应粒子的速度，对粒子施加滑移边界条件、无滑移边界条件或结于两种条件之间的条件。粒子的速度修正方式由参数 TangentialFriction （切向摩擦系数） 与 NormalFriction（法向摩擦系数）来控制。\n为了快速地检测边界与粒子的距离，该模块中的边界为有向距离场形式（SDF）。边界约束节点模块中预制了解析式生成的球体边界（Sphere）和六面体边界（Cube），此外也可以通过函数load直接载入有向距离场模型文件。\n该节点中，也可以设置粒子可运动的空间是位于封闭边界的内部或外部（inverted）。\n3. 核函数 SPH法中的核函数。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/Kernel.h\u0026#34;; 该模块中包含有以下几类核函数：\n SpikyKernel，较为尖锐的核函数； ConstantKernel，常数； SmoothKernel，平滑核函数； CorrectedKernel，修正后的核函数（避免粒子距离过近而导致奇点问题） CubicKernel，三次样条函数形式的核函数； QuarticKernel，四次样条函数形式的核函数。  4. 粒子速度耗散模块 按一定比例耗散粒子速度的模块。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/LinearDamping.h\u0026#34;; 5. 粒子积分模块 即粒子速度、位置更新模块。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/ParticleIntegrator.h\u0026#34;; 根据粒子所受到的力更新其速度，并根据其速度更新其位置。\n6. 密度计算模块 用于计算粒子的质量密度的模块。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/SummationDensity.h\u0026#34;; 该模块也可根据粒子的初始间距、静态质量，计算出每个粒子的质量。\n7. 粒子属性 为了模拟流体以外的材料及其与流体之间的耦合，场景中的粒子需要标记为不同的材料属性和可运动属性。这一特性的标记见Attribute文件，即：\n\u0026#34;Engine/Dynamics/ParticleSystem/Attribute.h\u0026#34;; 粒子系统中，粒子可以有多种属性，比如：流体（fluid）、刚体(rigid)、弹性材料(elastic)、塑性材料(plastic)。此外也可将粒子标记为可运动(dynamic)、不可运动(fixed)、通过关键帧控制的运动(passive)等。\n8. 流体模型 流体完整的仿真流程被封装在了model文件中，比如ProjectionBasedFluidModel、PositionBasedFluidModel。这类model文件中包含有粒子邻域查找、不可压缩性计算、粘性计算、速度位置更新等诸多流程。\n\u0026#34;Engine/Dynamics/ParticleSystem/Module/PositionBasedFluidModel.h\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/Module/ProjectionBasedFluidModel.h\u0026#34;; 9. 节点文件 节点文件中包含有仿真场景中所需要用到所有全局变量，例如场景所有粒子的空间位置数组（Position）、速度数组（Velocity）、力数组（Force）、粒子属性数组（Attribute）,法向量数组（Norm）等。同时也包含了管理、分配、释放这些变量所需的函数。\n\u0026#34;Engine/Dynamics/ParticleSystem/ParticleFluid.h\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/ParticleSystem.h\u0026#34;; \u0026#34;Engine/Dynamics/ParticleSystem/GhostFluid.h\u0026#34;; "
},
{
	"uri": "https://peridyno.github.io/zh/",
	"title": "泛动引擎",
	"tags": [],
	"description": "",
	"content": "泛动引擎（PeriDyno）帮助文档 "
},
{
	"uri": "https://peridyno.github.io/zh/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/zh/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]