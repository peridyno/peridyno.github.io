[
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/",
	"title": "HeightFiled",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_clothdrop/",
	"title": "CapillaryWave",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/heightfield/gl_capillarywave/",
	"title": "CapillaryWave",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_bricks/",
	"title": "Bricks",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/sph/gl_ghostsph/",
	"title": "SPH",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/peridynamics/gl_cloth/",
	"title": "Cloth",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/tutorials/gl_glfwgui/",
	"title": "Cloth",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/installation/window/",
	"title": "Window",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/overview/",
	"title": "Overview",
	"tags": [],
	"description": "An overview of Peridyno.
",
	"content": "What is it? Peridyno is short fo Physics-based Interactive Kinematics Architecture. It is an open source node-based architecture targeted at real-time simulation of versatile physical materials. Currently, it supports simulating physical phenomena ranging from fluids, elastic objects and fracture, etc. It is higly modualized and can also help the research community develop novel algorithms.\nWhat can I expect from Peridyno? Followings are a set of features making Peridyno unique to simulate a complex physical senario in a efficient way:\n  Template programming: Peridyno support a wide class of commonly used data structre in the form of templates.\n  Highly modularized: The whole is modularized from top to bottom, therefore, custom behaviors can easily obtained by extending existing components.\n  Complex coupling: It supports the coupling of a variety of different physical materials.\n  High performance: The architecture is highly optimized to improve the execuation performance.\n  Where should I go next? Give your users next steps from the Overview. For example:\n Getting Started: Get started with Peridyno Examples: Check out some example code!  "
},
{
	"uri": "https://peridyno.github.io/en/framework/interaction/",
	"title": "Scene Graph",
	"tags": [],
	"description": "",
	"content": "The scene graph mainly includes two functions: node management and node operation logic management.\n1、Node management Node management functions include:\n add node  template\u0026lt;class TNode, class ...Args\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(Args\u0026amp;\u0026amp; ... args) template\u0026lt;class TNode\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(std::shared_ptr\u0026lt;TNode\u0026gt; tNode) Where TNode represents the derived type of the node, and Args is the parameter required by the node construction process\n delete node  void deleteNode(std::shared_ptr\u0026lt;Node\u0026gt; node); 2、Node operation logic management   Update run queue   void updateExecutionQueue(); The timing of the update mainly depends on whether the nodes in the scene graph and the connection relationship have changed. Once any item is changed, the node execution queue of the scene will update the run queue first the next time the node function is executed.\n update node status  void propagateNode(std::shared_ptr\u0026lt;Node\u0026gt; node); When the running state of a specific node changes, for example, the configuration parameters of the node are changed, the scene graph can update the state of all subsequent nodes that depend on the node by calling the propagateNode() function.\n3、Function expansion To be added\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/framework/pipeline/",
	"title": "Scene Graph",
	"tags": [],
	"description": "",
	"content": "The scene graph mainly includes two functions: node management and node operation logic management.\n1、Node management Node management functions include:\n add node  template\u0026lt;class TNode, class ...Args\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(Args\u0026amp;\u0026amp; ... args) template\u0026lt;class TNode\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(std::shared_ptr\u0026lt;TNode\u0026gt; tNode) Where TNode represents the derived type of the node, and Args is the parameter required by the node construction process\n delete node  void deleteNode(std::shared_ptr\u0026lt;Node\u0026gt; node); 2、Node operation logic management   Update run queue   void updateExecutionQueue(); The timing of the update mainly depends on whether the nodes in the scene graph and the connection relationship have changed. Once any item is changed, the node execution queue of the scene will update the run queue first the next time the node function is executed.\n update node status  void propagateNode(std::shared_ptr\u0026lt;Node\u0026gt; node); When the running state of a specific node changes, for example, the configuration parameters of the node are changed, the scene graph can update the state of all subsequent nodes that depend on the node by calling the propagateNode() function.\n3、Function expansion To be added\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/framework/scenegraph/",
	"title": "Scene Graph",
	"tags": [],
	"description": "",
	"content": "1、Schematic diagram of the scene graph Peridyno manages all elements including Field, Module and Field in a unified manner through Scene Graph。The following figure shows a scene graph with four simulation nodes:\n2、How to create a scene graph Next, take fluid simulation as an example to show how to use peridyno to create a complete demo. The complete process consists of the following four steps:\n  Create a scene graph\nstd::shared_ptr\u0026lt;SceneGraph\u0026gt; scn = std::make_shared\u0026lt;SceneGraph\u0026gt;();   Add a simulation node\n//Add a fluid simulation node auto fluid = scn-\u0026gt;addNode(std::make_shared\u0026lt;ParticleFluid\u0026lt;DataType3f\u0026gt;\u0026gt;()); fluid-\u0026gt;loadParticles(Vec3f(0.5, 0.2, 0.4), Vec3f(0.7, 1.5, 0.6), 0.005); //add boundary constraint Node auto boundary = scn-\u0026gt;addNode(std::make_shared\u0026lt;StaticBoundary\u0026lt;DataType3f\u0026gt;\u0026gt;()); boundary-\u0026gt;loadSDF(getAssetPath() + \u0026#34;bowl/bowl.sdf\u0026#34;, false); //Add particle visualization node auto visualizer = scn-\u0026gt;addNode(std::make_shared\u0026lt;GLPointVisualNode\u0026lt;DataType3f\u0026gt;\u0026gt;());   Set the node data connection relationship\n//Fluid Node --\u0026gt; Boundary Constraint Node fluid-\u0026gt;connect(boundary-\u0026gt;importParticleSystems()); //Fluid Node --\u0026gt; Visualization Node fluid-\u0026gt;connect(visualizer-\u0026gt;importParticleSystem());   Create an application interface. PeriDyno currently supports both GLFW and QT application interfaces. Taking GLFW as an example, the algorithm flow is as follows:\nGlfwApp window; //Set up the simulation scene window.setSceneGraph(scn); //Create application interface window.createWindow(1024, 768); window.mainLoop(); \rThe current version requires that the createWindow() function boundary must be made after the setSceneGraph() and setRenderEngine() function calls. If the rendering engine is not explicitly set, the built-in OpenGL-based GLRenderEngine is used by default.\r \rThe effect diagram is as follows：\n  Similarly, if using the app interface：\nQtApp window;\r//Set up the simulation scene\rwindow.setSceneGraph(scn);\r//Create application interface\rwindow.createWindow(1024, 768);\rwindow.mainLoop();\r对应的效果图下，做的节点编辑器展示了所有的功能节点以及节点之间的链接 关系，通过连接/断开对应的连线可以改变仿真场景图的节点执行顺序。\n完整示例代码参见examples/GL_ParticleFluid和examples/Qt_GLVisualModule。\n\r"
},
{
	"uri": "https://peridyno.github.io/en/framework/scenegraph/scenegraph/",
	"title": "Scene Graph",
	"tags": [],
	"description": "",
	"content": "The scene graph mainly includes two functions: node management and node operation logic management.\n1、Node management Node management functions include:\n add node  template\u0026lt;class TNode, class ...Args\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(Args\u0026amp;\u0026amp; ... args) template\u0026lt;class TNode\u0026gt; std::shared_ptr\u0026lt;TNode\u0026gt; addNode(std::shared_ptr\u0026lt;TNode\u0026gt; tNode) Where TNode represents the derived type of the node, and Args is the parameter required by the node construction process\n delete node  void deleteNode(std::shared_ptr\u0026lt;Node\u0026gt; node); 2、Node operation logic management   Update run queue   void updateExecutionQueue(); The timing of the update mainly depends on whether the nodes in the scene graph and the connection relationship have changed. Once any item is changed, the node execution queue of the scene will update the run queue first the next time the node function is executed.\n update node status  void propagateNode(std::shared_ptr\u0026lt;Node\u0026gt; node); When the running state of a specific node changes, for example, the configuration parameters of the node are changed, the scene graph can update the state of all subsequent nodes that depend on the node by calling the propagateNode() function.\n3、Function expansion To be added\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/heightfield/",
	"title": "HeightFiled",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/rigidbody/gl_collisiondetectionin3d/",
	"title": "Two Boxes",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_clothontable/",
	"title": "Ocean",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/heightfield/gl_ocean/",
	"title": "Ocean",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_connection/",
	"title": "Connection",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/tutorials/gl_instancevisualizer/",
	"title": "Instance Visualizer",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/installation/",
	"title": "Installation",
	"tags": [],
	"description": "Tutorials on how to set up Peridyno and run examples on both Windows and Linux.
",
	"content": "Tutorials on how to set up Peridyno.\nPlatforms Windows 10: fully tested\nLinux: should work as well, yet not guranteed.\nPrerequisites IDE:\n Visual studio 2017+  CUDA:\n Latest tests were done based on CUDA Toolkit 11.4, should be compatible will other old version.  Graphics:\n glad: https://github.com/Dav1dde/glad.git glfw: https://github.com/glfw/glfw imgui: https://github.com/ocornut/imgui  Optional:\n Qt: https://download.qt.io/ VTK: https://github.com/Kitware/VTK Alembic: https://github.com/alembic/alembic Imath: https://github.com/AcademySoftwareFoundation/Imath  Installation Aside from those optional, other libraries are integrated inside the project to simplify the installation. Use the following git command to down the project as well as other dependences.\ngit clone --recursive https://github.com/peridyno/peridyno.git\rBuild the project Check whether CMake has been installed on your system, if not, visit https://cmake.org/download/ to download the lastest version.\nPreferred: Run cmake-gui.exe, set the top two entries with the source code and binary directories. Configure the libararies you want to build, then click the Generate button to build the project.\nA more convient way to build the project with a default setting is as follows\ncd peridyo/build cmake ..\rExamples Optional library QT and VTK installation QT installation: Recommended downloadQT5.13.0 or above\n1、Register account：\n2、Components to be selected：\n3、Cmake project, and check the QT related options：\nVTK installation: Recommended downloadVTK8.2.0 or above\n1、Download VTK source code\n2.勾选Moduel中QT相关的这些选项：\n3.设置OpenGL相关选项： 4.然后点Generate再打开VS项目进行生成\n5.打开VTK的VS工程。生成-\u0026gt;批生成 ALL_BUILD Release x64 栏 勾选 √\u0026mdash;-\u0026gt;点击【生成】 6.把刚刚勾选的ALL_BUILD Release后面的√去掉，下拉，在INSTALL Release后面勾选\n7.将VTK路径加入到Path中 License Peridyno\u0026rsquo;s default license is the Apache 2.0 (See LICENSE).\nExternal libraries are distributed under their own terms.\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/peridynamics/gl_elasticity/",
	"title": "Particle-based Elastic Objects",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/installation/linux/",
	"title": "Linux",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/framework/pipeline/fieldsync/",
	"title": "Keyboard Interaction",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/framework/pipeline/simulation/",
	"title": "Keyboard Interaction",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/framework/pipeline/rendering/",
	"title": "Mouse Interaction",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/framework/scenegraph/nodes/",
	"title": "Node",
	"tags": [],
	"description": "",
	"content": "1、Function introduction A node is a collection of algorithms with relatively independent functions that encapsulate specific function modules. It is mainly composed of input node, input data, output node, output data, state variable and function module.\n2、How to implement a custom function node Creating a complete node consists of the following steps:\n  define input nodes (optional)\nDEF_NODE_PORT(T, name, desc)\rThis macro defines a single node input, where T represents the node type, name represents the name, desc represents the input node description information, and the access method is import+data name.\nDEF_NODE_PORTS(T, name, desc)\rThis macro definition can define an array of input nodes, which can access 0 to any number of nodes of type T as input. The access method is import+data name+s.\n  define input data (optional)\nDEF_VAR_IN(T, name, desc)\rDefine a single data type with input type T and name name as input.\nDEF_ARRAY_IN(T, name, device, desc)\rDefine a one-dimensional array of type T and name name as input on the device (CPU/GPU) device.\nDEF_ARRAY2D_IN(T, name, device, desc)\rDefine a two-dimensional array of type T and name as input on the device (CPU/GPU) device.\nDEF_ARRAY3D_IN(T, name, device, desc)\rDefine a three-dimensional array of type T and name name as input on the device (CPU/GPU) device.\nDEF_INSTANCE_IN(T, name, desc)\rDefine an instance of input type T and name name as input.\nDEF_ARRAYLIST_IN(T, name, device, desc)\rDefine a one-dimensional dynamic list array of type T and name name as input on the device (CPU/GPU) device.\n  define output data (optional)\nDEF_VAR_OUT(T, name, desc)\rDefine a single data type with input type T and name name as output.\nDEF_ARRAY_OUT(T, name, device, desc)\rDefine a one-dimensional array of type T and name name as output on the device (CPU/GPU) device.\nDEF_ARRAY2D_OUT(T, name, device, desc)\rDefine a two-dimensional array of type T and name name as output on the device (CPU/GPU) device.\nDEF_ARRAY3D_OUT(T, name, device, desc)\rDefine a three-dimensional array of type T and name name as output on the device (CPU/GPU) device.\nDEF_INSTANCE_OUT(T, name, desc)\rDefine an instance of input type T and name name as output.\nDEF_ARRAYLIST_OUT(T, name, device, desc)\rDefine a one-dimensional dynamic list array with type T and name name as output on the device (CPU/GPU) device.\n  define state variables\nDEF_VAR(T, name, value, desc)\rDefine a single data type with type T, name as name, and initial value type as value as a state variable.\nDEF_ARRAY_STATE(T, name, device, desc)\rDefine a one-dimensional array of type T and name name as a state variable on the device (CPU/GPU) device.\nDEF_ARRAY2D_STATE(T, name, device, desc)\rDefine a two-dimensional array of type T and name as a state variable on the device (CPU/GPU) device.\nDEF_ARRAY3D_STATE(T, name, device, desc)\rDefine a three-dimensional array of type T and name as a state variable on the device (CPU/GPU) device.\nDEF_INSTANCE_STATE(T, name, desc)\rDefine an instance of input type T and name name as a state variable.\nDEF_ARRAYLIST_STATE(T, name, device, desc)\rDefine a one-dimensional dynamic list array of type T and name name as a state variable on the device (CPU/GPU) device.\n  Create function modules\nTaking RigidBodySystem as an example, the function modules created in the constructor are as follows:\n//Create a self-collision detection module auto elementQuery = std::make_shared\u0026lt;NeighborElementQuery\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;currentTopology()-\u0026gt;connect(elementQuery-\u0026gt;inDiscreteElements()); this-\u0026gt;stateCollisionMask()-\u0026gt;connect(elementQuery-\u0026gt;inCollisionMask()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(elementQuery); //Create a Bounding Box Collision Detection Function Module auto cdBV = std::make_shared\u0026lt;CollistionDetectionBoundingBox\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;currentTopology()-\u0026gt;connect(cdBV-\u0026gt;inDiscreteElements()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(cdBV); //Create a combined contact function block auto merge = std::make_shared\u0026lt;ContactsUnion\u0026lt;TDataType\u0026gt;\u0026gt;(); elementQuery-\u0026gt;outContacts()-\u0026gt;connect(merge-\u0026gt;inContactsA()); cdBV-\u0026gt;outContacts()-\u0026gt;connect(merge-\u0026gt;inContactsB()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(merge); //Create a Rigid Body Dynamics Solver Module auto iterSolver = std::make_shared\u0026lt;IterativeConstraintSolver\u0026lt;TDataType\u0026gt;\u0026gt;(); this-\u0026gt;varTimeStep()-\u0026gt;connect(iterSolver-\u0026gt;inTimeStep()); this-\u0026gt;varFrictionEnabled()-\u0026gt;connect(iterSolver-\u0026gt;varFrictionEnabled()); this-\u0026gt;stateMass()-\u0026gt;connect(iterSolver-\u0026gt;inMass()); this-\u0026gt;stateCenter()-\u0026gt;connect(iterSolver-\u0026gt;inCenter()); this-\u0026gt;stateVelocity()-\u0026gt;connect(iterSolver-\u0026gt;inVelocity()); this-\u0026gt;stateAngularVelocity()-\u0026gt;connect(iterSolver-\u0026gt;inAngularVelocity()); this-\u0026gt;stateRotationMatrix()-\u0026gt;connect(iterSolver-\u0026gt;inRotationMatrix()); this-\u0026gt;stateInertia()-\u0026gt;connect(iterSolver-\u0026gt;inInertia()); this-\u0026gt;stateQuaternion()-\u0026gt;connect(iterSolver-\u0026gt;inQuaternion()); this-\u0026gt;stateInitialInertia()-\u0026gt;connect(iterSolver-\u0026gt;inInitialInertia()); merge-\u0026gt;outContacts()-\u0026gt;connect(iterSolver-\u0026gt;inContacts()); this-\u0026gt;animationPipeline()-\u0026gt;pushModule(iterSolver);   Overload virtual function\nvirtual void preUpdateStates(); Status update pre-processing function\nvirtual void updateStates(); The state update function, the default is to call the pipeline to execute the default algorithm process\nvirtual void postUpdateStates(); Status update post-processing function\n  "
},
{
	"uri": "https://peridyno.github.io/en/examples/sph/gl_particleemitter/",
	"title": "Particle Fluid Emitter",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_fields/",
	"title": "Connection",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/rigidbody/gl_collisionmask/",
	"title": "Collision Mask",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/sph/gl_particlefluid/",
	"title": "Particle Fluid",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/rigidbody/gl_bricks/",
	"title": "Rigid Body Dynamics",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_clothoverball_1/",
	"title": "OceanPatch",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/heightfield/gl_oceanpatch/",
	"title": "OceanPatch",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/peridynamics/gl_plasticity/",
	"title": "plasticity",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/peridynamics/",
	"title": "peridynamics",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/tutorials/gl_mouseinteraction/",
	"title": "mouseInteraction",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/framework/",
	"title": "Framework",
	"tags": [],
	"description": "An introduction to the details of PeriDyno Framework. 
",
	"content": "1、Architecture overview "
},
{
	"uri": "https://peridyno.github.io/en/framework/scenegraph/modules/",
	"title": "Module",
	"tags": [],
	"description": "",
	"content": "1、Function introduction The module is a function-independent algorithm unit for internal calling of the node, which consists of input data, output data and control variables. The biggest difference between it and the node is that the input and output types only accept the Field type.\n2、How to implement a functional module It includes the following steps:\n  Define input data (usually at least one is required)\nSimilar to the definition in the node, the macro definition of DEF_{*}_IN is used to complete.\n  define output data (optional)\nSimilar to the definition in the node, the macro definition of DEF_{*}_OUT is used to complete.\n  Define control variables\nDEF_VAR(T, name, value, desc)\r\rControl variables must be initialized before module execution.\n\r  3、Module example /** * @brief The standard summation density * * @tparam TDataType */ template\u0026lt;typename TDataType\u0026gt; class SummationDensity : public virtual ParticleApproximation\u0026lt;TDataType\u0026gt; { DECLARE_TCLASS(SummationDensity, TDataType) public: typedef typename TDataType::Real Real; typedef typename TDataType::Coord Coord; SummationDensity(); ~SummationDensity() override {}; void compute() override; public: void compute( DArray\u0026lt;Real\u0026gt;\u0026amp; rho, DArray\u0026lt;Coord\u0026gt;\u0026amp; pos, DArrayList\u0026lt;int\u0026gt;\u0026amp; neighbors, Real smoothingLength, Real mass); void compute( DArray\u0026lt;Real\u0026gt;\u0026amp; rho, DArray\u0026lt;Coord\u0026gt;\u0026amp; pos, DArray\u0026lt;Coord\u0026gt;\u0026amp; posQueried, DArrayList\u0026lt;int\u0026gt;\u0026amp; neighbors, Real smoothingLength, Real mass); public: DEF_VAR(Real, RestDensity, 1000, \u0026#34;Rest Density\u0026#34;); ///Define inputs \t/** * @brief Particle positions */ DEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Particle position\u0026#34;); /** * @brief Particle positions */ DEF_ARRAY_IN(Coord, Other, DeviceType::GPU, \u0026#34;Particle position\u0026#34;); /** * @brief Neighboring particles * */ DEF_ARRAYLIST_IN(int, NeighborIds, DeviceType::GPU, \u0026#34;Neighboring particles\u0026#39; ids\u0026#34;); ///Define outputs \t/** * @brief Particle densities */ DEF_ARRAY_OUT(Real, Density, DeviceType::GPU, \u0026#34;Return the particle density\u0026#34;); private: void calculateParticleMass(); Real m_particle_mass; Real m_factor; }; IMPLEMENT_TCLASS(SummationDensity, TDataType) "
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_clothoverball_3/",
	"title": "Buoyancy",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/heightfield/qt_buoyancy/",
	"title": "Buoyancy",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_glvisualmodule/",
	"title": "Bricks",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/rigidbody/gl_timing/",
	"title": "Timing",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/",
	"title": "SPH",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/",
	"title": "Examples",
	"tags": [],
	"description": "A set of examples guiding users on how to set up different cases.
",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/tutorials/gl_mouseinteractioningraphicspipeline/",
	"title": "mouseInteractionInGraphicsPipeline",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/framework/scenegraph/fields/",
	"title": "Field",
	"tags": [],
	"description": "",
	"content": "1、Field function introduction Field mainly realizes data transfer between nodes and modules by encapsulating typical data types. As shown in the figure below, GLPointVisualNode passes point cloud data to InputFieldTest for use by defining Field of type FInstance.\nThe connection and disconnection between fields mainly depend on the implementation of the following two functions:\nvirtual bool connect(FBase* dst) = 0; virtual bool disconnect(FBase* dst); As the base class of all Fields, FBase mainly manages the connection status of Fields in a unified manner.\nconnect(FBase* dst) is a pure virtual function defined in FBase, so its specific implementation depends on a specific Field. The design is mainly to ensure the validity of the data connection, and to simulate connecting the data to the wrong type.\n\rAssuming that there are three Field types of data A, B, and C, their connection relationship is set to A-\u0026gt;B-\u0026gt;C. At this time, in order to reduce the data conversion and storage overhead, when we operate the data of C, it will return the data pointer at the top (corresponding to A) according to the connection relationship.\n2. Field type   FVar: Inherited from FBase, it is a package for a single data type, including scalar data, such as int, float, double; vector data, such as Vec3f; and second-order tensors, such as Mat3f. Nodes and modules can be defined by using macro definitions such as DEF_VAR/DEF_VAR_IN\nDEF_VAR(Real, RestDensity, 1000, \u0026#34;Rest Density\u0026#34;); 其中Real代表数据类型，RestDesntiy代表数据名称，1000代表初值，\u0026ldquo;Rest Density\u0026quot;则表示数据的说明。通过DEF_VAR定义的数据实际使用过程中可以通var+数据名称的方式对数据进行操作，假设我们需要将上述Field连接到另一个功能模块，则可以调用如下接口进行\nthis-\u0026gt;varRestDensity()-\u0026gt;connect(...);\r  FArray：The encapsulation of the one-dimensional array defined in Core/Array.h, similar to the vector in STL. According to its different functions in nodes/modules, we adopt the following three definitions:\nDEF_ARRAY_IN(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//input The access method of input data is in+data name, that is, inPosition()\nDEF_ARRAY_OUT(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//ouput The access method of input data is out+data name, namely outPosition()\nDEF_ARRAY_STATE(Coord, Position, DeviceType::GPU, \u0026#34;Internal state\u0026#34;);\t//internal state variable The access method of the state variable is state+data name, statePosition()\n  FArrayList：Encapsulation of Core/ArrayList.h data to support CPU/GPU compatible dynamic data types. It is defined in a similar way to FArray, i.e.\nDEF_ARRAYLIST_IN(Coord, Position, DeviceType::GPU, \u0026#34;Input\u0026#34;);\t//input The access method of input data is in+data name, that is, inPosition()\nDEF_ARRAYLIST_OUT(Coord, Position, DeviceType::GPU, \u0026#34;Output\u0026#34;);\t//ouput The access method of input data is out+data name, namely outPosition()\nDEF_ARRAYLIST_STATE(Coord, Position, DeviceType::GPU, \u0026#34;Internal state\u0026#34;);\t//internal state variable The access method of the state variable is state+data name, statePosition()\n  FInstance：Mainly to support the connection between data with inheritance relationship, the typical application is to use FInstance to define different topology data\nDEF_INSTANCE_IN(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;PointSet is derived from TopologyModule\u0026#34;);\t//input The access method of input data is in+data name, and any correspondence inherited from PointSetcan be connected to this data.\nDEF_INSTANCE_OUT(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;Output\u0026#34;);\t//output The access method of input data is out+data name\nDEF_INSTANCE_STATE(PointSet\u0026lt;TDataType\u0026gt;, PointSet, \u0026#34;Internal state\u0026#34;);\t//internal state variable The access method of the state variable is state+data name\n  Reference code src/Framework/FBase.h.\n\r"
},
{
	"uri": "https://peridyno.github.io/en/examples/rigidbody/",
	"title": "Rigid Body Dynamics",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_clothoverball_6/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/heightfield/qt_heightfild/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_glvisualnode/",
	"title": "Bricks",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/tutorials/gl_segmentvisualizer/",
	"title": "SegmentVisualizer",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/rigidbody/gl_wireframe/",
	"title": "Wireframe",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/topics/",
	"title": "Advanced Topics",
	"tags": [],
	"description": "Show your user how to work through some end to end examples.
",
	"content": "Tutorials are complete worked examples made up of multiple tasks that guide the user through a relatively simple but realistic scenario: building an application that uses some of your project’s features, for example. If you have already created some Examples for your project you can base Tutorials on them. This section is optional. However, remember that although you may not need this section at first, having tutorials can be useful to help your users engage with your example code, especially if there are aspects that need more explanation than you can easily provide in code comments.\n"
},
{
	"uri": "https://peridyno.github.io/en/reference/reflection/",
	"title": "Reflection",
	"tags": [],
	"description": "",
	"content": "1、what is reflection Assuming we know the name of a class, how can we dynamically generate an object of a class from the class name string?\nIn Java programming, this is not a problem. However, the language characteristics of C++ determine that it does not support generating objects through the class name string \u0026ldquo;ClassXX\u0026rdquo;, that is to say, in C++ we can use ClassXX* object =new ClassXX to generate objects, but not through ClassXX* object= new \u0026ldquo;ClassXX\u0026rdquo; to generate the object. This makes it impossible to achieve adaptive expansion when we expand the functions of nodes and modules, that is, if we introduce a new function module, the simulation engine cannot dynamically perceive its existence.\nThe reflection mechanism is introduced to solve the problem of adaptive expansion of simulation nodes and functional modules, thereby avoiding deep coupling between codes.\n2、C++ reflection principle Reference code src/Framework/Object.h.\n\r3、How extension modules support reflection All classes that need to support reflection need to inherit from Object. Taking the class implemented in src/Dynamics/ParticleSystem/SummationDensity.h as an example, the process of supporting reflection consists of two steps\n  Derived from Object or a subclass of Object\ntemplate\u0026lt;typename TDataType\u0026gt; class SummationDensity : public virtual ParticleApproximation\u0026lt;TDataType\u0026gt;   interface declaration\nDECLARE_CLASS(SummationDensity)\r//or\rDECLARE_TCLASS(SummationDensity, TDataType)\rAmong them, SummationDensity corresponds to the name of the class, and TDataType corresponds to the template parameter\n  interface implementation\nIMPLEMENT_TCLASS(SummationDensity)\r//or\rIMPLEMENT_TCLASS(SummationDensity, TDataType)\rAmong them, the registration of SummationDensity is completed by defining static variables through DECLARE_CLASS/DECLARE_TCLASS.\n  DECLARE_TCLASS and IMPLEMENT_TCLASS are required to be defined in the same header file. This method is valid for classes whose implementation files are cpp suffixes. However, there are still some problems with the current NVCC compiler. If the implementation file has a .cu suffix, the defined static variable cannot be initialized, and it needs to be done through an additional class.\n\rA feasible solution is to introduce an additional class for each static link library to complete the initialization, which is introduced in initializeParticleSystem.h\nclass ParticleSystemInitializer : public Object { public: ParticleSystemInitializer(); }; const static ParticleSystemInitializer particleSystemInitializer; At the same time, define and implement the following constructor in initializeParticleSystem.cpp to complete the explicit call to the class defined in the .cu file.\nParticleSystemInitializer::ParticleSystemInitializer() { TypeInfo::New\u0026lt;LinearDamping\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;ParticleIntegrator\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;ImplicitViscosity\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;DensityPBD\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;SummationDensity\u0026lt;DataType3f\u0026gt;\u0026gt;(); TypeInfo::New\u0026lt;VariationalApproximateProjection\u0026lt;DataType3f\u0026gt;\u0026gt;(); } Finally, add WHOLEARCHIVE to the CMakeLists.txt ({peridyno_Code_path}/examples/Qt_VtkVisualModule/CMakeLists.txt) of the Qt project: "
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_realtimecloth_v1/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_gui_empty/",
	"title": "Bricks",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/tutorials/gl_topology/",
	"title": "Topology",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/sph/",
	"title": "SPH",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/framework/rendering/",
	"title": "Rendering",
	"tags": [],
	"description": "",
	"content": "1、Introduction 2、Usage 3、Extending Rendering Module "
},
{
	"uri": "https://peridyno.github.io/en/framework/platform/",
	"title": "Platform",
	"tags": [],
	"description": "",
	"content": "2、Node operation logic management   Update run queue   void updateExecutionQueue(); The timing of the update mainly depends on whether the nodes in the scene graph and the connection relationship have changed. Once any item is changed, the node execution queue of the scene will update the run queue first the next time the node function is executed.\n update node status  void propagateNode(std::shared_ptr\u0026lt;Node\u0026gt; node); When the running state of a specific node changes, for example, the configuration parameters of the node are changed, the scene graph can update the state of all subsequent nodes that depend on the node by calling the propagateNode() function.\n3、Function expansion To be added\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_realtimecloth_v2/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_gui_plugin/",
	"title": "GUI Plugin",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/reference/",
	"title": "Reference",
	"tags": [],
	"description": "External resources related to physical-based simulations.
",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_rotatecylinder/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_marchingcubes/",
	"title": "MarchingCubes",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/contributing/",
	"title": "Contribution",
	"tags": [],
	"description": "See the list of contributors.
",
	"content": "Prerequisites and installation Install Hugo You need a recent extended version (we recommend version 0.53 or later) of Hugo to do local builds and previews of sites (like this one) that use Docsy. If you install from the release page, make sure to get the extended Hugo version, which supports SCSS.\nFor comprehensive Hugo documentation, see gohugo.io.\nTo see if you already have hugo installed and check the installed version, run the following commands:\nhugo version\rwindows 1.Download hugo executable file\nClick Here to download hugo executable file, you must download an extended version. For example, an 64bit windows OS should download hugo_extended_0.75.1_Windows-64bit.zip.\n2.Config the path\nConfig the path where .exe file exist to environment variables. The path should not have spaces, which may cause some unexpected problems.\nFor example, the path of D:\\Hugo\\bin is ok. The path of D:\\Program Files (x86)\\Hugo\\bin may cause some unexpected problems.\nLinux Do not use sudo apt-get install hugo, as it currently doesn\u0026rsquo;t get you the extended version.\nIf you\u0026rsquo;ve already installed Hugo, check your version:\nhugo version\rIf the result is v0.52 or earlier, or if you don\u0026rsquo;t see Extended, you\u0026rsquo;ll need to install the latest version.\n  Go to the Hugo releases page.\n  In the most recent release, scroll down until you find a list of Extended versions.\n  Download the latest extended version (hugo_extended_0.5X_Linux-64bit.tar.gz).\n  Create a new directory:\nmkdir hugo\r   Extract the files you downloaded to hugo.\n  Switch to your new directory:\ncd hugo\r   Install Hugo:\nsudo install hugo /usr/bin    macOS Install Hugo using Brew.\nInstall Node.js and npm To see if you already have Node.js and npm installed and check the installed version, run the following commands:\nnode -v\rnpm -v\rClick Here to download Node.js and install it.\nInstall PostCSS To build or update your site\u0026rsquo;s CSS resources, you also need PostCSS to create the final assets. If you need to install it, you must have a recent version of NodeJS installed on your machine so you can use npm, the Node package manager. By default npm installs tools under the directory where you run npm install:\nnpm install postcss --save-dev\rnpm install -D --save autoprefixer\rnpm install -D --save postcss-cli\rNote that versions of PostCSS later than 5.0.1 will not load autoprefixer if installed globally, you must use a local install.\nClone Peridyno webset code and run   Make a local working copy of the Peridyno webset directly using git clone:\ngit clone https://github.com/peridyno/peri-docs.git\r   Switch to the root of the cloned project, for example:\n cd peri-docs\r   Build your site:\n hugo server\r   Preview your site in your browser at: http://localhost:1313/. You can use Ctrl + c to stop the Hugo server whenever you like.\n  In the cmd of windows, enter into current folder, and input hugo server to launch the local server.\nPull requests Finally, you should make an \u0026ldquo;Pull requests\u0026rdquo; at our github repository. Thanks for your contribution to Peridyno opensource project!\nPublishing website   Generate public folder\n cd peridyno-doc\rhugo\r   Push files(If you have permission)\n cd public git init\rgit add -A\rgit commit -am \u0026quot;init\u0026quot;\rgit remote add origin https://github.com/peridyno/peri-docs.github.io\rgit push -f origin master\r   Modify Custom domain(If you have permission)\nEnter the settings of the peridynoTeam.github.io project(https://github.com/peridyno/peri-docs.github.io/settings). Add www.peridyno.com in Custom domain. Wait a few minutes, you can see Peridyno website on www.peridyno.com.\n  If our project is helpful to you, give a star and watch us!!! "
},
{
	"uri": "https://peridyno.github.io/en/contributing/docs/",
	"title": "Contribution",
	"tags": [],
	"description": "See the list of contributors.
",
	"content": "Prerequisites and installation Install Hugo You need a recent extended version (we recommend version 0.53 or later) of Hugo to do local builds and previews of sites (like this one) that use Docsy. If you install from the release page, make sure to get the extended Hugo version, which supports SCSS.\nFor comprehensive Hugo documentation, see gohugo.io.\nTo see if you already have hugo installed and check the installed version, run the following commands:\nhugo version\rwindows 1.Download hugo executable file\nClick Here to download hugo executable file, you must download an extended version. For example, an 64bit windows OS should download hugo_extended_0.75.1_Windows-64bit.zip.\n2.Config the path\nConfig the path where .exe file exist to environment variables. The path should not have spaces, which may cause some unexpected problems.\nFor example, the path of D:\\Hugo\\bin is ok. The path of D:\\Program Files (x86)\\Hugo\\bin may cause some unexpected problems.\nLinux Do not use sudo apt-get install hugo, as it currently doesn\u0026rsquo;t get you the extended version.\nIf you\u0026rsquo;ve already installed Hugo, check your version:\nhugo version\rIf the result is v0.52 or earlier, or if you don\u0026rsquo;t see Extended, you\u0026rsquo;ll need to install the latest version.\n  Go to the Hugo releases page.\n  In the most recent release, scroll down until you find a list of Extended versions.\n  Download the latest extended version (hugo_extended_0.5X_Linux-64bit.tar.gz).\n  Create a new directory:\nmkdir hugo\r   Extract the files you downloaded to hugo.\n  Switch to your new directory:\ncd hugo\r   Install Hugo:\nsudo install hugo /usr/bin    macOS Install Hugo using Brew.\nInstall Node.js and npm To see if you already have Node.js and npm installed and check the installed version, run the following commands:\nnode -v\rnpm -v\rClick Here to download Node.js and install it.\nInstall PostCSS To build or update your site\u0026rsquo;s CSS resources, you also need PostCSS to create the final assets. If you need to install it, you must have a recent version of NodeJS installed on your machine so you can use npm, the Node package manager. By default npm installs tools under the directory where you run npm install:\nnpm install postcss --save-dev\rnpm install -D --save autoprefixer\rnpm install -D --save postcss-cli\rNote that versions of PostCSS later than 5.0.1 will not load autoprefixer if installed globally, you must use a local install.\nClone Peridyno webset code and run   Make a local working copy of the Peridyno webset directly using git clone:\ngit clone https://github.com/peridyno/peri-docs.git\r   Switch to the root of the cloned project, for example:\n cd peri-docs\r   Build your site:\n hugo server\r   Preview your site in your browser at: http://localhost:1313/. You can use Ctrl + c to stop the Hugo server whenever you like.\n  In the cmd of windows, enter into current folder, and input hugo server to launch the local server.\nPull requests Finally, you should make an \u0026ldquo;Pull requests\u0026rdquo; at our github repository. Thanks for your contribution to Peridyno opensource project!\nPublishing website   Generate public folder\n cd peridyno-doc\rhugo\r   Push files(If you have permission)\n cd public git init\rgit add -A\rgit commit -am \u0026quot;init\u0026quot;\rgit remote add origin https://github.com/peridyno/peri-docs.github.io\rgit push -f origin master\r   Modify Custom domain(If you have permission)\nEnter the settings of the peridynoTeam.github.io project(https://github.com/peridyno/peri-docs.github.io/settings). Add www.peridyno.com in Custom domain. Wait a few minutes, you can see Peridyno website on www.peridyno.com.\n  If our project is helpful to you, give a star and watch us!!! "
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/cpd_shootingcloth/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_mouseinteractioningraphicspipeline/",
	"title": "Bricks",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/gl_clothwithcollision/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_pickers/",
	"title": "Pickers",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/codimensionalpd/qt_clothstudio/",
	"title": "Qt_HeightField",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_resetnode/",
	"title": "ResetNodes",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_selectnode/",
	"title": "ResetNodes",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_showchinese/",
	"title": "ShowChinese",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/examples/qt/qt_viewtest/",
	"title": "View Test",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/topics/rigidbodydynamics/narrowphase/",
	"title": "collision",
	"tags": [],
	"description": "",
	"content": "To be continued\u0026hellip;\n"
},
{
	"uri": "https://peridyno.github.io/en/topics/postprocessing/",
	"title": "Post Processing",
	"tags": [],
	"description": "PostProcessing
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/topics/proceduralmodeling/",
	"title": "Procedural Modeling",
	"tags": [],
	"description": "Procedural Modeling
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/topics/particlesystem/",
	"title": "Particle System",
	"tags": [],
	"description": "To be continued...
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/topics/rigidbodydynamics/",
	"title": "Rigid Body Dynamics",
	"tags": [],
	"description": "To be continued...
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/topics/fem/",
	"title": "Finite Element Method",
	"tags": [],
	"description": "To be continued...
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/topics/heightfield/",
	"title": "Height Field",
	"tags": [],
	"description": "Represent the water surface as a continuous planar grid
",
	"content": "General introduction A grid fluid simulation method based on a two-dimensional height field. This method represents the water surface as a continuous flat grid, and generates a series of continuous height textures corresponding to this network - called height maps. Each mesh vertex corresponds to a pixel of the height map, which is the height of the water surface, thus representing the entire water surface.\nThe height field fluid simulation is divided into two parts, shallow water wave simulation based on shallow water equation (SWE) and ocean wave simulation based on fast Fourier transform (FFT). The shallow water equation (SWE) is a mathematical model describing the flow of shallow water, and it is also an important mathematical model in hydraulics. The shallow water equations are based on the conservation of physical quantities with physical meaning, and can also be called hyperbolic conservation equations. The main idea of wave simulation based on fast Fourier transform (FFT) is to obtain the height field of the sea surface (that is, the frequency domain of the Fourier transform) according to the Phillips wave, and then inverse Fourier transform (IFFT) to obtain the sea surface. (aka time domain).\nShallow water wave simulation At present, the Gerstner model is widely used in large-scale water simulation in real-time systems. Although Gerstner Wave is suitable for modeling large-scale water bodies, it has limited ability to display fine-scale water waves and cannot reflect the interaction of water bodies and rigid bodies. In view of this, this project uses the shallow water equation to achieve fine-scale water wave simulation:\n\\begin{array}{l} \\frac{{\\partial h}}{{\\partial t}} + \\frac{\\partial }{{\\partial x}}\\left( {hu} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {hv} \\right) = 0 \\\\\n\\frac{\\partial }{{\\partial t}}\\left( {hu} \\right) + \\frac{\\partial }{{\\partial x}}\\left( {\\frac{{h{u^2}}}{2}} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {huv} \\right) = - gh\\frac{{\\partial s}}{{\\partial x}} \\\\\n\\frac{\\partial }{{\\partial t}}\\left( {hv} \\right) + \\frac{\\partial }{{\\partial x}}\\left( {huv} \\right) + \\frac{\\partial }{{\\partial y}}\\left( {\\frac{{h{v^2}}}{2}} \\right) = - gh\\frac{{\\partial s}}{{\\partial y}} \\end{array}\nAmong them, u and v represent the two components of the horizontal velocity of the ocean current, h represents the depth of the ocean current, s represents the vertical coordinate of the sea surface, and g represents the acceleration of gravity. In the solution process, the simulation area is firstly discretized based on the height field as shown in the figure below.\nThen, the position of the height field at each moment is calculated by solving the wave equation. Finally, the height field based on the shallow water equation (SWE) is superimposed on the large area water body to achieve a more realistic water body simulation.\nFirst initialize the initial height of the water surface. For the height of the water surface boundary, after each calculation:\na) The height value of the particle at point x=0 is equal to the height value of the particle at point x=1; b) The particle height value of x= width - 1 point is equal to the particle height value of x= width - 2 points; c) The particle height value at y=0 point is equal to the particle height value at y=1 point; d) The height of the particle at y= height- 1 is equal to the height of the particle at y= height - 2. \r参考代码src\\Dynamics\\HeightField\\CapillaryWave.cu。\n\r__global__ void C_ImposeBC(Vec4f* grid_next, Vec4f* grid, int width, int height, int pitch) { int x = threadIdx.x + blockIdx.x * blockDim.x; int y = threadIdx.y + blockIdx.y * blockDim.y; if (x \u0026lt; width \u0026amp;\u0026amp; y \u0026lt; height) { if (x == 0) { Vec4f a = grid[(y)*pitch + 1]; grid_next[(y)*pitch + x] = a; } else if (x == width - 1) { Vec4f a = grid[(y)*pitch + width - 2]; grid_next[(y)*pitch + x] = a; } else if (y == 0) { Vec4f a = grid[(1) * pitch + x]; grid_next[(y)*pitch + x] = a; } else if (y == height - 1) { Vec4f a = grid[(height - 2) * pitch + x]; grid_next[(y)*pitch + x] = a; } else { Vec4f a = grid[(y)*pitch + x]; grid_next[(y)*pitch + x] = a; } } } Iterate over the height field at each time:\n__global__ void C_OneWaveStep(Vec4f* grid_next, Vec4f* grid, int width, int height, float timestep, int pitch) Finally, calculate the two components of the horizontal velocity of the u and v ocean currents, the depth of the h ocean current, and the s vertical coordinate of the sea surface.\n__global__ void C_InitHeightField( Vec4f* height, Vec4f* grid, int patchSize, float horizon, float realSize) { int i = threadIdx.x + blockIdx.x * blockDim.x; int j = threadIdx.y + blockIdx.y * blockDim.y; if (i \u0026lt; patchSize \u0026amp;\u0026amp; j \u0026lt; patchSize) { int gridx = i + 1; int gridy = j + 1; Vec4f gp = grid[gridx + patchSize * gridy]; height[i + j * patchSize].x = gp.x - horizon; float d = sqrtf((i - patchSize / 2) * (i - patchSize / 2) + (j - patchSize / 2) * (j - patchSize / 2)); float q = d / (0.49f * patchSize); float weight = q \u0026lt; 1.0f ? 1.0f - q * q : 0.0f; height[i + j * patchSize].y = 1.3f * realSize * sinf(3.0f * weight * height[i + j * patchSize].x * 0.5f * M_PI); } } Wave Simulation Based on Fast Fourier Transform (FFT) The FFT model is a statistical model. Unlike the Gerstner model, which uses multiple sine and cosine functions to fit, the FFT model uses Fourier transform. The core of Fourier transform is to use sin(nx) and cos(nx) to simulate any periodic function. In the FFT model, the wave height is represented by a random function h(x,t) of time and level. This method has high simulation degree and is easy to model, and its calculation formula is as follows[1]：\n$$h(X,t) = \\sum\\limits_K^{} {\\tilde h(K,t){{\\mathop{\\rm e}\\nolimits} ^{(iK{\\rm{X}})}}} $$\nIn the formula, $X{\\rm{ = }}(x, z)$ horizontal position; $t$ represents time; $K$ is a two-dimensional vector; $\\tilde h(k,t)$ represents the surface structure of waves .\nAfter building the height field of the FFT model, the next step is to create a random height field. Introduce a Gaussian random function, as follows:\n$${\\tilde h_0}(K) = \\frac{1}{{\\sqrt 2 }}({\\xi _r} + i{\\xi _i})\\sqrt {{P_h}(K)} $$\nAmong them, ${\\xi _r}$ and ${\\xi _i}$ are independent Gaussian random numbers (mean 0, variance 1). At this time, the amplitude of the wave at time $t$ is:\n$$\\tilde h(K,t) = \\tilde h(K){e^{i\\omega (K)t}} + \\tilde h_0^*( - K){e^{ - i\\omega ({\\rm{K}})t}}$$\nAmong them, $\\omega (k)$ is the angular frequency of the wave $K$, which can be calculated according to ${\\omega ^2}(k) = g|K|$; the * sign represents the conjugate operation of complex numbers. According to the FFT model, the height of the ocean wave must eventually be a real number, so it must satisfy $\\tilde h(-K)= \\tilde h_0^*(K)$.\ntemplate\u0026lt;typename TDataType\u0026gt; void OceanPatch\u0026lt;TDataType\u0026gt;::generateH0(Vec2f* h0) { for (unsigned int y = 0; y \u0026lt;= mResolution; y++) { for (unsigned int x = 0; x \u0026lt;= mResolution; x++) { float kx = (-( int )mResolution / 2.0f + x) * (2.0f * CUDART_PI_F / m_realPatchSize); float ky = (-( int )mResolution / 2.0f + y) * (2.0f * CUDART_PI_F / m_realPatchSize); float P = sqrtf(phillips(kx, ky, windDir, m_windSpeed, A, dirDepend)); if (kx == 0.0f \u0026amp;\u0026amp; ky == 0.0f) { P = 0.0f; } float Er = gauss(); float Ei = gauss(); float h0_re = Er * P * CUDART_SQRT_HALF_F; float h0_im = Ei * P * CUDART_SQRT_HALF_F; int i = y * mSpectrumWidth + x; h0[i].x = h0_re; h0[i].y = h0_im; } } } Initialize phase and amplitude. The spectrum can be the Phillips spectrum. Phillips spectrum is suitable for parallelized computation of sea surface grids. It is a more realistic spectrum and is mostly used under the influence of wind. The Phillips spectrum is defined as follows:\n$${P_h}(K) = A\\frac{{\\exp ( - 1/{{(kL)}^2})}}{{{k^4}}}|\\hat K\\hat \\omega {|^2}$$\nAmong them, $g$ represents the acceleration of gravity; $k = |K| = 2\\pi / \\lambda $; $\\lambda $ represents the wavelength; $A$ represents a constant coefficient; $L = {V^2}/g$ Represents the maximum wave generated by the wind speed in the case of $V$; $\\hat \\omega $ represents the wind direction; $|\\hat K\\hat \\omega {|^2}$ represents the elimination of waves that move perpendicular to the wind direction.\n// generate wave heightfield at time t based on initial heightfield and dispersion relationship __global__ void generateSpectrumKernel(Vec2f* h0, Vec2f* ht, unsigned int in_width, unsigned int out_width, unsigned int out_height, float t, float patchSize) { unsigned int x = blockIdx.x * blockDim.x + threadIdx.x; unsigned int y = blockIdx.y * blockDim.y + threadIdx.y; unsigned int in_index = y * in_width + x; unsigned int in_mindex = (out_height - y) * in_width + (out_width - x); // mirrored  unsigned int out_index = y * out_width + x; // calculate wave vector  Vec2f k; k.x = (-( int )out_width / 2.0f + x) * (2.0f * CUDART_PI_F / patchSize); k.y = (-( int )out_width / 2.0f + y) * (2.0f * CUDART_PI_F / patchSize); // calculate dispersion w(k)  float k_len = sqrtf(k.x * k.x + k.y * k.y); float w = sqrtf(9.81f * k_len); if ((x \u0026lt; out_width) \u0026amp;\u0026amp; (y \u0026lt; out_height)) { Vec2f h0_k = h0[in_index]; Vec2f h0_mk = h0[in_mindex]; // output frequency-space complex values  ht[out_index] = complex_add(complex_mult(h0_k, complex_exp(w * t)), complex_mult(conjugate(h0_mk), complex_exp(-w * t))); //ht[out_index] = h0_k;  } } In the process of fluid simulation using the FFT model, the normal vector of the surface needs to be calculated from the slope of each point. In the actual calculation process, the finite difference of adjacent grid points is generally used to calculate the slope value. However, in order to reduce the slope error of the wavelet wavelength, the inverse FFT transformation can be used to solve:\n$$\\nabla h(X,t) = \\sum\\limits_K^{} {iK\\tilde h(K,t)\\exp (iKX)} $$\ncufftExecC2C(fftPlan, (float2*)m_ht, (float2*)m_ht, CUFFT_INVERSE); cufftExecC2C(fftPlan, (float2*)m_Dxt, (float2*)m_Dxt, CUFFT_INVERSE); cufftExecC2C(fftPlan, (float2*)m_Dzt, (float2*)m_Dzt, CUFFT_INVERSE); In addition, a bias vector D(x,t) is needed to simulate the wave tip of seawater, which can be set as follows:\n$$D(x,t) = \\sum\\limits_k { - i\\frac{k}{{|k|}}h(k,t){e^{ikx}}} $$\nwhere the Jacobian matrix is:\n\\begin{equation} J\\left( x \\right) =\\left| \\begin{matrix} J_{xx}\u0026amp;\tJ_{xy}\\\\\nJ_{zx}\u0026amp;\tJ_{yy}\\\\\n\\end{matrix} \\right| \\end{equation}\n$$ \\begin{array}{l} J_{xx}=\\frac{\\partial x^{'}}{\\partial x}=1+\\lambda \\frac{\\partial D_x\\left( x,t \\right)}{\\partial x}\\\\\nJ_{yy}=\\frac{\\partial y^{'}}{\\partial y}=1+\\lambda \\frac{\\partial D_y\\left( x,t \\right)}{\\partial y}\\\\\nJ_{yx}=\\frac{\\partial y^{'}}{\\partial x}=\\lambda \\frac{\\partial D_y\\left( x,t \\right)}{\\partial x}\\\\\nJ_{xy}=\\frac{\\partial x^{'}}{\\partial y}=\\lambda \\frac{\\partial D_x\\left( x,t \\right)}{\\partial y}\\\\\n\\end{array} $$\nReferences [1] Tessendorf J. Simulating ocean water[J]. Simulating nature: realistic and interactive techniques. SIGGRAPH, 2001, 1(2): 5.\n"
},
{
	"uri": "https://peridyno.github.io/en/topics/rigidbodydynamics/broadphase/",
	"title": "Rigid body collision",
	"tags": [],
	"description": "Rigid body collision
",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/",
	"title": "PeriDyno",
	"tags": [],
	"description": "",
	"content": "PERIDYNO "
},
{
	"uri": "https://peridyno.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peridyno.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]